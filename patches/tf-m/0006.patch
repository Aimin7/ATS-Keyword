diff --git a/lib/tf-m/bl2/ext/mcuboot/bl2_main.c b/lib/tf-m/bl2/ext/mcuboot/bl2_main.c
index 1674e133b..987623927 100644
--- a/lib/tf-m/bl2/ext/mcuboot/bl2_main.c
+++ b/lib/tf-m/bl2/ext/mcuboot/bl2_main.c
@@ -29,8 +29,6 @@
 #include "flash_map_backend/flash_map_backend.h"
 #include "boot_hal.h"
 #include "uart_stdout.h"
-#include "tfm_plat_otp.h"
-#include "tfm_plat_provisioning.h"
 
 /* Avoids the semihosting issue */
 #if defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
@@ -87,7 +85,6 @@ int main(void)
 {
     struct boot_rsp rsp;
     fih_int fih_rc = FIH_FAILURE;
-    enum tfm_plat_err_t plat_err;
 
     /* Initialise the mbedtls static memory allocator so that mbedtls allocates
      * memory from the provided static buffer instead of from the heap.
@@ -106,22 +103,6 @@ int main(void)
 
     BOOT_LOG_INF("Starting bootloader");
 
-    plat_err = tfm_plat_otp_init();
-    if (plat_err != TFM_PLAT_ERR_SUCCESS) {
-            BOOT_LOG_ERR("OTP system initialization failed");
-            FIH_PANIC;
-    }
-
-    if (tfm_plat_provisioning_is_required()) {
-        plat_err = tfm_plat_provisioning_perform();
-        if (plat_err != TFM_PLAT_ERR_SUCCESS) {
-            BOOT_LOG_ERR("Provisioning failed");
-            FIH_PANIC;
-        }
-    } else {
-        tfm_plat_provisioning_check_for_dummy_keys();
-    }
-
     FIH_CALL(boot_nv_security_counter_init, fih_rc);
     if (fih_not_eq(fih_rc, FIH_SUCCESS)) {
         BOOT_LOG_ERR("Error while initializing the security counter");
diff --git a/lib/tf-m/bl2/ext/mcuboot/include/sysflash/sysflash.h b/lib/tf-m/bl2/ext/mcuboot/include/sysflash/sysflash.h
index b5d166dc4..33f92902c 100644
--- a/lib/tf-m/bl2/ext/mcuboot/include/sysflash/sysflash.h
+++ b/lib/tf-m/bl2/ext/mcuboot/include/sysflash/sysflash.h
@@ -4,7 +4,7 @@
  * Original code taken from mcuboot project at:
  * https://github.com/mcu-tools/mcuboot
  * Git SHA of the original version: ac55554059147fff718015be9f4bd3108123f50a
- * Modifications are Copyright (c) 2020-2021 Arm Limited.
+ * Modifications are Copyright (c) 2020 Arm Limited.
  */
 
 #ifndef __SYSFLASH_H__
@@ -16,8 +16,6 @@
 extern "C" {
 #endif
 
-#ifdef DEFAULT_MCUBOOT_FLASH_MAP
-
 #if (MCUBOOT_IMAGE_NUMBER == 1)
 /*
  * NOTE: the definition below returns the same values for true/false on
@@ -45,8 +43,6 @@ extern "C" {
 
 #define FLASH_AREA_IMAGE_SCRATCH        FLASH_AREA_SCRATCH_ID
 
-#endif /* DEFAULT_MCUBOOT_FLASH_MAP */
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/tf-m/bl2/ext/mcuboot/include/target.h b/lib/tf-m/bl2/ext/mcuboot/include/target.h
index a32dbf22e..9ead12986 100644
--- a/lib/tf-m/bl2/ext/mcuboot/include/target.h
+++ b/lib/tf-m/bl2/ext/mcuboot/include/target.h
@@ -1,6 +1,6 @@
 /*
  *  Copyright (C) 2017, Linaro Ltd
- *  Copyright (c) 2018-2021, Arm Limited.
+ *  Copyright (c) 2018-2020, Arm Limited.
  *
  *  SPDX-License-Identifier: Apache-2.0
  */
@@ -19,9 +19,6 @@
  */
 #include "flash_layout.h"
 
-#ifdef DEFAULT_MCUBOOT_FLASH_MAP
-/* No need to check the platform defines if custom flash map is used */
-
 #ifndef FLASH_BASE_ADDRESS
 #error "FLASH_BASE_ADDRESS must be defined by the target"
 #endif
@@ -121,6 +118,4 @@ or not by target"
 #error "MCUBOOT_MAX_IMG_SECTORS must be defined by the target"
 #endif
 
-#endif /* DEFAULT_MCUBOOT_FLASH_MAP */
-
 #endif /* H_TARGETS_TARGET_ */
diff --git a/lib/tf-m/bl2/src/flash_map.c b/lib/tf-m/bl2/src/flash_map.c
index 252bfe5a2..ffb04ee37 100644
--- a/lib/tf-m/bl2/src/flash_map.c
+++ b/lib/tf-m/bl2/src/flash_map.c
@@ -13,22 +13,86 @@
 #include "bootutil/bootutil_log.h"
 #include "Driver_Flash.h"
 
-#define FLASH_PROGRAM_UNIT    TFM_HAL_FLASH_PROGRAM_UNIT
+/* When undefined FLASH_DEV_NAME_0 or FLASH_DEVICE_ID_0 , default */
+#if !defined(FLASH_DEV_NAME_0) || !defined(FLASH_DEVICE_ID_0)
+#define FLASH_DEV_NAME_0  FLASH_DEV_NAME
+#define FLASH_DEVICE_ID_0 FLASH_DEVICE_ID
+#endif
 
-/**
- * Return the greatest value not greater than `value` that is aligned to
- * `alignment`.
- */
-#define FLOOR_ALIGN(value, alignment) ((value) & ~((alignment) - 1))
+/* When undefined FLASH_DEV_NAME_1 or FLASH_DEVICE_ID_1 , default */
+#if !defined(FLASH_DEV_NAME_1) || !defined(FLASH_DEVICE_ID_1)
+#define FLASH_DEV_NAME_1  FLASH_DEV_NAME
+#define FLASH_DEVICE_ID_1 FLASH_DEVICE_ID
+#endif
 
-/**
- * Return the least value not less than `value` that is aligned to `alignment`.
- */
-#define CEILING_ALIGN(value, alignment) \
-                         (((value) + ((alignment) - 1)) & ~((alignment) - 1))
+/* When undefined FLASH_DEV_NAME_2 or FLASH_DEVICE_ID_2 , default */
+#if !defined(FLASH_DEV_NAME_2) || !defined(FLASH_DEVICE_ID_2)
+#define FLASH_DEV_NAME_2  FLASH_DEV_NAME
+#define FLASH_DEVICE_ID_2 FLASH_DEVICE_ID
+#endif
+
+/* When undefined FLASH_DEV_NAME_3 or FLASH_DEVICE_ID_3 , default */
+#if !defined(FLASH_DEV_NAME_3) || !defined(FLASH_DEVICE_ID_3)
+#define FLASH_DEV_NAME_3  FLASH_DEV_NAME
+#define FLASH_DEVICE_ID_3 FLASH_DEVICE_ID
+#endif
 
-extern const struct flash_area flash_map[];
-extern const int flash_map_entry_num;
+/* When undefined FLASH_DEV_NAME_SCRATCH or FLASH_DEVICE_ID_SCRATCH , default */
+#if !defined(FLASH_DEV_NAME_SCRATCH) || !defined(FLASH_DEVICE_ID_SCRATCH)
+#define FLASH_DEV_NAME_SCRATCH  FLASH_DEV_NAME
+#define FLASH_DEVICE_ID_SCRATCH FLASH_DEVICE_ID
+#endif
+
+#define ARRAY_SIZE(arr) (sizeof(arr)/sizeof((arr)[0]))
+
+/* Flash device names must be specified by target */
+extern ARM_DRIVER_FLASH FLASH_DEV_NAME_0;
+extern ARM_DRIVER_FLASH FLASH_DEV_NAME_1;
+extern ARM_DRIVER_FLASH FLASH_DEV_NAME_2;
+extern ARM_DRIVER_FLASH FLASH_DEV_NAME_3;
+extern ARM_DRIVER_FLASH FLASH_DEV_NAME_SCRATCH;
+
+static const struct flash_area flash_map[] = {
+    {
+        .fa_id = FLASH_AREA_0_ID,
+        .fa_device_id = FLASH_DEVICE_ID_0,
+        .fa_driver = &FLASH_DEV_NAME_0,
+        .fa_off = FLASH_AREA_0_OFFSET,
+        .fa_size = FLASH_AREA_0_SIZE,
+    },
+    {
+        .fa_id = FLASH_AREA_2_ID,
+        .fa_device_id = FLASH_DEVICE_ID_2,
+        .fa_driver = &FLASH_DEV_NAME_2,
+        .fa_off = FLASH_AREA_2_OFFSET,
+        .fa_size = FLASH_AREA_2_SIZE,
+    },
+#if (MCUBOOT_IMAGE_NUMBER == 2)
+    {
+        .fa_id = FLASH_AREA_1_ID,
+        .fa_device_id = FLASH_DEVICE_ID_1,
+        .fa_driver = &FLASH_DEV_NAME_1,
+        .fa_off = FLASH_AREA_1_OFFSET,
+        .fa_size = FLASH_AREA_1_SIZE,
+    },
+    {
+        .fa_id = FLASH_AREA_3_ID,
+        .fa_device_id = FLASH_DEVICE_ID_3,
+        .fa_driver = &FLASH_DEV_NAME_3,
+        .fa_off = FLASH_AREA_3_OFFSET,
+        .fa_size = FLASH_AREA_3_SIZE,
+    },
+#endif
+    {
+        .fa_id = FLASH_AREA_SCRATCH_ID,
+        .fa_device_id = FLASH_DEVICE_ID_SCRATCH,
+        .fa_driver = &FLASH_DEV_NAME_SCRATCH,
+        .fa_off = FLASH_AREA_SCRATCH_OFFSET,
+        .fa_size = FLASH_AREA_SCRATCH_SIZE,
+    },
+};
+
+static const int flash_map_entry_num = ARRAY_SIZE(flash_map);
 
 /*
  * Check the target address in the flash_area_xxx operation.
@@ -82,226 +146,28 @@ void flash_area_close(const struct flash_area *area)
     /* Nothing to do. */
 }
 
-/*
- * Read/write/erase. Offset is relative from beginning of flash area.
- * `off` and `len` can be any alignment.
- * Return 0 on success, other value on failure.
- */
 int flash_area_read(const struct flash_area *area, uint32_t off, void *dst,
                     uint32_t len)
 {
-    uint32_t remaining_len;
-    uint32_t aligned_off;
-    uint8_t temp_buffer[sizeof(uint32_t)];
-    uint8_t align_unit, i = 0;
-    int ret = 0;
-
-    /* Valid entries for data item width */
-    uint32_t data_width_byte[] = {
-        sizeof(uint8_t),
-        sizeof(uint16_t),
-        sizeof(uint32_t),
-    };
-    ARM_FLASH_CAPABILITIES DriverCapabilities;
-
     BOOT_LOG_DBG("read area=%d, off=%#x, len=%#x", area->fa_id, off, len);
 
     if (!is_range_valid(area, off, len)) {
         return -1;
     }
-    remaining_len = len;
-
-    /* CMSIS ARM_FLASH_ReadData API requires the `addr` data type size aligned.
-     * Data type size is specified by the data_width in ARM_FLASH_CAPABILITIES.
-     */
-    DriverCapabilities = DRV_FLASH_AREA(area)->GetCapabilities();
-    align_unit = data_width_byte[DriverCapabilities.data_width];
-    aligned_off = FLOOR_ALIGN(off, align_unit);
-
-    /* Read the first align_unit long data if `off` is not aligned. */
-    if (aligned_off != off) {
-        ret = DRV_FLASH_AREA(area)->ReadData(area->fa_off + aligned_off,
-                                             temp_buffer,
-                                             align_unit);
-        if (ret < 0) {
-            return ret;
-        }
 
-        /* Copy the read data from off. */
-        for (i = 0; i + off - aligned_off < align_unit; i++) {
-            ((uint8_t *)dst)[i] = temp_buffer[i + off - aligned_off];
-        }
-        remaining_len -= align_unit - (off - aligned_off);
-    }
-
-    /* CMSIS ARM_FLASH_ReadData does not require the alignment of `cnt`.*/
-    if (remaining_len) {
-        ret = DRV_FLASH_AREA(area)->ReadData(area->fa_off + off + i,
-                                             (uint8_t *)dst + i,
-                                             remaining_len);
-    }
-
-    /* CMSIS ARM_FLASH_ReadData can return the number of data items read or
-     * Status Error Codes which are negative for failures.
-     */
-    if (ret < 0) {
-        return ret;
-    } else {
-        return 0;
-    }
+    return DRV_FLASH_AREA(area)->ReadData(area->fa_off + off, dst, len);
 }
 
-/* Writes `len` bytes of flash memory at `off` from the buffer at `src`.
- * `off` and `len` can be any alignment.
- */
 int flash_area_write(const struct flash_area *area, uint32_t off,
                      const void *src, uint32_t len)
 {
-    uint8_t add_padding[FLASH_PROGRAM_UNIT];
-#if (FLASH_PROGRAM_UNIT == 1)
-    uint8_t len_padding[FLASH_PROGRAM_UNIT]; /* zero sized arrayas are illegal C */
-#else
-    uint8_t len_padding[FLASH_PROGRAM_UNIT - 1];
-#endif
-
-    /* The PROGRAM_UNIT aligned value of `off` */
-    uint32_t aligned_off;
-
-    /* The total write length. */
-    uint32_t aligned_len;
-    uint32_t i, k;
-
-    /* The index in src[] that has been programmed. */
-    uint32_t src_written_idx = 0;
-    uint32_t add_padding_size, len_padding_size;
-    uint32_t write_size;
-    uint32_t last_unit_start_off = 0;
-    /*
-     *    aligned_off           off           last_unit_start_off
-     *        |                  |                     |
-     *        | add_padding_size |                     |   | len_padding_size  |
-     *        |+++++++++++++++++++**|******************|***@@@@@@@@@@@@@@@@@@@@|
-     *        |                     |                  |                       |
-     * ---->--|---- PROGRAM UNIT ---|-- PROGRAM UNIT --|---- PROGRAM UNIT -----|
-     *        |                     |                  |                       |
-     *        |+++++++++++++++++++**|******************|***@@@@@@@@@@@@@@@@@@@@|
-     *                            |<-------- len --------->|
-     */
-
     BOOT_LOG_DBG("write area=%d, off=%#x, len=%#x", area->fa_id, off, len);
 
-    /* Align the target address. The area->fa_off should already be aligned. */
-    aligned_off = FLOOR_ALIGN(off, FLASH_PROGRAM_UNIT);
-    add_padding_size = off - aligned_off;
     if (!is_range_valid(area, off, len)) {
         return -1;
     }
 
-    /* Read the bytes from aligned_off to off. */
-    if (flash_area_read(area, aligned_off, add_padding, add_padding_size)) {
-        return -1;
-    }
-
-    /* Align the write size */
-    aligned_len = CEILING_ALIGN(len + add_padding_size, FLASH_PROGRAM_UNIT);
-    len_padding_size = aligned_len - len - add_padding_size;
-    if (!is_range_valid(area, aligned_off, aligned_len)) {
-        return -1;
-    }
-
-    /* Read the bytes from (off + len) to (off + aligned_len). */
-    if (flash_area_read(area, off + len, len_padding,
-                        len_padding_size)) {
-        return -1;
-    }
-
-    /* Program the first FLASH_PROGRAM_UNIT. */
-    if (add_padding_size) {
-        /* Fill the first program unit bytes with data from src. */
-        for (i = add_padding_size, src_written_idx = 0;
-             i < FLASH_PROGRAM_UNIT && src_written_idx < len;
-             i++, src_written_idx++) {
-            add_padding[i] = ((uint8_t *)src)[src_written_idx];
-        }
-        if (src_written_idx == len) {
-            /* aligned_len equals to FLASH_PROGRAM_UNIT in this case.
-             * Fill the len_padding_size datas into add_padding.
-             */
-            for (k = 0; i < FLASH_PROGRAM_UNIT && k < len_padding_size;
-                 i++, k++) {
-                add_padding[i] = len_padding[k];
-            }
-            if (k != len_padding_size) {
-                return -1;
-            }
-        }
-
-        /* Check the first program unit bytes are all filled. */
-        if (i != FLASH_PROGRAM_UNIT) {
-            return -1;
-        }
-        if (DRV_FLASH_AREA(area)->ProgramData(area->fa_off + aligned_off,
-                                              add_padding,
-                                              FLASH_PROGRAM_UNIT)) {
-            return -1;
-        }
-    }
-
-    /* 'src_written_idx' indicates the number of the src data which has already
-     * been programed into flash. 'src_written_idx' equals to 'len' means that
-     * all the data in src has been programmed and aligned_len equals to
-     * FLASH_PROGRAM_UNIT. This case has been handled above.
-     * 'src_written_idx' less than 'len' means that not all the data in src has
-     * been programmed.
-     */
-    if (src_written_idx < len) {
-        /* Program from the first aligned bytes(src_written_idx) to the last
-         * aligned bytes in src.
-         */
-        write_size = FLOOR_ALIGN(len - src_written_idx, FLASH_PROGRAM_UNIT);
-        if (write_size > 0) {
-            if (DRV_FLASH_AREA(area)->ProgramData(
-                                           area->fa_off + off + src_written_idx,
-                                           src,
-                                           write_size)) {
-                return -1;
-            }
-            src_written_idx += write_size;
-        }
-        last_unit_start_off = src_written_idx;
-
-        /* Program the last program unit data into flash. */
-        if (len_padding_size) {
-            /* Copy the last unaligned bytes in src to add_padding. */
-            for (i = 0; i < FLASH_PROGRAM_UNIT && src_written_idx < len;
-                 i++, src_written_idx++) {
-                add_padding[i] = ((uint8_t *)src)[src_written_idx];
-            }
-
-            if (src_written_idx != len) {
-                return -1;
-            }
-            /* Copy the len_padding_size bytes in len_padding to add_padding. */
-            for (k = 0; i < FLASH_PROGRAM_UNIT && k < len_padding_size;
-                 i++, k++) {
-                add_padding[i] = len_padding[k];
-            }
-            write_size = add_padding_size + last_unit_start_off +
-                         FLASH_PROGRAM_UNIT;
-            if (i != FLASH_PROGRAM_UNIT || k != len_padding_size ||
-                aligned_len != write_size) {
-                return -1;
-            }
-            if (DRV_FLASH_AREA(area)->ProgramData(
-                                area->fa_off + off + last_unit_start_off,
-                                add_padding,
-                                FLASH_PROGRAM_UNIT)) {
-                return -1;
-            }
-        }
-    }
-
-    return 0;
+    return DRV_FLASH_AREA(area)->ProgramData(area->fa_off + off, src, len);
 }
 
 int flash_area_erase(const struct flash_area *area, uint32_t off, uint32_t len)
diff --git a/lib/tf-m/bl2/src/security_cnt.c b/lib/tf-m/bl2/src/security_cnt.c
index 7ee6bb05a..7fc6e4c29 100644
--- a/lib/tf-m/bl2/src/security_cnt.c
+++ b/lib/tf-m/bl2/src/security_cnt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -11,10 +11,9 @@
 #include "bootutil/fault_injection_hardening.h"
 #include <stdint.h>
 
-#define TFM_BOOT_NV_COUNTER_0    PLAT_NV_COUNTER_BL2_0   /* NV counter of Image 0 */
-#define TFM_BOOT_NV_COUNTER_1    PLAT_NV_COUNTER_BL2_1   /* NV counter of Image 1 */
-#define TFM_BOOT_NV_COUNTER_2    PLAT_NV_COUNTER_BL2_2   /* NV counter of Image 2 */
-#define TFM_BOOT_NV_COUNTER_MAX  PLAT_NV_COUNTER_BL2_2 + 1
+#define TFM_BOOT_NV_COUNTER_0    PLAT_NV_COUNTER_3   /* NV counter of Image 0 */
+#define TFM_BOOT_NV_COUNTER_1    PLAT_NV_COUNTER_4   /* NV counter of Image 1 */
+#define TFM_BOOT_NV_COUNTER_MAX  PLAT_NV_COUNTER_MAX
 
 static enum tfm_nv_counter_t get_nv_counter_from_image_id(uint32_t image_id)
 {
@@ -56,7 +55,7 @@ fih_int boot_nv_security_counter_get(uint32_t image_id, fih_int *security_cnt)
     }
 
     nv_counter = get_nv_counter_from_image_id(image_id);
-    if (nv_counter >= TFM_BOOT_NV_COUNTER_MAX) {
+    if (nv_counter == TFM_BOOT_NV_COUNTER_MAX) {
         FIH_RET(FIH_FAILURE);
     }
 
@@ -76,7 +75,7 @@ int32_t boot_nv_security_counter_update(uint32_t image_id,
     enum tfm_plat_err_t err;
 
     nv_counter = get_nv_counter_from_image_id(image_id);
-    if (nv_counter >= TFM_BOOT_NV_COUNTER_MAX) {
+    if (nv_counter == TFM_BOOT_NV_COUNTER_MAX) {
         return -1;
     }
 
diff --git a/lib/tf-m/interface/include/psa/crypto_compat.h b/lib/tf-m/interface/include/psa/crypto_compat.h
index 9a7de899f..17dcee2d9 100644
--- a/lib/tf-m/interface/include/psa/crypto_compat.h
+++ b/lib/tf-m/interface/include/psa/crypto_compat.h
@@ -43,6 +43,217 @@ static inline int psa_key_handle_is_null(psa_key_handle_t handle)
     return(handle == 0);
 }
 
+#if !defined(MBEDTLS_DEPRECATED_REMOVED)
+
+/*
+ * Mechanism for declaring deprecated values
+ */
+#if defined(MBEDTLS_DEPRECATED_WARNING) && !defined(MBEDTLS_PSA_DEPRECATED)
+#define MBEDTLS_PSA_DEPRECATED __attribute__((deprecated))
+#else
+#define MBEDTLS_PSA_DEPRECATED
+#endif
+
+typedef MBEDTLS_PSA_DEPRECATED size_t mbedtls_deprecated_size_t;
+typedef MBEDTLS_PSA_DEPRECATED psa_status_t mbedtls_deprecated_psa_status_t;
+typedef MBEDTLS_PSA_DEPRECATED psa_key_usage_t mbedtls_deprecated_psa_key_usage_t;
+typedef MBEDTLS_PSA_DEPRECATED psa_ecc_family_t mbedtls_deprecated_psa_ecc_family_t;
+typedef MBEDTLS_PSA_DEPRECATED psa_dh_family_t mbedtls_deprecated_psa_dh_family_t;
+typedef MBEDTLS_PSA_DEPRECATED psa_ecc_family_t psa_ecc_curve_t;
+typedef MBEDTLS_PSA_DEPRECATED psa_dh_family_t psa_dh_group_t;
+typedef MBEDTLS_PSA_DEPRECATED psa_algorithm_t mbedtls_deprecated_psa_algorithm_t;
+
+#define PSA_KEY_TYPE_GET_CURVE PSA_KEY_TYPE_ECC_GET_FAMILY
+#define PSA_KEY_TYPE_GET_GROUP PSA_KEY_TYPE_DH_GET_FAMILY
+
+#define MBEDTLS_DEPRECATED_CONSTANT( type, value )      \
+    ( (mbedtls_deprecated_##type) ( value ) )
+
+/*
+ * Deprecated PSA Crypto error code definitions (PSA Crypto API  <= 1.0 beta2)
+ */
+#define PSA_ERROR_UNKNOWN_ERROR \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_status_t, PSA_ERROR_GENERIC_ERROR )
+#define PSA_ERROR_OCCUPIED_SLOT \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_status_t, PSA_ERROR_ALREADY_EXISTS )
+#define PSA_ERROR_EMPTY_SLOT \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_status_t, PSA_ERROR_DOES_NOT_EXIST )
+#define PSA_ERROR_INSUFFICIENT_CAPACITY \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_status_t, PSA_ERROR_INSUFFICIENT_DATA )
+#define PSA_ERROR_TAMPERING_DETECTED \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_status_t, PSA_ERROR_CORRUPTION_DETECTED )
+
+/*
+ * Deprecated PSA Crypto numerical encodings (PSA Crypto API  <= 1.0 beta3)
+ */
+#define PSA_KEY_USAGE_SIGN \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_key_usage_t, PSA_KEY_USAGE_SIGN_HASH )
+#define PSA_KEY_USAGE_VERIFY \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_key_usage_t, PSA_KEY_USAGE_VERIFY_HASH )
+
+/*
+ * Deprecated PSA Crypto size calculation macros (PSA Crypto API  <= 1.0 beta3)
+ */
+#define PSA_ASYMMETRIC_SIGNATURE_MAX_SIZE \
+    MBEDTLS_DEPRECATED_CONSTANT( size_t, PSA_SIGNATURE_MAX_SIZE )
+#define PSA_ASYMMETRIC_SIGN_OUTPUT_SIZE( key_type, key_bits, alg ) \
+    MBEDTLS_DEPRECATED_CONSTANT( size_t, PSA_SIGN_OUTPUT_SIZE( key_type, key_bits, alg ) )
+#define PSA_KEY_EXPORT_MAX_SIZE( key_type, key_bits ) \
+    MBEDTLS_DEPRECATED_CONSTANT( size_t, PSA_EXPORT_KEY_OUTPUT_SIZE( key_type, key_bits ) )
+#define PSA_BLOCK_CIPHER_BLOCK_SIZE( type ) \
+    MBEDTLS_DEPRECATED_CONSTANT( size_t, PSA_BLOCK_CIPHER_BLOCK_LENGTH( type ) )
+#define PSA_MAX_BLOCK_CIPHER_BLOCK_SIZE \
+    MBEDTLS_DEPRECATED_CONSTANT( size_t, PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE )
+#define PSA_HASH_SIZE( alg ) \
+    MBEDTLS_DEPRECATED_CONSTANT( size_t, PSA_HASH_LENGTH( alg ) )
+#define PSA_MAC_FINAL_SIZE( key_type, key_bits, alg ) \
+    MBEDTLS_DEPRECATED_CONSTANT( size_t, PSA_MAC_LENGTH( key_type, key_bits, alg ) )
+#define PSA_ALG_TLS12_PSK_TO_MS_MAX_PSK_LEN \
+    MBEDTLS_DEPRECATED_CONSTANT( size_t, PSA_TLS12_PSK_TO_MS_PSK_MAX_SIZE )
+/*
+ * Deprecated PSA Crypto function names (PSA Crypto API  <= 1.0 beta3)
+ */
+MBEDTLS_PSA_DEPRECATED psa_status_t psa_asymmetric_sign( psa_key_handle_t key,
+                            psa_algorithm_t alg,
+                            const uint8_t *hash,
+                            size_t hash_length,
+                            uint8_t *signature,
+                            size_t signature_size,
+                            size_t *signature_length );
+
+MBEDTLS_PSA_DEPRECATED psa_status_t psa_asymmetric_verify( psa_key_handle_t key,
+                              psa_algorithm_t alg,
+                              const uint8_t *hash,
+                              size_t hash_length,
+                              const uint8_t *signature,
+                              size_t signature_length );
+
+
+/*
+ * Size-specific elliptic curve families.
+ */
+#define PSA_ECC_CURVE_SECP160K1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_K1 )
+#define PSA_ECC_CURVE_SECP192K1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_K1 )
+#define PSA_ECC_CURVE_SECP224K1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_K1 )
+#define PSA_ECC_CURVE_SECP256K1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_K1 )
+#define PSA_ECC_CURVE_SECP160R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_R1 )
+#define PSA_ECC_CURVE_SECP192R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_R1 )
+#define PSA_ECC_CURVE_SECP224R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_R1 )
+#define PSA_ECC_CURVE_SECP256R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_R1 )
+#define PSA_ECC_CURVE_SECP384R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_R1 )
+#define PSA_ECC_CURVE_SECP521R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_R1 )
+#define PSA_ECC_CURVE_SECP160R2 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_R2 )
+#define PSA_ECC_CURVE_SECT163K1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_K1 )
+#define PSA_ECC_CURVE_SECT233K1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_K1 )
+#define PSA_ECC_CURVE_SECT239K1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_K1 )
+#define PSA_ECC_CURVE_SECT283K1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_K1 )
+#define PSA_ECC_CURVE_SECT409K1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_K1 )
+#define PSA_ECC_CURVE_SECT571K1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_K1 )
+#define PSA_ECC_CURVE_SECT163R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_R1 )
+#define PSA_ECC_CURVE_SECT193R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_R1 )
+#define PSA_ECC_CURVE_SECT233R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_R1 )
+#define PSA_ECC_CURVE_SECT283R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_R1 )
+#define PSA_ECC_CURVE_SECT409R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_R1 )
+#define PSA_ECC_CURVE_SECT571R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_R1 )
+#define PSA_ECC_CURVE_SECT163R2 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_R2 )
+#define PSA_ECC_CURVE_SECT193R2 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_R2 )
+#define PSA_ECC_CURVE_BRAINPOOL_P256R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_BRAINPOOL_P_R1 )
+#define PSA_ECC_CURVE_BRAINPOOL_P384R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_BRAINPOOL_P_R1 )
+#define PSA_ECC_CURVE_BRAINPOOL_P512R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_BRAINPOOL_P_R1 )
+#define PSA_ECC_CURVE_CURVE25519 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_MONTGOMERY )
+#define PSA_ECC_CURVE_CURVE448 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_MONTGOMERY )
+
+/*
+ * Curves that changed name due to PSA specification.
+ */
+#define PSA_ECC_CURVE_SECP_K1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_K1 )
+#define PSA_ECC_CURVE_SECP_R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_R1 )
+#define PSA_ECC_CURVE_SECP_R2 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECP_R2 )
+#define PSA_ECC_CURVE_SECT_K1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_K1 )
+#define PSA_ECC_CURVE_SECT_R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_R1 )
+#define PSA_ECC_CURVE_SECT_R2 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_SECT_R2 )
+#define PSA_ECC_CURVE_BRAINPOOL_P_R1 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_BRAINPOOL_P_R1 )
+#define PSA_ECC_CURVE_MONTGOMERY \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_ecc_family_t, PSA_ECC_FAMILY_MONTGOMERY )
+
+/*
+ * Finite-field Diffie-Hellman families.
+ */
+#define PSA_DH_GROUP_FFDHE2048 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_dh_family_t, PSA_DH_FAMILY_RFC7919 )
+#define PSA_DH_GROUP_FFDHE3072 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_dh_family_t, PSA_DH_FAMILY_RFC7919 )
+#define PSA_DH_GROUP_FFDHE4096 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_dh_family_t, PSA_DH_FAMILY_RFC7919 )
+#define PSA_DH_GROUP_FFDHE6144 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_dh_family_t, PSA_DH_FAMILY_RFC7919 )
+#define PSA_DH_GROUP_FFDHE8192 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_dh_family_t, PSA_DH_FAMILY_RFC7919 )
+
+/*
+ * Diffie-Hellman families that changed name due to PSA specification.
+ */
+#define PSA_DH_GROUP_RFC7919 \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_dh_family_t, PSA_DH_FAMILY_RFC7919 )
+#define PSA_DH_GROUP_CUSTOM \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_dh_family_t, PSA_DH_FAMILY_CUSTOM )
+
+/*
+ * Deprecated PSA Crypto stream cipher algorithms (PSA Crypto API  <= 1.0 beta3)
+ */
+#define PSA_ALG_ARC4 \
+    MBEDTLS_DEPRECATED_CONSTANT(psa_algorithm_t, PSA_ALG_STREAM_CIPHER)
+#define PSA_ALG_CHACHA20 \
+    MBEDTLS_DEPRECATED_CONSTANT(psa_algorithm_t, PSA_ALG_STREAM_CIPHER)
+
+/*
+ * Renamed AEAD tag length macros (PSA Crypto API  <= 1.0 beta3)
+ */
+#define PSA_ALG_AEAD_WITH_DEFAULT_TAG_LENGTH( aead_alg ) \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_algorithm_t, PSA_ALG_AEAD_WITH_DEFAULT_LENGTH_TAG( aead_alg ) )
+#define PSA_ALG_AEAD_WITH_TAG_LENGTH( aead_alg, tag_length ) \
+    MBEDTLS_DEPRECATED_CONSTANT( psa_algorithm_t, PSA_ALG_AEAD_WITH_SHORTENED_TAG( aead_alg, tag_length ) )
+
+
+#endif /* MBEDTLS_DEPRECATED_REMOVED */
+
 /** Open a handle to an existing persistent key.
  *
  * Open a handle to a persistent key. A key is persistent if it was created
diff --git a/lib/tf-m/interface/include/tfm_its_defs.h b/lib/tf-m/interface/include/tfm_its_defs.h
index a6591b138..852f8f40c 100644
--- a/lib/tf-m/interface/include/tfm_its_defs.h
+++ b/lib/tf-m/interface/include/tfm_its_defs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -15,12 +15,6 @@ extern "C" {
 /* Invalid UID */
 #define TFM_ITS_INVALID_UID 0
 
-/* ITS message types that distinguish ITS services. */
-#define TFM_ITS_SET                1001
-#define TFM_ITS_GET                1002
-#define TFM_ITS_GET_INFO           1003
-#define TFM_ITS_REMOVE             1004
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/tf-m/interface/include/tfm_ps_defs.h b/lib/tf-m/interface/include/tfm_ps_defs.h
index aac231690..5dcf2f134 100644
--- a/lib/tf-m/interface/include/tfm_ps_defs.h
+++ b/lib/tf-m/interface/include/tfm_ps_defs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -15,13 +15,6 @@ extern "C" {
 /* Invalid UID */
 #define TFM_PS_INVALID_UID 0
 
-/* PS message types that distinguish PS services. */
-#define TFM_PS_SET                1001
-#define TFM_PS_GET                1002
-#define TFM_PS_GET_INFO           1003
-#define TFM_PS_REMOVE             1004
-#define TFM_PS_GET_SUPPORT        1005
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/tf-m/interface/src/tfm_initial_attestation_ipc_api.c b/lib/tf-m/interface/src/tfm_initial_attestation_ipc_api.c
index 44e18daa8..43c9b0e47 100644
--- a/lib/tf-m/interface/src/tfm_initial_attestation_ipc_api.c
+++ b/lib/tf-m/interface/src/tfm_initial_attestation_ipc_api.c
@@ -10,7 +10,6 @@
 #include "psa/client.h"
 #include "psa/crypto_types.h"
 #include "psa_manifest/sid.h"
-#include "tfm_attest_defs.h"
 
 psa_status_t
 psa_initial_attest_get_token(const uint8_t *auth_challenge,
@@ -19,6 +18,7 @@ psa_initial_attest_get_token(const uint8_t *auth_challenge,
                              size_t         token_buf_size,
                              size_t        *token_size)
 {
+    psa_handle_t handle = PSA_NULL_HANDLE;
     psa_status_t status;
 
     psa_invec in_vec[] = {
@@ -28,9 +28,16 @@ psa_initial_attest_get_token(const uint8_t *auth_challenge,
         {token_buf, token_buf_size}
     };
 
-    status = psa_call(TFM_ATTESTATION_SERVICE_HANDLE, TFM_ATTEST_GET_TOKEN,
+    handle = psa_connect(TFM_ATTEST_GET_TOKEN_SID,
+                         TFM_ATTEST_GET_TOKEN_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_HANDLE_TO_ERROR(handle);
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL,
                       in_vec, IOVEC_LEN(in_vec),
                       out_vec, IOVEC_LEN(out_vec));
+    psa_close(handle);
 
     if (status == PSA_SUCCESS) {
         *token_size = out_vec[0].len;
@@ -43,6 +50,7 @@ psa_status_t
 psa_initial_attest_get_token_size(size_t  challenge_size,
                                   size_t *token_size)
 {
+    psa_handle_t handle = PSA_NULL_HANDLE;
     psa_status_t status;
     psa_invec in_vec[] = {
         {&challenge_size, sizeof(challenge_size)}
@@ -51,9 +59,16 @@ psa_initial_attest_get_token_size(size_t  challenge_size,
         {token_size, sizeof(size_t)}
     };
 
-    status = psa_call(TFM_ATTESTATION_SERVICE_HANDLE, TFM_ATTEST_GET_TOKEN_SIZE,
+    handle = psa_connect(TFM_ATTEST_GET_TOKEN_SIZE_SID,
+                         TFM_ATTEST_GET_TOKEN_SIZE_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_HANDLE_TO_ERROR(handle);
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL,
                       in_vec, IOVEC_LEN(in_vec),
                       out_vec, IOVEC_LEN(out_vec));
+    psa_close(handle);
 
     return status;
 }
diff --git a/lib/tf-m/interface/src/tfm_its_ipc_api.c b/lib/tf-m/interface/src/tfm_its_ipc_api.c
index a52197b6e..543b88f3d 100644
--- a/lib/tf-m/interface/src/tfm_its_ipc_api.c
+++ b/lib/tf-m/interface/src/tfm_its_ipc_api.c
@@ -9,7 +9,6 @@
 #include "psa/internal_trusted_storage.h"
 #include "psa_manifest/sid.h"
 #include "tfm_api.h"
-#include "tfm_its_defs.h"
 
 psa_status_t psa_its_set(psa_storage_uid_t uid,
                          size_t data_length,
@@ -17,6 +16,7 @@ psa_status_t psa_its_set(psa_storage_uid_t uid,
                          psa_storage_create_flags_t create_flags)
 {
     psa_status_t status;
+    psa_handle_t handle;
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) },
@@ -24,8 +24,14 @@ psa_status_t psa_its_set(psa_storage_uid_t uid,
         { .base = &create_flags, .len = sizeof(create_flags) }
     };
 
-    status = psa_call(TFM_INTERNAL_TRUSTED_STORAGE_SERVICE_HANDLE, TFM_ITS_SET,
-                      in_vec, IOVEC_LEN(in_vec), NULL, 0);
+    handle = psa_connect(TFM_ITS_SET_SID, TFM_ITS_SET_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), NULL, 0);
+
+    psa_close(handle);
 
     return status;
 }
@@ -37,6 +43,7 @@ psa_status_t psa_its_get(psa_storage_uid_t uid,
                          size_t *p_data_length)
 {
     psa_status_t status;
+    psa_handle_t handle;
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) },
@@ -51,8 +58,15 @@ psa_status_t psa_its_get(psa_storage_uid_t uid,
         return PSA_ERROR_INVALID_ARGUMENT;
     }
 
-    status = psa_call(TFM_INTERNAL_TRUSTED_STORAGE_SERVICE_HANDLE, TFM_ITS_GET,
-                      in_vec, IOVEC_LEN(in_vec), out_vec, IOVEC_LEN(out_vec));
+    handle = psa_connect(TFM_ITS_GET_SID, TFM_ITS_GET_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
+                      IOVEC_LEN(out_vec));
+
+    psa_close(handle);
 
     *p_data_length = out_vec[0].len;
 
@@ -63,6 +77,7 @@ psa_status_t psa_its_get_info(psa_storage_uid_t uid,
                               struct psa_storage_info_t *p_info)
 {
     psa_status_t status;
+    psa_handle_t handle;
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) }
@@ -72,23 +87,36 @@ psa_status_t psa_its_get_info(psa_storage_uid_t uid,
         { .base = p_info, .len = sizeof(*p_info) }
     };
 
-    status = psa_call(TFM_INTERNAL_TRUSTED_STORAGE_SERVICE_HANDLE,
-                      TFM_ITS_GET_INFO, in_vec, IOVEC_LEN(in_vec), out_vec,
+    handle = psa_connect(TFM_ITS_GET_INFO_SID, TFM_ITS_GET_INFO_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
                       IOVEC_LEN(out_vec));
 
+    psa_close(handle);
+
     return status;
 }
 
 psa_status_t psa_its_remove(psa_storage_uid_t uid)
 {
     psa_status_t status;
+    psa_handle_t handle;
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) }
     };
 
-    status = psa_call(TFM_INTERNAL_TRUSTED_STORAGE_SERVICE_HANDLE,
-                      TFM_ITS_REMOVE, in_vec, IOVEC_LEN(in_vec), NULL, 0);
+    handle = psa_connect(TFM_ITS_REMOVE_SID, TFM_ITS_REMOVE_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), NULL, 0);
+
+    psa_close(handle);
 
     return status;
 }
diff --git a/lib/tf-m/interface/src/tfm_ps_ipc_api.c b/lib/tf-m/interface/src/tfm_ps_ipc_api.c
index c74c425ea..106917e9b 100644
--- a/lib/tf-m/interface/src/tfm_ps_ipc_api.c
+++ b/lib/tf-m/interface/src/tfm_ps_ipc_api.c
@@ -9,7 +9,6 @@
 #include "psa/protected_storage.h"
 #include "psa_manifest/sid.h"
 #include "tfm_ns_interface.h"
-#include "tfm_ps_defs.h"
 
 psa_status_t psa_ps_set(psa_storage_uid_t uid,
                         size_t data_length,
@@ -17,6 +16,7 @@ psa_status_t psa_ps_set(psa_storage_uid_t uid,
                         psa_storage_create_flags_t create_flags)
 {
     psa_status_t status;
+    psa_handle_t handle;
 
     psa_invec in_vec[] = {
         { .base = &uid,   .len = sizeof(uid) },
@@ -24,8 +24,15 @@ psa_status_t psa_ps_set(psa_storage_uid_t uid,
         { .base = &create_flags, .len = sizeof(create_flags) }
     };
 
-    status = psa_call(TFM_PROTECTED_STORAGE_SERVICE_HANDLE, TFM_PS_SET, in_vec,
-                      IOVEC_LEN(in_vec), NULL, 0);
+    handle = psa_connect(TFM_PS_SET_SID, TFM_PS_SET_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec),
+                      NULL, 0);
+
+    psa_close(handle);
 
     return status;
 }
@@ -37,6 +44,7 @@ psa_status_t psa_ps_get(psa_storage_uid_t uid,
                         size_t *p_data_length)
 {
     psa_status_t status;
+    psa_handle_t handle;
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) },
@@ -51,8 +59,15 @@ psa_status_t psa_ps_get(psa_storage_uid_t uid,
         return PSA_ERROR_INVALID_ARGUMENT;
     }
 
-    status = psa_call(TFM_PROTECTED_STORAGE_SERVICE_HANDLE, TFM_PS_GET, in_vec,
-                      IOVEC_LEN(in_vec), out_vec, IOVEC_LEN(out_vec));
+    handle = psa_connect(TFM_PS_GET_SID, TFM_PS_GET_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
+                      IOVEC_LEN(out_vec));
+
+    psa_close(handle);
 
     *p_data_length = out_vec[0].len;
 
@@ -63,6 +78,7 @@ psa_status_t psa_ps_get_info(psa_storage_uid_t uid,
                              struct psa_storage_info_t *p_info)
 {
     psa_status_t status;
+    psa_handle_t handle;
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) }
@@ -72,8 +88,15 @@ psa_status_t psa_ps_get_info(psa_storage_uid_t uid,
         { .base = p_info, .len = sizeof(*p_info) }
     };
 
-    status = psa_call(TFM_PROTECTED_STORAGE_SERVICE_HANDLE, TFM_PS_GET_INFO,
-                      in_vec, IOVEC_LEN(in_vec), out_vec, IOVEC_LEN(out_vec));
+    handle = psa_connect(TFM_PS_GET_INFO_SID, TFM_PS_GET_INFO_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
+                      IOVEC_LEN(out_vec));
+
+    psa_close(handle);
 
     return status;
 }
@@ -81,13 +104,22 @@ psa_status_t psa_ps_get_info(psa_storage_uid_t uid,
 psa_status_t psa_ps_remove(psa_storage_uid_t uid)
 {
     psa_status_t status;
+    psa_handle_t handle;
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) }
     };
 
-    status = psa_call(TFM_PROTECTED_STORAGE_SERVICE_HANDLE, TFM_PS_REMOVE,
-                      in_vec, IOVEC_LEN(in_vec), NULL, 0);
+
+    handle = psa_connect(TFM_PS_REMOVE_SID, TFM_PS_REMOVE_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec),
+                      NULL, 0);
+
+    psa_close(handle);
 
     return status;
 }
@@ -119,6 +151,7 @@ uint32_t psa_ps_get_support(void)
      * uninitialised value in case the secure function fails.
      */
     uint32_t support_flags = 0;
+    psa_handle_t handle;
 
     psa_outvec out_vec[] = {
         { .base = &support_flags, .len = sizeof(support_flags) }
@@ -127,8 +160,14 @@ uint32_t psa_ps_get_support(void)
     /* The PSA API does not return an error, so any error from TF-M is
      * ignored.
      */
-    (void)psa_call(TFM_PROTECTED_STORAGE_SERVICE_HANDLE, TFM_PS_GET_SUPPORT,
-                   NULL, 0, out_vec, IOVEC_LEN(out_vec));
+    handle = psa_connect(TFM_PS_GET_SUPPORT_SID, TFM_PS_GET_SUPPORT_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return support_flags;
+    }
+
+    (void)psa_call(handle, PSA_IPC_CALL, NULL, 0, out_vec, IOVEC_LEN(out_vec));
+
+    psa_close(handle);
 
     return support_flags;
 }
diff --git a/tf-m.old/lib/ext/CMSIS_5/.CMakeLists.txt.swp b/lib/tf-m/lib/ext/CMSIS_5/.CMakeLists.txt.swp
new file mode 100644
index 000000000..e2cd96ceb
Binary files /dev/null and b/lib/tf-m/lib/ext/CMSIS_5/.CMakeLists.txt.swp differ
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/crypto_api/cc3x_sym/api/mbedtls_ccm_internal.c b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/crypto_api/cc3x_sym/api/mbedtls_ccm_internal.c
index 0611eb21e..c9707f62f 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/crypto_api/cc3x_sym/api/mbedtls_ccm_internal.c
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/crypto_api/cc3x_sym/api/mbedtls_ccm_internal.c
@@ -349,7 +349,7 @@ static int ccm_text_data(mbedtls_ccm_context *ctx, const uint8_t *pTextDataIn, s
         /* set operation mode to CBC_MAC */
         pAesCcmCtx->mode = CIPHER_CBC_MAC;
 
-        rc = ProcessAesCcmDrv(pAesCcmCtx, &inBuffInfo, &outBuffInfo, textDataSize);
+        rc = ProcessAesCcmDrv(pAesCcmCtx, &inBuffInfo, &outBuffInfo, buffAttr, textDataSize);
         if ( rc != AES_DRV_OK )
         {
             CC_PAL_LOG_ERR("CBC_MAC on text data failed with error code %d\n", rc);
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/chacha20_alt.c b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/chacha20_alt.c
index 69226cbb1..e8ebfc1c4 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/chacha20_alt.c
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/chacha20_alt.c
@@ -11,7 +11,6 @@
 
 #if defined(MBEDTLS_CHACHA20_C)
 #include "mbedtls/chacha20.h"
-#include "mbedtls/error.h"
 #include "chacha20_alt.h"
 #include "mbedtls/platform_util.h"
 #include "chacha_driver.h"
@@ -148,7 +147,7 @@ int mbedtls_chacha20_update( mbedtls_chacha20_context *ctx,
     drvRc = ProcessChacha(chachaCtx, &inBuffInfo, &outBuffInfo, size);
     if (drvRc != 0) {
         CC_PAL_LOG_ERR("\nProcessChacha failed %d", drvRc);
-        return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        return MBEDTLS_ERR_CHACHA20_HW_ACCEL_FAILED;
     }
 
     return ( 0 );
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/chachapoly_alt.c b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/chachapoly_alt.c
index 5f2e3a170..abf676f15 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/chachapoly_alt.c
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/chachapoly_alt.c
@@ -11,7 +11,6 @@
 
 #if defined(MBEDTLS_CHACHAPOLY_C)
 #include "mbedtls/chachapoly.h"
-#include "mbedtls/error.h"
 #include "poly.h"
 #include "mbedtls/chacha20.h"
 #include "mbedtls/platform_util.h"
@@ -68,7 +67,7 @@ int mbedtls_chachapoly_starts( mbedtls_chachapoly_context *ctx,
     CC_UNUSED_PARAM(ctx);
     CC_UNUSED_PARAM(nonce);
     CC_UNUSED_PARAM(mode);
-    return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
+    return MBEDTLS_ERR_POLY1305_FEATURE_UNAVAILABLE;
 }
 /* Cryptocell only supports integrated chachapoly operations  */
 int mbedtls_chachapoly_update_aad( mbedtls_chachapoly_context *ctx,
@@ -78,7 +77,7 @@ int mbedtls_chachapoly_update_aad( mbedtls_chachapoly_context *ctx,
     CC_UNUSED_PARAM(ctx);
     CC_UNUSED_PARAM(aad);
     CC_UNUSED_PARAM(aad_len);
-    return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
+    return MBEDTLS_ERR_POLY1305_FEATURE_UNAVAILABLE;
 }
 
 /* Cryptocell only supports integrated chachapoly operations  */
@@ -91,7 +90,7 @@ int mbedtls_chachapoly_update( mbedtls_chachapoly_context *ctx,
     CC_UNUSED_PARAM(len);
     CC_UNUSED_PARAM(input);
     CC_UNUSED_PARAM(output);
-    return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
+    return MBEDTLS_ERR_POLY1305_FEATURE_UNAVAILABLE;
 }
 
 /* Cryptocell only supports integrated chachapoly operations  */
@@ -100,7 +99,7 @@ int mbedtls_chachapoly_finish( mbedtls_chachapoly_context *ctx,
 {
     CC_UNUSED_PARAM(ctx);
     CC_UNUSED_PARAM(mac);
-    return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
+    return MBEDTLS_ERR_POLY1305_FEATURE_UNAVAILABLE;
 }
 
 static int chachapoly_crypt_and_tag( mbedtls_chachapoly_mode_t mode,
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/poly1305_alt.c b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/poly1305_alt.c
index 57329c131..b52acced4 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/poly1305_alt.c
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/poly1305_alt.c
@@ -11,7 +11,6 @@
 
 #if defined(MBEDTLS_POLY1305_C)
 #include "mbedtls/poly1305.h"
-#include "mbedtls/error.h"
 #include "poly.h"
 #include "mbedtls/platform_util.h"
 #include "chacha_driver.h"
@@ -48,7 +47,7 @@ int mbedtls_poly1305_starts( mbedtls_poly1305_context *ctx,
 {
     CC_UNUSED_PARAM(ctx);
     CC_UNUSED_PARAM(key);
-    return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
+    return MBEDTLS_ERR_POLY1305_FEATURE_UNAVAILABLE;
 }
 
 /* Cryptocell only supports integrated poly1305 operations  */
@@ -59,7 +58,7 @@ int mbedtls_poly1305_update( mbedtls_poly1305_context *ctx,
     CC_UNUSED_PARAM(ctx);
     CC_UNUSED_PARAM(input);
     CC_UNUSED_PARAM(ilen);
-    return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
+    return MBEDTLS_ERR_POLY1305_FEATURE_UNAVAILABLE;
 }
 
 /* Cryptocell only supports integrated poly1305 operations  */
@@ -68,7 +67,7 @@ int mbedtls_poly1305_finish( mbedtls_poly1305_context *ctx,
 {
     CC_UNUSED_PARAM(ctx);
     CC_UNUSED_PARAM(mac);
-    return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
+    return MBEDTLS_ERR_POLY1305_FEATURE_UNAVAILABLE;
 }
 
 int mbedtls_poly1305_mac( const unsigned char key[32],
@@ -92,7 +91,7 @@ int mbedtls_poly1305_mac( const unsigned char key[32],
 
     rc = PolyMacCalc(pKey, NULL, 0, input, ilen, macRes, false);
     if (rc != 0) {
-        return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        return MBEDTLS_ERR_POLY1305_HW_ACCEL_FAILED;
     }
 
     CC_PalMemCopy(mac, (unsigned char *)macRes, MBEDTLS_POLY_MAC_SIZE_BYTES);
diff --git a/tf-m.old/lib/ext/cryptocell-312-runtime/shared/hw/include/arm/musca_b1/secure_enclave/dx_reg_base_host.h b/lib/tf-m/lib/ext/cryptocell-312-runtime/shared/hw/include/arm/musca_b1/secure_enclave/dx_reg_base_host.h
new file mode 100644
index 000000000..2cf03682a
--- /dev/null
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/shared/hw/include/arm/musca_b1/secure_enclave/dx_reg_base_host.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2001-2020, Arm Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __DX_REG_BASE_HOST_H__
+#define __DX_REG_BASE_HOST_H__
+
+/* Identify platform: ARM MUSCA_B1_SECURE_ENCLAVE */
+#define DX_PLAT_MUSCA_B1_SECURE_ENCLAVE 1
+
+#define DX_BASE_CC 0x50088000
+
+#define DX_BASE_HOST_RGF 0x0UL
+#define DX_BASE_CRY_KERNEL     0x0UL
+
+#define DX_BASE_RNG 0x0000UL
+#endif /*__DX_REG_BASE_HOST_H__*/
diff --git a/tf-m.old/lib/ext/cryptocell-312-runtime/shared/hw/include/dx_reg_base_host.h b/lib/tf-m/lib/ext/cryptocell-312-runtime/shared/hw/include/dx_reg_base_host.h
new file mode 100644
index 000000000..001de06a5
--- /dev/null
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/shared/hw/include/dx_reg_base_host.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2001-2019, Arm Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#ifndef __DX_REG_BASE_HOST_H__
+#define __DX_REG_BASE_HOST_H__
+
+/* Identify platform: Xilinx Zynq7000 ZC706 */
+#define DX_PLAT_ZYNQ7000 1
+#define DX_PLAT_ZYNQ7000_ZC706 1
+
+#define DX_BASE_CC 0x60000000
+
+#define DX_BASE_ENV_REGS 0x40008000
+#define DX_BASE_ENV_CC_MEMORIES 0x40008000
+#define DX_BASE_ENV_PERF_RAM 0x40009000
+
+#define DX_BASE_HOST_RGF 0x0UL
+#define DX_BASE_CRY_KERNEL     0x0UL
+#define DX_BASE_ROM     0x40000000
+
+#define DX_BASE_RNG 0x0000UL
+#endif /*__DX_REG_BASE_HOST_H__*/
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/shared/include/pal/cc_pal_compiler.h b/lib/tf-m/lib/ext/cryptocell-312-runtime/shared/include/pal/cc_pal_compiler.h
index d0289c20d..6e387120d 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/shared/include/pal/cc_pal_compiler.h
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/shared/include/pal/cc_pal_compiler.h
@@ -131,42 +131,6 @@ dropping it. */
 #define inline __inline
 
 
-/*! Associate a symbol with a link section. */
-#define CC_PAL_COMPILER_SECTION(sectionName)  __attribute__((section(sectionName)))
-
-/*! Mark a symbol as used, that is, prevent garbage collector from
-dropping it. */
-#define CC_PAL_COMPILER_KEEP_SYMBOL __attribute__((used))
-
-/*! Align a given data item in bytes. */
-#define CC_PAL_COMPILER_ALIGN(alignement)  __attribute__((aligned(alignement)))
-
-/*! Mark a function that never returns. */
-#define CC_PAL_COMPILER_FUNC_NEVER_RETURNS __attribute__((noreturn))
-
-/*! Prevent a function from being inlined. */
-#define CC_PAL_COMPILER_FUNC_DONT_INLINE __attribute__((noinline))
-
-/*! Given data type might serve as an alias for another data-type pointer. */
-/* (this is used for "superclass" struct casting)             */
-#define CC_PAL_COMPILER_TYPE_MAY_ALIAS
-
-/*! Get the size of a structure-type member. */
-#define CC_PAL_COMPILER_SIZEOF_STRUCT_MEMBER(type_name, member_name) \
-    sizeof(((type_name *)0)->member_name)
-
-/*! Definition of assertion. */
-#define CC_ASSERT_CONCAT_(a, b) a##b
-/*! Definition of assertion. */
-#define CC_ASSERT_CONCAT(a, b) CC_ASSERT_CONCAT_(a, b)
-/*! Definition of assertion. */
-#define CC_PAL_COMPILER_ASSERT(cond, message) \
-    enum { CC_ASSERT_CONCAT(assert_line_, __LINE__) = 1/(!!(cond)) }
-
-#elif defined(__ICCARM__)
-#define inline __inline
-
-
 /*! Associate a symbol with a link section. */
 #define CC_PAL_COMPILER_SECTION(sectionName)  __attribute__((section(sectionName)))
 
diff --git a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_default.h b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_default.h
index d87b6aaca..9febb9664 100644
--- a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_default.h
+++ b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_default.h
@@ -1115,7 +1115,7 @@
  *
  * This module is required for PEM support (required by X.509).
  */
-//#define MBEDTLS_BASE64_C
+#define MBEDTLS_BASE64_C
 
 /**
  * \def MBEDTLS_BIGNUM_C
@@ -1571,7 +1571,7 @@
  *
  * This modules adds support for decoding / parsing PEM files.
  */
-//#define MBEDTLS_PEM_PARSE_C
+#define MBEDTLS_PEM_PARSE_C
 
 /**
  * \def MBEDTLS_PEM_WRITE_C
@@ -1585,7 +1585,7 @@
  *
  * This modules adds support for encoding / writing PEM files.
  */
-//#define MBEDTLS_PEM_WRITE_C
+#define MBEDTLS_PEM_WRITE_C
 
 /**
  * \def MBEDTLS_PK_C
@@ -2011,13 +2011,9 @@
 
 /* \} name SECTION: Customisation configuration options */
 
-#ifdef CRYPTO_NV_SEED
-#include "tfm_mbedcrypto_config_extra_nv_seed.h"
-#endif /* CRYPTO_NV_SEED */
-
 #ifdef CRYPTO_HW_ACCELERATOR
 #include "mbedtls_accelerator_config.h"
-#elif defined(MBEDTLS_ENTROPY_NV_SEED)
+#else
 #include "mbedtls_entropy_nv_seed_config.h"
 #endif
 
diff --git a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_large.h b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_large.h
index 997dccc8a..d1e57bc0f 100644
--- a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_large.h
+++ b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_large.h
@@ -1110,7 +1110,7 @@
  *
  * This module is required for PEM support (required by X.509).
  */
-//#define MBEDTLS_BASE64_C
+#define MBEDTLS_BASE64_C
 
 /**
  * \def MBEDTLS_BIGNUM_C
@@ -1566,7 +1566,7 @@
  *
  * This modules adds support for decoding / parsing PEM files.
  */
-//#define MBEDTLS_PEM_PARSE_C
+#define MBEDTLS_PEM_PARSE_C
 
 /**
  * \def MBEDTLS_PEM_WRITE_C
@@ -1580,7 +1580,7 @@
  *
  * This modules adds support for encoding / writing PEM files.
  */
-//#define MBEDTLS_PEM_WRITE_C
+#define MBEDTLS_PEM_WRITE_C
 
 /**
  * \def MBEDTLS_PK_C
@@ -2006,13 +2006,9 @@
 
 /* \} name SECTION: Customisation configuration options */
 
-#ifdef CRYPTO_NV_SEED
-#include "tfm_mbedcrypto_config_extra_nv_seed.h"
-#endif /* CRYPTO_NV_SEED */
-
 #ifdef CRYPTO_HW_ACCELERATOR
 #include "mbedtls_accelerator_config.h"
-#elif defined(MBEDTLS_ENTROPY_NV_SEED)
+#else
 #include "mbedtls_entropy_nv_seed_config.h"
 #endif
 
diff --git a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_medium.h b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_medium.h
index 8fbca00a2..7472f600a 100644
--- a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_medium.h
+++ b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_medium.h
@@ -1411,7 +1411,7 @@
  * This module adds support for the Hashed Message Authentication Code
  * (HMAC)-based key derivation function (HKDF).
  */
-#define MBEDTLS_HKDF_C
+//#define MBEDTLS_HKDF_C
 
 /**
  * \def MBEDTLS_HMAC_DRBG_C
@@ -2006,13 +2006,9 @@
 
 /* \} name SECTION: Customisation configuration options */
 
-#ifdef CRYPTO_NV_SEED
-#include "tfm_mbedcrypto_config_extra_nv_seed.h"
-#endif /* CRYPTO_NV_SEED */
-
 #ifdef CRYPTO_HW_ACCELERATOR
 #include "mbedtls_accelerator_config.h"
-#elif defined(MBEDTLS_ENTROPY_NV_SEED)
+#else
 #include "mbedtls_entropy_nv_seed_config.h"
 #endif
 
diff --git a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_small.h b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_small.h
index 3da666011..d787c6533 100644
--- a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_small.h
+++ b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_small.h
@@ -846,7 +846,7 @@
  * Note that this option is meant for internal use only and may be removed
  * without notice.
  */
-#define MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
+//#define MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
 
 /**
  * \def MBEDTLS_MEMORY_DEBUG
@@ -1411,7 +1411,7 @@
  * This module adds support for the Hashed Message Authentication Code
  * (HMAC)-based key derivation function (HKDF).
  */
-#define MBEDTLS_HKDF_C
+//#define MBEDTLS_HKDF_C
 
 /**
  * \def MBEDTLS_HMAC_DRBG_C
@@ -2006,13 +2006,9 @@
 
 /* \} name SECTION: Customisation configuration options */
 
-#ifdef CRYPTO_NV_SEED
-#include "tfm_mbedcrypto_config_extra_nv_seed.h"
-#endif /* CRYPTO_NV_SEED */
-
 #ifdef CRYPTO_HW_ACCELERATOR
 #include "mbedtls_accelerator_config.h"
-#elif defined(MBEDTLS_ENTROPY_NV_SEED)
+#else
 #include "mbedtls_entropy_nv_seed_config.h"
 #endif
 
diff --git a/lib/tf-m/lib/ext/psa_arch_tests/0001-Fix-wrong-expected-return-value-in-test-46-and-47.patch b/lib/tf-m/lib/ext/psa_arch_tests/0001-Fix-wrong-expected-return-value-in-test-46-and-47.patch
index 6e7ef142c..0c3703aec 100644
--- a/lib/tf-m/lib/ext/psa_arch_tests/0001-Fix-wrong-expected-return-value-in-test-46-and-47.patch
+++ b/lib/tf-m/lib/ext/psa_arch_tests/0001-Fix-wrong-expected-return-value-in-test-46-and-47.patch
@@ -1,7 +1,7 @@
-From f56b7fba26b4220882a1fe7e7539c80a4e42fc19 Mon Sep 17 00:00:00 2001
+From 4950186e4da5c8547478cd634c35d69ada6d8037 Mon Sep 17 00:00:00 2001
 From: Summer Qin <summer.qin@arm.com>
-Date: Wed, 28 Jul 2021 11:15:09 +0800
-Subject: [PATCH 1/4] Fix wrong expected return value in test 46 and 47
+Date: Fri, 9 Jul 2021 17:35:22 +0800
+Subject: [PATCH 1/3] Fix wrong expected return value in test 46 and 47
 
 Update the expected return value in test 46 and 47
 according to the PSA Crypto spec 1.0.
diff --git a/lib/tf-m/lib/ext/psa_arch_tests/0002-Enable-Crypto-1.0-test-cases.patch b/lib/tf-m/lib/ext/psa_arch_tests/0002-Enable-Crypto-1.0-test-cases.patch
index a7bff3d28..6d51e1663 100644
--- a/lib/tf-m/lib/ext/psa_arch_tests/0002-Enable-Crypto-1.0-test-cases.patch
+++ b/lib/tf-m/lib/ext/psa_arch_tests/0002-Enable-Crypto-1.0-test-cases.patch
@@ -1,18 +1,17 @@
-From 2685e6d9c8dd9f0d4fcddc2ed49195b6372a63ac Mon Sep 17 00:00:00 2001
+From 78094cc82bc595d5c4ca2ffe7fcfc17533d35300 Mon Sep 17 00:00:00 2001
 From: Summer Qin <summer.qin@arm.com>
-Date: Wed, 28 Jul 2021 11:16:11 +0800
-Subject: [PATCH 2/4] Enable Crypto 1.0 test cases
+Date: Fri, 9 Jul 2021 17:40:28 +0800
+Subject: [PATCH 2/3] Enable Crypto 1.0 test cases
 
-psa_cipher_encrypt(), psa_cipher_decrypt(), psa_sign_message(),
-psa_verify_message(), psa_mac_compute() and psa_mac_verify() are
-supported now in tfm and mbedtls-3.0.0.
+psa_cipher_encrypt(), psa_cipher_decrypt(), psa_sign_message() and
+psa_verify_message() are supported now in tfm and mbedtls 3.0.
 Enable the test case for them.
 
 Signed-off-by: Summer Qin <summer.qin@arm.com>
 ---
- api-tests/dev_apis/crypto/common/test_crypto_common.h  |  2 ++
- .../targets/common/nspe/crypto/pal_crypto_intf.c       | 10 ----------
- 2 files changed, 2 insertions(+), 10 deletions(-)
+ api-tests/dev_apis/crypto/common/test_crypto_common.h         | 2 ++
+ .../platform/targets/common/nspe/crypto/pal_crypto_intf.c     | 4 ----
+ 2 files changed, 2 insertions(+), 4 deletions(-)
 
 diff --git a/api-tests/dev_apis/crypto/common/test_crypto_common.h b/api-tests/dev_apis/crypto/common/test_crypto_common.h
 index c213b7d..b1c6e65 100644
@@ -28,42 +27,10 @@ index c213b7d..b1c6e65 100644
  
  extern const uint8_t rsa_128_key_pair[];
 diff --git a/api-tests/platform/targets/common/nspe/crypto/pal_crypto_intf.c b/api-tests/platform/targets/common/nspe/crypto/pal_crypto_intf.c
-index 7d8e633..8ef5e99 100644
+index 7d8e633..dc2a292 100644
 --- a/api-tests/platform/targets/common/nspe/crypto/pal_crypto_intf.c
 +++ b/api-tests/platform/targets/common/nspe/crypto/pal_crypto_intf.c
-@@ -267,7 +267,6 @@ int32_t pal_crypto_function(int type, va_list valist)
- 			cipher_operation         =  va_arg(valist, psa_cipher_operation_t *);
- 			return psa_cipher_abort(cipher_operation);
- 			break;
--#if HOST_GCC_MISSING_CRYPTO_1_0 == 0
- 		case PAL_CRYPTO_CIPHER_DECRYPT:
- 			key                      = va_arg(valist, psa_key_id_t);
- 			alg                      = va_arg(valist, psa_algorithm_t);
-@@ -284,7 +283,6 @@ int32_t pal_crypto_function(int type, va_list valist)
- 									  output_size,
- 									  p_output_length);
- 			break;
--#endif
- 		case PAL_CRYPTO_CIPHER_DECRYPT_SETUP:
- 			cipher_operation         = va_arg(valist, psa_cipher_operation_t *);
- 			key                      = va_arg(valist, psa_key_id_t);
-@@ -293,7 +291,6 @@ int32_t pal_crypto_function(int type, va_list valist)
- 											key,
- 											alg);
- 			break;
--#if HOST_GCC_MISSING_CRYPTO_1_0 == 0
- 		case PAL_CRYPTO_CIPHER_ENCRYPT:
- 			key                      = va_arg(valist, psa_key_id_t);
- 			alg                      = va_arg(valist, psa_algorithm_t);
-@@ -310,7 +307,6 @@ int32_t pal_crypto_function(int type, va_list valist)
- 									  output_size,
- 									  p_output_length);
- 			break;
--#endif
- 		case PAL_CRYPTO_CIPHER_ENCRYPT_SETUP:
- 			cipher_operation         = va_arg(valist, psa_cipher_operation_t *);
- 			key                      = va_arg(valist, psa_key_id_t);
-@@ -648,7 +644,6 @@ int32_t pal_crypto_function(int type, va_list valist)
+@@ -648,7 +648,6 @@ int32_t pal_crypto_function(int type, va_list valist)
  			mac_operation            = va_arg(valist, psa_mac_operation_t *);
  			return psa_mac_abort(mac_operation);
  			break;
@@ -71,7 +38,7 @@ index 7d8e633..8ef5e99 100644
  		case PAL_CRYPTO_MAC_COMPUTE:
  			key                      = va_arg(valist, psa_key_id_t);
  			alg                      = va_arg(valist, psa_algorithm_t);
-@@ -665,7 +660,6 @@ int32_t pal_crypto_function(int type, va_list valist)
+@@ -665,7 +664,6 @@ int32_t pal_crypto_function(int type, va_list valist)
  								   output_size,
  								   p_output_length);
  			break;
@@ -79,23 +46,7 @@ index 7d8e633..8ef5e99 100644
  		case PAL_CRYPTO_MAC_OPERATION_INIT:
  			mac_operation            = va_arg(valist, psa_mac_operation_t *);
  			mac_operation_temp       = psa_mac_operation_init();
-@@ -699,7 +693,6 @@ int32_t pal_crypto_function(int type, va_list valist)
- 								  input,
- 								  input_length);
- 			break;
--#if HOST_GCC_MISSING_CRYPTO_1_0 == 0
- 		case PAL_CRYPTO_MAC_VERIFY:
- 			key                      = va_arg(valist, psa_key_id_t);
- 			alg                      = va_arg(valist, psa_algorithm_t);
-@@ -714,7 +707,6 @@ int32_t pal_crypto_function(int type, va_list valist)
- 								  input1,
- 								  input_length1);
- 			break;
--#endif
- 		case PAL_CRYPTO_MAC_VERIFY_FINISH:
- 			mac_operation            = va_arg(valist, psa_mac_operation_t *);
- 			input                    = va_arg(valist, const uint8_t *);
-@@ -814,7 +806,6 @@ int32_t pal_crypto_function(int type, va_list valist)
+@@ -814,7 +812,6 @@ int32_t pal_crypto_function(int type, va_list valist)
  								 output_size,
  								 p_output_length);
  			break;
@@ -103,7 +54,7 @@ index 7d8e633..8ef5e99 100644
  		case PAL_CRYPTO_SIGN_MESSAGE:
  			key                      = va_arg(valist, psa_key_id_t);
  			alg                      = va_arg(valist, psa_algorithm_t);
-@@ -845,7 +836,6 @@ int32_t pal_crypto_function(int type, va_list valist)
+@@ -845,7 +842,6 @@ int32_t pal_crypto_function(int type, va_list valist)
  									  input1,
  									  input_length1);
  			break;
diff --git a/lib/tf-m/lib/ext/psa_arch_tests/0003-Workaround-for-removal-of-initial-attest-get-public-.patch b/lib/tf-m/lib/ext/psa_arch_tests/0003-Workaround-for-removal-of-initial-attest-get-public-.patch
index 121ad55f0..00ce2f9f1 100644
--- a/lib/tf-m/lib/ext/psa_arch_tests/0003-Workaround-for-removal-of-initial-attest-get-public-.patch
+++ b/lib/tf-m/lib/ext/psa_arch_tests/0003-Workaround-for-removal-of-initial-attest-get-public-.patch
@@ -1,7 +1,7 @@
-From b19f2e11134d687174b7df89cedc9d73218e01b9 Mon Sep 17 00:00:00 2001
+From 4be33133eb9ae94e7a71c1385a771484322347d6 Mon Sep 17 00:00:00 2001
 From: Summer Qin <summer.qin@arm.com>
-Date: Wed, 28 Jul 2021 11:17:30 +0800
-Subject: [PATCH 3/4] Workaround for removal of initial attest get public key
+Date: Fri, 9 Jul 2021 17:52:02 +0800
+Subject: [PATCH 3/3] Workaround for removal of initial attest get public key
  API
 
 TF-M self-defined API of getting initial attestation public key has been
@@ -18,10 +18,10 @@ Signed-off-by: Summer Qin <summer.qin@arm.com>
  2 files changed, 22 insertions(+), 5 deletions(-)
 
 diff --git a/api-tests/CMakeLists.txt b/api-tests/CMakeLists.txt
-index 31b7ef7..a8d9c58 100644
+index e0f1dbe..0ebf78a 100644
 --- a/api-tests/CMakeLists.txt
 +++ b/api-tests/CMakeLists.txt
-@@ -613,6 +613,10 @@ endif()
+@@ -610,6 +610,10 @@ endif()
  
  # Build PAL NSPE LIB
  include(${PSA_ROOT_DIR}/platform/targets/${TARGET}/target.cmake)
@@ -33,7 +33,7 @@ index 31b7ef7..a8d9c58 100644
  #add_definitions(-DVAL_NSPE_BUILD)
  include(${PSA_ROOT_DIR}/val/val_nspe.cmake)
 diff --git a/api-tests/platform/targets/common/nspe/initial_attestation/pal_attestation_crypto.c b/api-tests/platform/targets/common/nspe/initial_attestation/pal_attestation_crypto.c
-index 4a25a20..04d9f42 100644
+index 7b233a2..004c25b 100644
 --- a/api-tests/platform/targets/common/nspe/initial_attestation/pal_attestation_crypto.c
 +++ b/api-tests/platform/targets/common/nspe/initial_attestation/pal_attestation_crypto.c
 @@ -17,9 +17,14 @@
diff --git a/lib/tf-m/lib/ext/psa_arch_tests/0004-Align-with-mbedtls-3.0.0.patch b/lib/tf-m/lib/ext/psa_arch_tests/0004-Align-with-mbedtls-3.0.0.patch
index c02409362..900d9cbc7 100644
--- a/lib/tf-m/lib/ext/psa_arch_tests/0004-Align-with-mbedtls-3.0.0.patch
+++ b/lib/tf-m/lib/ext/psa_arch_tests/0004-Align-with-mbedtls-3.0.0.patch
@@ -1,20 +1,21 @@
-From 7e4ed5386dc1e8f6c452ef8b58a2750051f437af Mon Sep 17 00:00:00 2001
+From b553a6f375fb2f55d776cca4663f8cd491e7445e Mon Sep 17 00:00:00 2001
 From: Summer Qin <summer.qin@arm.com>
-Date: Wed, 28 Jul 2021 11:19:12 +0800
-Subject: [PATCH 4/4] Align with mbedtls-3.0.0
+Date: Tue, 20 Jul 2021 11:48:40 +0800
+Subject: [PATCH] Align with mbedtls 3.0.0
 
-PSA_ALG_MD4 is removed from mbedtls-3.0.0. Use PSA_ALG_MD5 instead.
+PSA_ALG_MD4 is removed from mbedtls 3.0.0. Use PSA_ALG_MD5 instead.
+PSA_KEY_USAGE_VERIFY is replaced by PSA_KEY_USAGE_VERIFY_HASH.
 
 Signed-off-by: Summer Qin <summer.qin@arm.com>
 ---
- .../common/nspe/initial_attestation/pal_attestation_crypto.c    | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
+ .../common/nspe/initial_attestation/pal_attestation_crypto.c  | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
 diff --git a/api-tests/platform/targets/common/nspe/initial_attestation/pal_attestation_crypto.c b/api-tests/platform/targets/common/nspe/initial_attestation/pal_attestation_crypto.c
-index 04d9f42..daf7842 100644
+index 7b233a2..33e77fc 100644
 --- a/api-tests/platform/targets/common/nspe/initial_attestation/pal_attestation_crypto.c
 +++ b/api-tests/platform/targets/common/nspe/initial_attestation/pal_attestation_crypto.c
-@@ -41,7 +41,7 @@ static psa_algorithm_t cose_hash_alg_id_to_psa(int32_t cose_hash_alg_id)
+@@ -36,7 +36,7 @@ static psa_algorithm_t cose_hash_alg_id_to_psa(int32_t cose_hash_alg_id)
          status = PSA_ALG_SHA_256;
          break;
      default:
@@ -23,6 +24,15 @@ index 04d9f42..daf7842 100644
          break;
      }
  
+@@ -215,7 +215,7 @@ static int32_t pal_attest_get_public_key(uint8_t          *public_key_buff,
+ static uint32_t pal_import_attest_key(psa_algorithm_t key_alg)
+ {
+     psa_status_t     status             = PAL_ATTEST_ERROR;
+-    psa_key_usage_t  usage              = PSA_KEY_USAGE_VERIFY;
++    psa_key_usage_t  usage              = PSA_KEY_USAGE_VERIFY_HASH;
+     psa_ecc_family_t ecc_family;
+     psa_key_type_t   attest_key_type;
+     size_t           public_key_size;
 -- 
 2.17.1
 
diff --git a/tf-m.old/lib/ext/qcbor/util/README.md b/lib/tf-m/lib/ext/qcbor/util/README.md
new file mode 100644
index 000000000..7e41dd8b8
--- /dev/null
+++ b/lib/tf-m/lib/ext/qcbor/util/README.md
@@ -0,0 +1,43 @@
+# Comments on qcbor_util
+
+These utilities are shared by t_cose and attest_token. They are
+are just part of test code for attestation. This is logically
+part of neither t_cose or attest_token so it doesn't
+belog in either.
+
+Eventually it is likely to be an official part of QCBOR, but
+it is not complete enough for that yet. It works fine
+for what it is, but it is only enough for the needs
+of t_cose and attest_token. It needs to be more to be
+part of QCBOR.
+
+So the copy here is part of Arm TF-M software and
+not part of QCBOR even though it is in QCBOR
+directory. This is a convenient place for it.
+
+# Copyright for this README
+
+Copyright 2019, Laurence Lundblade
+
+* Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+
+* Neither the name of the copyright holder nor the names of its
+contributors may be used to endorse or promote products derived from
+this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/tf-m.old/lib/ext/qcbor/util/qcbor_util.c b/lib/tf-m/lib/ext/qcbor/util/qcbor_util.c
new file mode 100644
index 000000000..8d0930ec7
--- /dev/null
+++ b/lib/tf-m/lib/ext/qcbor/util/qcbor_util.c
@@ -0,0 +1,266 @@
+/*
+ * qcbor_util.c
+ *
+ * Copyright (c) 2019, Laurence Lundblade.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * See BSD-3-Clause license in README.md
+ */
+
+#include "qcbor_util.h"
+
+
+/*
+ * Public function. See qcbor_util.h
+ */
+QCBORError
+qcbor_util_consume_item(QCBORDecodeContext *decode_context,
+                        const QCBORItem    *item_to_consume,
+                        uint_fast8_t       *next_nest_level)
+{
+    QCBORError return_value;
+    QCBORItem  item;
+
+    if(item_to_consume->uDataType == QCBOR_TYPE_MAP ||
+       item_to_consume->uDataType == QCBOR_TYPE_ARRAY) {
+        /* There is only real work to do for maps and arrays */
+
+        /* This works for definite and indefinite length
+         * maps and arrays by using the nesting level
+         */
+        do {
+            return_value = QCBORDecode_GetNext(decode_context, &item);
+            if(return_value != QCBOR_SUCCESS) {
+                goto Done;
+            }
+        } while(item.uNextNestLevel >= item_to_consume->uNextNestLevel);
+
+        if(next_nest_level != NULL) {
+            *next_nest_level = item.uNextNestLevel;
+        }
+        return_value = QCBOR_SUCCESS;
+
+    } else {
+        /* item_to_consume is not a map or array */
+        if(next_nest_level != NULL) {
+            /* Just pass the nesting level through */
+            *next_nest_level = item_to_consume->uNextNestLevel;
+        }
+        return_value = QCBOR_SUCCESS;
+    }
+
+Done:
+    return return_value;
+}
+
+
+/*
+ * Public function. qcbor_util.h
+ */
+enum attest_token_err_t
+qcbor_util_get_items_in_map(QCBORDecodeContext *decode_context,
+                            struct qcbor_util_items_to_get_t *items_found)
+{
+    QCBORItem                         item;
+    struct qcbor_util_items_to_get_t  *iterator;
+    enum attest_token_err_t           return_value;
+    uint_fast8_t                      map_nest_level;
+    uint_fast8_t                      next_nest_level;
+
+    /* Clear structure holding the items found */
+    for(iterator = items_found; iterator->label != 0; iterator++) {
+        iterator->item.uDataType = QCBOR_TYPE_NONE;
+    }
+
+    /* Get the data item that is the map that is being searched */
+    QCBORDecode_GetNext(decode_context, &item);
+    if(item.uDataType != QCBOR_TYPE_MAP) {
+        return_value = ATTEST_TOKEN_ERR_CBOR_STRUCTURE;
+        goto Done;
+    }
+
+    /* Loop over all the items in the map. The map may contain further
+     * maps and arrays. This also needs to handle definite and
+     * indefinite length maps and array.
+     *
+     * map_nest_level is the nesting level of the data item opening
+     * the map that is being scanned. All data items inside this map
+     * have a nesting level greater than it. The data item following
+     * the map being scanned has a nesting level that is equal to or
+     * higher than map_nest_level.
+     */
+    map_nest_level  = item.uNestingLevel;
+    next_nest_level = item.uNextNestLevel;
+
+    while(next_nest_level > map_nest_level) {
+        if(QCBORDecode_GetNext(decode_context, &item) != QCBOR_SUCCESS) {
+            /* Got non-well-formed CBOR */
+            return_value = ATTEST_TOKEN_ERR_CBOR_NOT_WELL_FORMED;
+            goto Done;
+        }
+
+        /* Only look at labels that are integers */
+        if(item.uLabelType == QCBOR_TYPE_INT64) {
+            /* See if it is one we are looking for */
+            for(iterator = items_found; iterator->label != 0; iterator++) {
+                if(item.label.int64 == iterator->label) {
+                    /* It is one we are looking for. Record it.
+                     * This was the point of the whole loop! */
+                    iterator->item = item;
+                }
+            }
+        }
+
+        /* Only looking at top-level data items, so just consume any
+         * map or array encountered.*/
+        if(qcbor_util_consume_item(decode_context, &item, &next_nest_level)) {
+            return_value = ATTEST_TOKEN_ERR_CBOR_NOT_WELL_FORMED;
+            goto Done;
+        }
+    }
+    return_value = ATTEST_TOKEN_ERR_SUCCESS;
+
+Done:
+    return return_value;
+}
+
+
+/*
+ * Public function. See qcbor_util.h
+ */
+enum attest_token_err_t
+qcbor_util_decode_to_labeled_item(QCBORDecodeContext *decode_context,
+                                  int32_t label,
+                                  QCBORItem *item)
+{
+    QCBORItem               map_item;
+    enum attest_token_err_t return_value;
+
+    return_value = ATTEST_TOKEN_ERR_SUCCESS;
+
+    QCBORDecode_GetNext(decode_context, &map_item);
+    if(map_item.uDataType != QCBOR_TYPE_MAP) {
+        /* Isn't a map */
+        return_value = ATTEST_TOKEN_ERR_CBOR_STRUCTURE;
+        goto Done;
+    }
+
+    /* Loop over all the items in the map */
+    while(1) {
+        if(QCBORDecode_GetNext(decode_context, item) != QCBOR_SUCCESS) {
+            /* Got non-well-formed CBOR */
+            return_value = ATTEST_TOKEN_ERR_CBOR_NOT_WELL_FORMED;
+            goto Done;
+        }
+
+        /* Only look at labels that are integers */
+        if(item->uLabelType == QCBOR_TYPE_INT64) {
+            /* See if it is one we are looking for */
+            if(item->label.int64 == label) {
+                /* This is successful exit from the loop */
+                return_value = ATTEST_TOKEN_ERR_SUCCESS;
+                goto Done;
+            }
+        }
+
+        /* Only looking at top-level data items, so just consume any
+         * map or array encountered */
+        if(qcbor_util_consume_item(decode_context, item, NULL)) {
+            return_value = ATTEST_TOKEN_ERR_CBOR_NOT_WELL_FORMED;
+            goto Done;
+        }
+
+        if(item->uNextNestLevel < map_item.uNextNestLevel) {
+            /* Fetched last item in the map without
+             * finding what was requested */
+            return_value = ATTEST_TOKEN_ERR_NOT_FOUND;
+            goto Done;
+        }
+    }
+
+Done:
+    return return_value;
+}
+
+
+/*
+ * Public function. See qcbor_util.h
+ */
+enum attest_token_err_t
+qcbor_util_get_item_in_map(QCBORDecodeContext *decode_context,
+                           int32_t label,
+                           QCBORItem *item)
+{
+    struct qcbor_util_items_to_get_t  one_item[2];
+    enum attest_token_err_t           return_value;
+
+    one_item[0].label = label;
+    one_item[1].label = 0; /* Terminator for search list */
+
+    return_value = qcbor_util_get_items_in_map(decode_context, one_item);
+    if(return_value) {
+        goto Done;
+    }
+
+    if(one_item[0].item.uDataType == QCBOR_TYPE_NONE) {
+        return_value = ATTEST_TOKEN_ERR_NOT_FOUND;
+        goto Done;
+    }
+
+    *item = one_item[0].item;
+
+Done:
+    return return_value;
+}
+
+
+/*
+ * Public function. See qcbor_util.h
+ */
+enum attest_token_err_t
+qcbor_util_get_top_level_item_in_map(struct q_useful_buf_c payload,
+                                     int32_t label,
+                                     uint_fast8_t qcbor_type,
+                                     QCBORItem *item)
+{
+    enum attest_token_err_t return_value;
+    QCBORItem               found_item;
+    QCBORDecodeContext      decode_context;
+    QCBORError              cbor_error;
+
+    if(q_useful_buf_c_is_null(payload)) {
+        return_value = ATTEST_TOKEN_ERR_COSE_VALIDATION;
+        goto Done;
+    }
+
+    QCBORDecode_Init(&decode_context, payload, QCBOR_DECODE_MODE_NORMAL);
+
+    return_value = qcbor_util_get_item_in_map(&decode_context,
+                                              label,
+                                              &found_item);
+    if(return_value != ATTEST_TOKEN_ERR_SUCCESS) {
+        goto Done;
+    }
+
+    cbor_error = QCBORDecode_Finish(&decode_context);
+    if(cbor_error != QCBOR_SUCCESS) {
+        if(cbor_error == QCBOR_ERR_ARRAY_OR_MAP_STILL_OPEN) {
+            return_value = ATTEST_TOKEN_ERR_CBOR_STRUCTURE;
+        } else {
+            /* This is usually due to extra bytes at the end */
+            return_value = ATTEST_TOKEN_ERR_CBOR_NOT_WELL_FORMED;
+        }
+        goto Done;
+    }
+
+    if(found_item.uDataType != qcbor_type) {
+        return_value = ATTEST_TOKEN_ERR_CBOR_TYPE;
+        goto Done;
+    }
+    *item = found_item;
+
+Done:
+    return return_value;
+}
+
diff --git a/tf-m.old/lib/ext/qcbor/util/qcbor_util.h b/lib/tf-m/lib/ext/qcbor/util/qcbor_util.h
new file mode 100644
index 000000000..1ea05b4c8
--- /dev/null
+++ b/lib/tf-m/lib/ext/qcbor/util/qcbor_util.h
@@ -0,0 +1,235 @@
+/*
+ * qcbor_util.h
+ *
+ * Copyright (c) 2019, Laurence Lundblade.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * See BSD-3-Clause license in README.md
+ */
+
+#ifndef __QCBOR_UTILS_H__
+#define __QCBOR_UTILS_H__
+
+
+#include "qcbor.h"
+#include "q_useful_buf.h"
+#include "attest_token.h" /* For error codes */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ *\file qcbor_util.h
+ *
+ * \brief Some utility functions for decoding CBOR with QCBOR.
+ *
+ * All functions search only for integer labeled data items. If data
+ * items labeled otherwise are present, they will be skipped over.
+ *
+ * These functions may eventually expand in to a more general and
+ * useful set of decoding utilities.
+ *
+ * \c uint_fast8_t is used for type and nest levels. They are
+ * 8-bit quantities, but making using uint8_t variables
+ * and parameters can result in bigger, slower code.
+ * \c uint_fast8_t is part of \c <stdint.h>. It is not
+ * used in structures where it is more important to keep
+ * the size smaller.
+ */
+
+
+/**
+ *\brief Consume a data item, particularly a map or array.
+ *
+ * \param[in] decode_context   The CBOR context from which to
+ *                             consume the map or array.
+ * \param[in] item_to_consume  The item to consume.
+ * \param[out] next_nest_level The nesting level of the item
+ *                             that would be consumed next.
+ *
+ * \return A \c  QCBORError when there is something wrong with the
+ *               encoded CBOR.
+ *
+ * If the \c item_to_consume is not a map or array this does nothing
+ * but return the \c next_nest_level (which is just copied from \c
+ * item_to_consume). If it is a map or array all subordinate items
+ * will be consumed from the \c decode_context.
+ */
+QCBORError
+qcbor_util_consume_item(QCBORDecodeContext *decode_context,
+                        const QCBORItem *item_to_consume,
+                        uint_fast8_t *next_nest_level);
+
+
+/**
+ * Descriptor for a single labeled item to be retrieved by
+ * qcbor_util_get_items_in_map().  An array of these is passed to
+ * qcbor_util_get_items_in_map() terminated by one of these with label
+ * 0.
+ */
+struct qcbor_util_items_to_get_t {
+    /**
+     * The integer label to search for. List terminated by label 0.
+     */
+    int64_t   label;
+    /**
+     * Where the retrieved item is returned. Item.uDataType is
+     * QCBOR_TYPE_NONE if not found
+     */
+    QCBORItem item;
+};
+
+
+/**
+ * \brief Search a CBOR map for multiple integer-labeled items.
+ *
+ * \param[in,out] decode_context  The QCBOR decode context to
+ *                                consume and look through.
+ * \param[in,out] items           The array of labels to search for
+ *                                and the places to return what was
+ *                                found. See \ref
+ *                                qcbor_util_items_to_get_t.
+ *
+ * \retval ATTEST_TOKEN_ERR_CBOR_STRUCTURE
+ *         The next item in the decode context is not a map.
+ * \retval ATTEST_TOKEN_ERR_CBOR_NOT_WELL_FORMED
+ *         The CBOR is not well-formed.
+ * \retval ATTEST_TOKEN_ERR_SUCCESS
+ *         Success. This just means the map was searched, not that
+ *         anything was found. The contents of \c items must be
+ *         checked to see what was found.
+ *
+ * The next item from \c decode_context must be a map. This is the map
+ * that will be searched. Only items at the immediate subordinate
+ * level in the map will be checked for label matches. This will
+ * consume the all the data items in the map.
+ *
+ * Note that this cannot be used for finding maps and arrays in at map
+ * and decoding them since it consumes them and does not return their
+ * contents. qcbor_util_decode_to_labeled_item() is more useful for
+ * this.
+ *
+ * This will ignore any data items that do not have integer labels.
+ */
+enum attest_token_err_t
+qcbor_util_get_items_in_map(QCBORDecodeContext *decode_context,
+                            struct qcbor_util_items_to_get_t *items);
+
+
+/**
+ * \brief Decode a map up to a particular label and stop.
+ *
+ * \param[in,out] decode_context The QCBOR decode context to
+ *                               consume and look through.
+ * \param[in] label              The label of the item being sought.
+ * \param[out] item              The item that is filled in with the
+ *                               when the match is found.
+ *
+ * \retval ATTEST_TOKEN_ERR_CBOR_STRUCTURE
+ *         The next item in the decode context is not a map.
+ * \retval ATTEST_TOKEN_ERR_CBOR_NOT_WELL_FORMED
+ *         The CBOR is not well-formed.
+ * \retval ATTEST_TOKEN_ERR_SUCCESS
+ *         The labeled item was found.
+ * \retval ATTEST_TOKEN_ERR_NOT_FOUND
+           The entire map was consumed without finding \c label.
+ *
+ * The next item from \c decode_context must be a map. This is the map
+ * that will be searched.
+
+ * This will decode consuming data items from \c decode_context until
+ * the labeled item is found. It will consume all items in any map or
+ * array encountered before finding \c label.
+ *
+ * Typically this is used to decode to the start of a map or array.
+ * The next data item from \c decode_context will be the first item in
+ * the map or the array.
+ *
+ * This works for any CBOR data type, not just maps or arrays.
+ *
+ * This will ignore any data items that do not have integer labels.
+ **/
+enum attest_token_err_t
+qcbor_util_decode_to_labeled_item(QCBORDecodeContext *decode_context,
+                                  int32_t label,
+                                  QCBORItem *item);
+
+
+/**
+ * \brief Search a map for one particular integer labeled item.
+ *
+ * \param[in,out] decode_context The QCBOR decode context to
+ *                               consume and look through.
+ * \param[in] label              The label of the item being sought.
+ * \param[out] item              The item that is filled in when
+ *                               the match is found.
+ *
+ * \retval ATTEST_TOKEN_ERR_CBOR_NOT_WELL_FORMED
+ *         CBOR was not well-formed
+ * \retval ATTEST_TOKEN_ERR_CBOR_STRUCTURE
+ *         Starting item on \c decode context was not a map.
+ * \retval ATTEST_TOKEN_ERR_SUCCESS
+ *         The labeled item was found and returned.
+ * \retval ATTEST_TOKEN_ERR_NOT_FOUND
+ *         The entire map was consumed without finding \c label.
+ *
+ * This is qcbor_util_get_items_in_map() for just one item.
+ *
+ * This will consume the whole map. It is most useful for getting
+ * unstructured data items like integers and strings, but not good for
+ * arrays and maps. See qcbor_util_decode_to_labeled_item() for arrays
+ * and maps.
+ */
+enum attest_token_err_t
+qcbor_util_get_item_in_map(QCBORDecodeContext *decode_context,
+                           int32_t label,
+                           QCBORItem *item);
+
+
+/**
+ * \brief Search encoded CBOR from beginning to end for labeled item.
+ *
+ * \param[in] payload     Encoded chunk of CBOR to decode.
+ * \param[in] label       Integer label of item to look for.
+ * \param[in] qcbor_type  One of \c QCBOR_TYPE_xxx indicating the
+ *                        type of the data item expected.
+ * \param[out] item       Place to copy the \c QCBORItem to that
+ *                        describes what was found.
+ *
+ * \retval ATTEST_TOKEN_ERR_CBOR_TYPE
+ *        The labeled item was found, but it didn't match \c qcbor_type.
+ * \retval ATTEST_TOKEN_ERR_SUCCESS
+ *        The labeled item was found and returned.
+ * \retval ATTEST_TOKEN_ERR_CBOR_NOT_WELL_FORMED
+ *         CBOR was not well-formed
+ * \retval ATTEST_TOKEN_ERR_CBOR_STRUCTURE
+ *         A map was expected.
+ * \retval ATTEST_TOKEN_ERR_NOT_FOUND
+ *         The entire map was consumed without finding \c label.
+ *
+ * This will decode the \c payload from beginning to end. If there are
+ * extra bytes at the end of it or all the maps and arrays in it are
+ * not closed this will return an error.
+ *
+ * Since this decodes the payload from start to finish to find one
+ * item, calling this multiple times to get multiple items will cause
+ * the payload to be completely decoded multiple times. This is not as
+ * efficient as qcbor_util_get_items_in_map(), but not that costly
+ * either.
+ *
+ * This uses qcbor_util_get_item_in_map() to do its work.
+ */
+enum attest_token_err_t
+qcbor_util_get_top_level_item_in_map(struct q_useful_buf_c payload,
+                                     int32_t label,
+                                     uint_fast8_t qcbor_type,
+                                     QCBORItem *item);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __QCBOR_UTILS_H__ */
diff --git a/lib/tf-m/platform/ext/accelerator/cc312/cc312.c b/lib/tf-m/platform/ext/accelerator/cc312/cc312.c
index db92bc0d1..400260ef5 100644
--- a/lib/tf-m/platform/ext/accelerator/cc312/cc312.c
+++ b/lib/tf-m/platform/ext/accelerator/cc312/cc312.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -113,6 +113,11 @@ int crypto_hw_accelerator_finish(void)
     return 0;
 }
 
+int crypto_hw_accelerator_get_lcs(uint32_t *lcs)
+{
+    return mbedtls_mng_lcsGet(lcs);
+}
+
 int crypto_hw_accelerator_huk_derive_key(const uint8_t *label,
                                          size_t label_size,
                                          const uint8_t *context,
@@ -134,3 +139,115 @@ int crypto_hw_accelerator_huk_derive_key(const uint8_t *label,
                                             context, context_size,
                                             key, key_size);
 }
+
+/*
+ * Count number of zero bits in 32-bit word.
+ * Copied from:
+ * lib/ext/cryptocell-312-runtime/host/src/ \
+ * cc3x_productionlib/common/prod_util.c: CC_PROD_GetZeroCount(..)
+ */
+static int get_zero_bits_count(uint32_t *buf,
+                               uint32_t  buf_word_size,
+                               uint32_t *zero_count)
+{
+    uint32_t val;
+    uint32_t index = 0;
+
+    *zero_count = 0;
+    for (index = 0; index < buf_word_size; index++) {
+        val = buf[index];
+        val = val - ((val >> 1) & 0x55555555);
+        val = (val & 0x33333333) + ((val >> 2) & 0x33333333);
+        val = ((((val + (val >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24);
+        *zero_count += (32 - val);
+    }
+    /* All 0's and all 1's is forbidden */
+    if ((*zero_count == 0)
+        || (*zero_count == buf_word_size*CC_BITS_IN_32BIT_WORD)) {
+        *zero_count = 0;
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Get attestation private key from CC312 OTP
+ */
+int crypto_hw_accelerator_get_attestation_private_key(uint8_t  *buf,
+                                                      uint32_t *size)
+{
+    uint32_t *key = (uint32_t *)buf;
+    uint32_t otp_val;
+    uint32_t otp_zero_count;
+    uint32_t zero_count;
+    int i;
+    int rc;
+
+    if (key == NULL ||
+        *size < CC_OTP_ATTESTATION_KEY_SIZE_IN_WORDS * sizeof(uint32_t)) {
+        return -1;
+    }
+    *size = CC_OTP_ATTESTATION_KEY_SIZE_IN_WORDS * sizeof(uint32_t);
+
+    /* Get provisioned key from OTP, 8 words */
+    for (i = 0; i < CC_OTP_ATTESTATION_KEY_SIZE_IN_WORDS; i++) {
+        CC_PROD_OTP_READ(otp_val, CC_OTP_ATTESTATION_KEY_OFFSET + i);
+        *key = otp_val;
+        key++;
+    }
+
+    /* Verify the zero number of private key */
+    rc = get_zero_bits_count((uint32_t *)buf,
+                             CC_OTP_ATTESTATION_KEY_SIZE_IN_WORDS,
+                             &zero_count);
+    if (rc) {
+        return -1;
+    }
+
+    CC_PROD_OTP_READ(otp_zero_count, CC_OTP_ATTESTATION_KEY_ZERO_COUNT_OFFSET);
+    if (otp_zero_count != zero_count) {
+        return -1;
+    }
+
+    return 0;
+}
+
+#ifdef BL2
+int crypto_hw_accelerator_get_rotpk_hash(uint8_t image_id,
+                                         uint8_t *rotpk_hash,
+                                         uint32_t *rotpk_hash_size)
+{
+    int32_t ret;
+    mbedtls_mng_pubKeyType_t key_index;
+    uint32_t rotpk_hash_size_in_words;
+
+    if (image_id == 0) {
+#if (MCUBOOT_IMAGE_NUMBER == 1)
+        key_index = CC_MNG_HASH_BOOT_KEY_256B;
+        rotpk_hash_size_in_words = 8;
+#elif (MCUBOOT_IMAGE_NUMBER == 2)
+        key_index = CC_MNG_HASH_BOOT_KEY_0_128B;
+        rotpk_hash_size_in_words = 4;
+    } else if (image_id == 1) {
+        key_index = CC_MNG_HASH_BOOT_KEY_1_128B;
+        rotpk_hash_size_in_words = 4;
+#endif /* MCUBOOT_IMAGE_NUMBER == 1 */
+    } else {
+        return -1;
+    }
+
+    if (*rotpk_hash_size < rotpk_hash_size_in_words * sizeof(uint32_t)) {
+        return -1;
+    }
+    *rotpk_hash_size = rotpk_hash_size_in_words * sizeof(uint32_t);
+
+    ret = mbedtls_mng_pubKeyHashGet(key_index, (uint32_t *)rotpk_hash,
+                                    rotpk_hash_size_in_words);
+    if (ret) {
+        return ret;
+    }
+
+    return 0;
+}
+#endif  /* BL2 */
diff --git a/lib/tf-m/platform/ext/accelerator/cc312/cc312_log.c b/lib/tf-m/platform/ext/accelerator/cc312/cc312_log.c
index 694e9eeb1..de73c664a 100644
--- a/lib/tf-m/platform/ext/accelerator/cc312/cc312_log.c
+++ b/lib/tf-m/platform/ext/accelerator/cc312/cc312_log.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -24,23 +24,22 @@ void CC_PalLogInit(void){}
 
 void CC_PalLog(int level, const char* format, ...)
 {
-    (void) level;
+   char buf[CC312_LOG_BUF_SIZE] = {0};
+   va_list args;
+   int format_len = strlen(format);
 
-    char buf[CC312_LOG_BUF_SIZE] = {0};
-    va_list args;
-    size_t format_len = strlen(format);
+   if (format_len + 2 > CC312_LOG_BUF_SIZE)
+   {
+       printf("CC312 logging error: Message too long\r\n");
+       return;
+   }
 
-    if (format_len + 2 > CC312_LOG_BUF_SIZE) {
-        printf("CC312 logging error: Message too long\r\n");
-        return;
-    }
 
-    va_start(args, format);
+   va_start(args, format);
 
-    /* CC312 lib doesn't insert CR characters, so it's done here */
-    strcpy(buf, format);
-    buf[format_len] = '\r';
+   /* CC312 lib doesn't insert CR characters so it's done here */
+   strcpy(buf, format);
+   buf[format_len] = '\r';
 
-    // TODO: replace with print function that works at higher isolation levels
-    vprintf(buf, args);
+   vprintf(buf, args);
 }
diff --git a/tf-m.old/platform/ext/accelerator/cc312/cc312_provisioning.c b/lib/tf-m/platform/ext/accelerator/cc312/cc312_provisioning.c
new file mode 100644
index 000000000..40032996b
--- /dev/null
+++ b/lib/tf-m/platform/ext/accelerator/cc312/cc312_provisioning.c
@@ -0,0 +1,416 @@
+/*
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#include "crypto_hw.h"
+#include <stdint.h>
+#include <string.h>
+#include <stdio.h>
+#include "cc_hal_plat.h"
+#include "cc_prod.h"
+#include "cc_cmpu.h"
+#include "cc_dmpu.h"
+#include "cc_pal_types.h"
+#include "dx_reg_base_host.h"
+#include "mbedtls/ecdsa.h"
+#include "cc_rnd_common.h"
+#include "cmpu_derivation.h"
+#include "cmpu_llf_rnd.h"
+#include "mbedtls_cc_mng_int.h"
+#include "cc_prod_error.h"
+#include "prod_util.h"
+
+extern uint8_t rotpk_hash_0[];
+extern uint8_t rotpk_hash_1[];
+
+/* Workspace for provisioning internal use */
+#define PROVISIONING_MEM_BUF_LEN  \
+        (CMPU_WORKSPACE_MINIMUM_SIZE > DMPU_WORKSPACE_MINIMUM_SIZE) ? \
+         CMPU_WORKSPACE_MINIMUM_SIZE : DMPU_WORKSPACE_MINIMUM_SIZE
+__attribute__((aligned(CC_32BIT_WORD_SIZE)))
+static uint8_t provisioning_mem_buf[PROVISIONING_MEM_BUF_LEN];
+
+/*
+ * Extract private key
+ */
+static int extract_private_key(mbedtls_ecdsa_context *key, uint8_t *buf)
+{
+    size_t len;
+
+    len = mbedtls_mpi_size(&key->d);
+    if (mbedtls_mpi_write_binary(&key->d, buf, len) != 0) {
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Generate ECC P256 keypair
+ */
+static int cc312_generate_ecc_p256_keypair(void *rng_state, uint8_t *output,
+                                           size_t len)
+{
+    uint32_t error = 0;
+    uint32_t *pEntrSrc;
+    uint32_t sourceSize;
+    uint8_t  pKey[32] = { 0 };
+    uint8_t  pIv[16] = { 0 };
+    uint32_t *pRndWorkBuff = (uint32_t *)provisioning_mem_buf;
+
+    error = CC_PROD_LLF_RND_GetTrngSource((uint32_t **)&pEntrSrc,
+                                          &sourceSize,
+                                          pRndWorkBuff);
+    if (error != CC_OK) {
+        return error;
+    }
+
+    error = CC_PROD_Derivation_Instantiate(pEntrSrc,
+                                           sourceSize,
+                                           pKey,
+                                           pIv);
+    if (error != CC_OK) {
+        return error;
+    }
+
+    if (len <= 32) {
+        memcpy(output, pKey, len);
+    } else if (len > 32 && len <= 48) {
+        memcpy(output, pKey, 32);
+        memcpy(output + 32, pIv, len - 32);
+    } else {
+        memcpy(output, pKey, 32);
+        memcpy(output + 32, pIv, 16);
+        memset(output + 48, 0, len - 48);
+    }
+
+    return 0;
+}
+
+static int cc312_generate_attestation_key(mbedtls_ecp_group_id curve_type,
+                                          uint8_t *private_key)
+{
+    int rc;
+    mbedtls_ecdsa_context ecdsa;
+
+    if (!private_key || curve_type == MBEDTLS_ECP_DP_NONE) {
+        return -1;
+    }
+
+    mbedtls_ecdsa_init(&ecdsa);
+
+    rc = mbedtls_ecdsa_genkey(&ecdsa, curve_type,
+         cc312_generate_ecc_p256_keypair, NULL);
+    if (rc) {
+        goto exit;
+    }
+
+    rc = extract_private_key(&ecdsa, private_key);
+    if (rc) {
+        goto exit;
+    }
+
+    rc = 0;
+
+exit:
+    mbedtls_ecdsa_free(&ecdsa);
+
+    return rc;
+}
+
+/*
+ * All Musca-S1 platform-dependent defines (DX_PLAT_MUSCA_S1) are due to the
+ * fact that the S1 board's OTP is just an ordinary register which is volatile.
+ * The MRAM is used instead, and this is what the changes reflect.
+ */
+#ifdef DX_PLAT_MUSCA_S1
+
+#define HAL_WRITE_MRAM_UINT32(val, regOffset)                      \
+        (*((volatile uint32_t *)(DX_MRAM_CC + ((regOffset) *       \
+        sizeof(uint32_t)))) = (val))
+
+static void cc312_otp_copy_to_mram(const uint32_t offs, size_t size_in_words)
+{
+    uint32_t i = 0;
+    uint32_t temp = 0;
+
+    for(i = 0; i < size_in_words; i++) {
+        CC_PROD_OTP_READ(temp, offs + i);
+        HAL_WRITE_MRAM_UINT32(temp, offs + i);
+    }
+}
+
+static void cc312_otp_copy_attestation_to_mram(void)
+{
+    cc312_otp_copy_to_mram(CC_OTP_ATTESTATION_KEY_OFFSET,
+                           CC_OTP_ATTESTATION_KEY_SIZE_IN_WORDS);
+
+    cc312_otp_copy_to_mram(CC_OTP_ATTESTATION_KEY_ZERO_COUNT_OFFSET, 1);
+}
+
+static int32_t cc312_otp_copy_dm_content_to_mram(CCDmpuData_t *pDmpuData)
+{
+    uint32_t hbkSizeInWords;
+    uint32_t hbkOtpWordOffset;
+    uint32_t swVerOtpWordOffset;
+    uint32_t swVerSizeInWords;
+    uint32_t icvWord;
+
+    if (pDmpuData == NULL) {
+        return -1;
+    }
+
+    CC_PROD_OTP_READ(icvWord, CC_OTP_MANUFACTURE_FLAG_OFFSET);
+
+    switch (pDmpuData->hbkType) {
+    case DMPU_HBK_TYPE_HBK1:
+            if (!IS_HBK0_USED(icvWord)) {
+                return -1;
+            }
+            hbkSizeInWords = CC_OTP_HBK1_SIZE_IN_WORDS;
+            hbkOtpWordOffset = CC_OTP_HBK1_OFFSET;
+            swVerOtpWordOffset = CC_OTP_HBK1_MIN_VERSION_OFFSET;
+            swVerSizeInWords = CC_OTP_HBK1_MIN_VERSION_SIZE_IN_WORDS;
+            break;
+    case DMPU_HBK_TYPE_HBK:
+            if (IS_HBK0_USED(icvWord)) {
+                return -1;
+            }
+            hbkSizeInWords = CC_OTP_HBK_SIZE_IN_WORDS;
+            hbkOtpWordOffset = CC_OTP_HBK_OFFSET;
+            swVerOtpWordOffset = CC_OTP_HBK_MIN_VERSION_OFFSET;
+            swVerSizeInWords = CC_OTP_HBK_MIN_VERSION_SIZE_IN_WORDS;
+            break;
+    default:
+            return -1;
+    }
+
+
+    cc312_otp_copy_to_mram(CC_OTP_OEM_FLAG_OFFSET, 1);
+
+    cc312_otp_copy_to_mram(hbkOtpWordOffset, hbkSizeInWords);
+
+    cc312_otp_copy_to_mram(CC_OTP_DCU_OFFSET, CC_OTP_DCU_SIZE_IN_WORDS);
+
+    cc312_otp_copy_to_mram(swVerOtpWordOffset, swVerSizeInWords);
+
+    if (pDmpuData->kcpDataType != ASSET_NO_KEY) {
+        cc312_otp_copy_to_mram(CC_OTP_KCP_OFFSET, CC_OTP_KCP_SIZE_IN_WORDS);
+    }
+    if (pDmpuData->kceDataType != ASSET_NO_KEY) {
+        cc312_otp_copy_to_mram(CC_OTP_KCE_OFFSET, CC_OTP_KCE_SIZE_IN_WORDS);
+    }
+
+    return 0;
+}
+
+static int32_t cc312_otp_copy_cm_content_to_mram(CCCmpuData_t *pCmpuData)
+{
+    if (pCmpuData == NULL) {
+        return -1;
+    }
+
+    cc312_otp_copy_to_mram(CC_OTP_MANUFACTURE_FLAG_OFFSET, 1);
+
+    cc312_otp_copy_to_mram(CC_OTP_HUK_OFFSET, CC_OTP_HUK_SIZE_IN_WORDS);
+
+    if (pCmpuData->uniqueDataType == CMPU_UNIQUE_IS_HBK0) {
+        cc312_otp_copy_to_mram(CC_OTP_HBK0_OFFSET, CC_OTP_HBK0_SIZE_IN_WORDS);
+
+        cc312_otp_copy_to_mram(CC_OTP_DCU_OFFSET, CC_OTP_DCU_SIZE_IN_WORDS);
+
+        cc312_otp_copy_to_mram(CC_OTP_HBK0_MIN_VERSION_OFFSET,
+        CC_OTP_HBK0_MIN_VERSION_SIZE_IN_WORDS);
+    }
+    if (pCmpuData->kpicvDataType  != ASSET_NO_KEY) {
+        cc312_otp_copy_to_mram(CC_OTP_KPICV_OFFSET,
+                               CC_OTP_KPICV_SIZE_IN_WORDS);
+    }
+    if (pCmpuData->kceicvDataType  != ASSET_NO_KEY) {
+        cc312_otp_copy_to_mram(CC_OTP_KCEICV_OFFSET,
+                               CC_OTP_KCEICV_SIZE_IN_WORDS);
+    }
+    cc312_otp_copy_to_mram(CC_OTP_ICV_GENERAL_PURPOSE_FLAG_OFFSET, 1);
+
+    return 0;
+}
+#endif /* DX_PLAT_MUSCA_S1 */
+
+
+
+static int cc312_program_attestation_private_key(
+                                    mbedtls_ecp_group_id curve_type)
+{
+    uint32_t private_key[8];
+    uint32_t error;
+    uint32_t zero_count;
+    int ret;
+
+    /* Check if the attestation key area has been programmed */
+    CC_PROD_OTP_READ(zero_count, CC_OTP_ATTESTATION_KEY_ZERO_COUNT_OFFSET);
+    if (zero_count) {
+        return -1;
+    }
+
+    ret = cc312_generate_attestation_key(curve_type,
+                                        (uint8_t *)private_key);
+    if (ret) {
+        return -1;
+    }
+
+    /* Program private key to OTP */
+    CC_PROD_OTP_WRITE_VERIFY_WORD_BUFF(CC_OTP_ATTESTATION_KEY_OFFSET,
+                                       private_key,
+                                       CC_OTP_ATTESTATION_KEY_SIZE_IN_WORDS,
+                                       error);
+    if (error != CC_OK) {
+        return -1;
+     }
+
+    CC_PROD_GetZeroCount(private_key,
+                         CC_OTP_ATTESTATION_KEY_SIZE_IN_WORDS,
+                         &zero_count);
+    /* Program the number of zero bits in the private key. This is used to
+     * detect whether the private key is overwritten or tampered.
+     */
+    CC_PROD_OTP_WRITE_VERIFY_WORD(CC_OTP_ATTESTATION_KEY_ZERO_COUNT_OFFSET,
+                                  zero_count,
+                                  error);
+
+    if (error != CC_OK) {
+        return -1;
+    }
+
+#ifdef DX_PLAT_MUSCA_S1
+    cc312_otp_copy_attestation_to_mram();
+#endif
+
+    return 0;
+}
+
+static int cc312_cmpu_provision(void)
+{
+    int rc;
+    uint8_t *pWorkspaceBuf = provisioning_mem_buf;
+    static const uint32_t DCU_DEFAULT_LOCK[PROD_DCU_LOCK_WORD_SIZE];
+    static CCCmpuData_t cmpuData;
+
+    /* Populate cmpuData with data */
+#if (MCUBOOT_IMAGE_NUMBER == 1)
+    /* HBK won't be provisioned */
+    cmpuData.uniqueDataType = CMPU_UNIQUE_IS_USER_DATA;
+#elif (MCUBOOT_IMAGE_NUMBER == 2)
+    cmpuData.uniqueDataType = CMPU_UNIQUE_IS_HBK0;
+    memcpy(cmpuData.uniqueBuff.hbk0, rotpk_hash_0, 16);
+#else
+#error "MCUBOOT_IMAGE_NUMBER is not defined or has invalid value"
+#endif
+
+    cmpuData.kpicvDataType = ASSET_NO_KEY;
+    cmpuData.kceicvDataType = ASSET_NO_KEY;
+    cmpuData.icvMinVersion = 0;
+    cmpuData.icvConfigWord = 0;
+
+    memcpy(cmpuData.icvDcuDefaultLock, DCU_DEFAULT_LOCK,
+           sizeof(DCU_DEFAULT_LOCK));
+
+    rc = CCProd_Cmpu(DX_BASE_CC, &cmpuData, (unsigned long)pWorkspaceBuf,
+                     CMPU_WORKSPACE_MINIMUM_SIZE);
+
+#ifdef DX_PLAT_MUSCA_S1
+    if (rc) {
+        return rc;
+    }
+
+    rc = cc312_otp_copy_cm_content_to_mram(&cmpuData);
+#endif
+
+    return rc;
+}
+
+static int cc312_dmpu_provision(void)
+{
+    int rc;
+    uint8_t *pWorkspaceBuf = provisioning_mem_buf;
+    static const uint32_t DCU_DEFAULT_LOCK[PROD_DCU_LOCK_WORD_SIZE];
+    static CCDmpuData_t dmpuData;
+
+    /* Populate dmpuData with data */
+#if (MCUBOOT_IMAGE_NUMBER == 1)
+    dmpuData.hbkType = DMPU_HBK_TYPE_HBK;
+    memcpy(dmpuData.hbkBuff.hbk, rotpk_hash_0, 32);
+#elif (MCUBOOT_IMAGE_NUMBER == 2)
+    dmpuData.hbkType = DMPU_HBK_TYPE_HBK1;
+    memcpy(dmpuData.hbkBuff.hbk1, rotpk_hash_1, 16);
+#else
+#error "MCUBOOT_IMAGE_NUMBER is not defined or has invalid value"
+#endif
+
+    dmpuData.kcpDataType = ASSET_NO_KEY;
+    dmpuData.kceDataType = ASSET_NO_KEY;
+    dmpuData.oemMinVersion = 0;
+
+    memcpy(dmpuData.oemDcuDefaultLock, DCU_DEFAULT_LOCK,
+           sizeof(DCU_DEFAULT_LOCK));
+
+    rc = CCProd_Dmpu(DX_BASE_CC, &dmpuData, (unsigned long)pWorkspaceBuf,
+                     DMPU_WORKSPACE_MINIMUM_SIZE);
+
+#ifdef DX_PLAT_MUSCA_S1
+    if (rc) {
+        return rc;
+    }
+
+    rc = cc312_otp_copy_dm_content_to_mram(&dmpuData);
+#endif
+
+    return rc;
+}
+
+int crypto_hw_accelerator_otp_provisioning(void)
+{
+    int rc;
+    uint32_t lcs;
+
+    gCcRegBase = DX_BASE_CC;
+
+    if (CCProd_Init() != CC_OK) {
+        return -1;
+    }
+
+    rc = mbedtls_mng_lcsGet(&lcs);
+    if (rc) {
+        return rc;
+    }
+
+    /* First cycle - program the attestation key and HUK */
+    if (lcs == CC_MNG_LCS_CM) {
+        rc = cc312_program_attestation_private_key(MBEDTLS_ECP_DP_SECP256R1);
+        if (rc) {
+            return rc;
+        }
+        printf("First cycle: Attestation key is provisioned successfully\r\n");
+        rc = cc312_cmpu_provision();
+        if (rc) {
+            return rc;
+        }
+        printf("First cycle: HUK is provisioned successfully\r\n");
+        printf("Please reset the board to program ROTPK\r\n");
+    /* Second cycle - program the ROTPK */
+    } else if (lcs == CC_MNG_LCS_DM) {
+        rc = cc312_dmpu_provision();
+        if (rc) {
+            return rc;
+        }
+        printf("Second cycle: ROTPK is provisioned successfully\r\n");
+        printf("Provisioning finished, reset the board to get secure"
+               " enabled lifecycle\r\n");
+    } else {
+        printf("Board is in invalid lifecycle for provisioning: %u\r\n", lcs);
+    }
+
+    return 0;
+}
diff --git a/lib/tf-m/platform/ext/accelerator/interface/crypto_hw.h b/lib/tf-m/platform/ext/accelerator/interface/crypto_hw.h
index 039ba9807..d4c7aaf64 100644
--- a/lib/tf-m/platform/ext/accelerator/interface/crypto_hw.h
+++ b/lib/tf-m/platform/ext/accelerator/interface/crypto_hw.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -15,6 +15,18 @@
 extern "C" {
 #endif /* __cplusplus */
 
+/* The CC312 uses some the MBEDTLS heap buffer, so it needs increasing in size
+ * to allow attest crypto operations to still function.
+ */
+#ifndef TFM_CRYPTO_ENGINE_BUF_SIZE
+#define TFM_CRYPTO_ENGINE_BUF_SIZE (0x4000) /* 16KB for EC signing in attest */
+#endif
+
+/* Offsets are specified in 32-bit words */
+#define CC_OTP_ATTESTATION_KEY_OFFSET               (0x30UL)
+#define CC_OTP_ATTESTATION_KEY_SIZE_IN_WORDS        (8)
+#define CC_OTP_ATTESTATION_KEY_ZERO_COUNT_OFFSET    (0x2FUL)
+
 /**
  * \brief Initialize the CC312 crypto accelerator
  *
@@ -49,6 +61,53 @@ int crypto_hw_accelerator_huk_derive_key(const uint8_t *label,
                                          uint8_t *key,
                                          size_t key_size);
 
+/**
+ * \brief Write the crypto keys to One-Time-Programmable memory
+ *
+ * The following keys will be provisioned:
+ *  - Hardware Unique Key (HUK)
+ *  - Hash of ROTPK
+ *  - Attestation private key
+ *
+ * \return 0 on success, non-zero otherwise
+ */
+int crypto_hw_accelerator_otp_provisioning(void);
+
+/**
+ * \brief Retrieve the hash of ROTPK from OTP
+ *
+ * \param[in]      image_id         The identifier of firmware image
+ * \param[out]     rotpk_hash       Buffer to store the key-hash in
+ * \param[in,out]  rotpk_hash_size  As input the size of the buffer. As output
+ *                                  the actual key-hash length.
+ *
+ * \return 0 on success, non-zero otherwise
+ */
+int crypto_hw_accelerator_get_rotpk_hash(uint8_t image_id,
+                                         uint8_t *rotpk_hash,
+                                         uint32_t *rotpk_hash_size);
+
+/**
+ * \brief Retrieve the attestation private key from OTP
+ *
+ * \param[out]     buf   Buffer to store the key in
+ * \param[in,out]  size  As input the size of the buffer. As output the actual
+ *                       size of the key in bytes.
+ *
+ * \return 0 on success, non-zero otherwise
+ */
+int crypto_hw_accelerator_get_attestation_private_key(uint8_t *buf,
+                                                      uint32_t *size);
+
+/**
+ * \brief Retrieve the device lifecycle
+ *
+ * \param[out]  lcs  Pointer to store lifecycle state
+ *
+ * \return 0 on success, non-zero otherwise
+ */
+int crypto_hw_accelerator_get_lcs(uint32_t *lcs);
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/lib/tf-m/platform/ext/cmsis/core_cm33.h b/lib/tf-m/platform/ext/cmsis/core_cm33.h
index 7fed59a88..47ba42d99 100644
--- a/lib/tf-m/platform/ext/cmsis/core_cm33.h
+++ b/lib/tf-m/platform/ext/cmsis/core_cm33.h
@@ -938,6 +938,19 @@ typedef struct
 #define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
 #define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
 
+/* Coprocessor Power Control Register Definitions */
+#define SCnSCB_CPPWR_SUS11_Pos              23U                                        /*!< CPPWR: SUS11 Position */
+#define SCnSCB_CPPWR_SUS11_Msk              (1UL << SCnSCB_CPPWR_SUS11_Pos)            /*!< CPPWR: SUS11 Mask */
+
+#define SCnSCB_CPPWR_SU11_Pos               22U                                        /*!< CPPWR: SU11 Position */
+#define SCnSCB_CPPWR_SU11_Msk               (1UL << SCnSCB_CPPWR_SU11_Pos)             /*!< CPPWR: SU11 Mask */
+
+#define SCnSCB_CPPWR_SUS10_Pos              21U                                        /*!< CPPWR: SUS10 Position */
+#define SCnSCB_CPPWR_SUS10_Msk              (1UL << SCnSCB_CPPWR_SUS10_Pos)            /*!< CPPWR: SUS10 Mask */
+
+#define SCnSCB_CPPWR_SU10_Pos               20U                                        /*!< CPPWR: SU10 Position */
+#define SCnSCB_CPPWR_SU10_Msk               (1UL << SCnSCB_CPPWR_SU10_Pos)             /*!< CPPWR: SU10 Mask */
+
 /*@} end of group CMSIS_SCnotSCB */
 
 
diff --git a/lib/tf-m/platform/ext/common/armclang/tfm_common_s.sct b/lib/tf-m/platform/ext/common/armclang/tfm_common_s.sct
index cce157329..c68fd6292 100644
--- a/lib/tf-m/platform/ext/common/armclang/tfm_common_s.sct
+++ b/lib/tf-m/platform/ext/common/armclang/tfm_common_s.sct
@@ -116,19 +116,19 @@ LR_CODE S_CODE_START S_CODE_SIZE {
     }
 
     /* MSP */
-    ARM_LIB_STACK +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
+    ARM_LIB_STACK_MSP +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
     }
 
 # if !defined(TFM_PSA_API)
     /* PSP is unprivileged in single-core topology. Reserve 8 bytes for seal */
-    ER_INITIAL_PSP +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE - 0x8 {
+    ARM_LIB_STACK +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE - 0x8 {
     }
 
-    ER_INITIAL_PSP_SEAL +0 EMPTY 0x8 {
+    ARM_LIB_STACK_SEAL +0 EMPTY 0x8 {
     }
 # else
     /* PSP is unprivileged in single-core topology */
-    ER_INITIAL_PSP +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
+    ARM_LIB_STACK +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
     }
 # endif /* !defined(TFM_PSA_API) */
 #endif
@@ -181,11 +181,11 @@ LR_CODE S_CODE_START S_CODE_SIZE {
     }
 
     /* MSP */
-    ARM_LIB_STACK +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
+    ARM_LIB_STACK_MSP +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
     }
 
     /* PSP is privileged in multi-core topology */
-    ER_INITIAL_PSP +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
+    ARM_LIB_STACK +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
     }
 #endif
 
diff --git a/lib/tf-m/platform/ext/common/armclang/tfm_isolation_l3.sct.template b/lib/tf-m/platform/ext/common/armclang/tfm_isolation_l3.sct.template
index 3c0a23cc6..c546061e0 100644
--- a/lib/tf-m/platform/ext/common/armclang/tfm_isolation_l3.sct.template
+++ b/lib/tf-m/platform/ext/common/armclang/tfm_isolation_l3.sct.template
@@ -124,7 +124,7 @@ LR_CODE S_CODE_START {
     }
 
     /* MSP */
-    ARM_LIB_STACK +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
+    ARM_LIB_STACK_MSP +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
     }
 
     ARM_LIB_HEAP +0 ALIGN 8 EMPTY S_HEAP_SIZE {
@@ -185,7 +185,7 @@ LR_CODE S_CODE_START {
     }
 
     /* PSP is unprivileged in single-core topology */
-    ER_INITIAL_PSP +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
+    ARM_LIB_STACK +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
     }
 
 {% for partition in partitions %}
diff --git a/lib/tf-m/platform/ext/common/gcc/tfm_common_s.ld b/lib/tf-m/platform/ext/common/gcc/tfm_common_s.ld
index d3aada370..75de32d15 100644
--- a/lib/tf-m/platform/ext/common/gcc/tfm_common_s.ld
+++ b/lib/tf-m/platform/ext/common/gcc/tfm_common_s.ld
@@ -248,8 +248,8 @@ SECTIONS
     {
         . += __msp_init_stack_size__;
     } > RAM
-    Image$$ARM_LIB_STACK$$ZI$$Base = ADDR(.msp_stack);
-    Image$$ARM_LIB_STACK$$ZI$$Limit = ADDR(.msp_stack) + SIZEOF(.msp_stack);
+    Image$$ARM_LIB_STACK_MSP$$ZI$$Base = ADDR(.msp_stack);
+    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit = ADDR(.msp_stack) + SIZEOF(.msp_stack);
 
     /* PSP is unprivileged in single-core topology */
     .psp_stack : ALIGN(32)
@@ -260,16 +260,16 @@ SECTIONS
         . += (__psp_stack_size__);
 # endif
     } > RAM
-    Image$$ER_INITIAL_PSP$$ZI$$Base = ADDR(.psp_stack);
-    Image$$ER_INITIAL_PSP$$ZI$$Limit = ADDR(.psp_stack) + SIZEOF(.psp_stack);
+    Image$$ARM_LIB_STACK$$ZI$$Base = ADDR(.psp_stack);
+    Image$$ARM_LIB_STACK$$ZI$$Limit = ADDR(.psp_stack) + SIZEOF(.psp_stack);
 
 # if !defined(TFM_PSA_API)
     .psp_stack_seal_res :
     {
         . += 0x8;
     } > RAM
-    Image$$ER_INITIAL_PSP_SEAL$$ZI$$Base = ADDR(.psp_stack_seal_res);
-    Image$$ER_INITIAL_PSP_SEAL$$ZI$$Limit = ADDR(.psp_stack_seal_res) + SIZEOF(.psp_stack_seal_res);
+    Image$$ARM_LIB_STACK_SEAL$$ZI$$Base = ADDR(.psp_stack_seal_res);
+    Image$$ARM_LIB_STACK_SEAL$$ZI$$Limit = ADDR(.psp_stack_seal_res) + SIZEOF(.psp_stack_seal_res);
 # endif
 #endif
 
@@ -400,16 +400,16 @@ SECTIONS
     {
         . += __msp_init_stack_size__;
     } > RAM
-    Image$$ARM_LIB_STACK$$ZI$$Base = ADDR(.msp_stack);
-    Image$$ARM_LIB_STACK$$ZI$$Limit = ADDR(.msp_stack) + SIZEOF(.msp_stack);
+    Image$$ARM_LIB_STACK_MSP$$ZI$$Base = ADDR(.msp_stack);
+    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit = ADDR(.msp_stack) + SIZEOF(.msp_stack);
 
     /* PSP is privileged in multi-core topology */
     .psp_stack : ALIGN(32)
     {
         . += __psp_stack_size__;
     } > RAM
-    Image$$ER_INITIAL_PSP$$ZI$$Base = ADDR(.psp_stack);
-    Image$$ER_INITIAL_PSP$$ZI$$Limit = ADDR(.psp_stack) + SIZEOF(.psp_stack);
+    Image$$ARM_LIB_STACK$$ZI$$Base = ADDR(.psp_stack);
+    Image$$ARM_LIB_STACK$$ZI$$Limit = ADDR(.psp_stack) + SIZEOF(.psp_stack);
 #endif
 
     /**** PSA RoT DATA start here */
diff --git a/lib/tf-m/platform/ext/common/gcc/tfm_isolation_l3.ld.template b/lib/tf-m/platform/ext/common/gcc/tfm_isolation_l3.ld.template
index 4b649f678..14ef0cabb 100644
--- a/lib/tf-m/platform/ext/common/gcc/tfm_isolation_l3.ld.template
+++ b/lib/tf-m/platform/ext/common/gcc/tfm_isolation_l3.ld.template
@@ -271,8 +271,8 @@ SECTIONS
     {
         . += __msp_init_stack_size__;
     } > RAM
-    Image$$ARM_LIB_STACK$$ZI$$Base = ADDR(.msp_stack);
-    Image$$ARM_LIB_STACK$$ZI$$Limit = ADDR(.msp_stack) + SIZEOF(.msp_stack);
+    Image$$ARM_LIB_STACK_MSP$$ZI$$Base = ADDR(.msp_stack);
+    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit = ADDR(.msp_stack) + SIZEOF(.msp_stack);
 
     /**** PSA RoT DATA start here */
 {% for partition in partitions %}
@@ -346,8 +346,8 @@ SECTIONS
     {
         . += (__psp_stack_size__);
     } > RAM
-    Image$$ER_INITIAL_PSP$$ZI$$Base = ADDR(.psp_stack);
-    Image$$ER_INITIAL_PSP$$ZI$$Limit = ADDR(.psp_stack) + SIZEOF(.psp_stack);
+    Image$$ARM_LIB_STACK$$ZI$$Base = ADDR(.psp_stack);
+    Image$$ARM_LIB_STACK$$ZI$$Limit = ADDR(.psp_stack) + SIZEOF(.psp_stack);
 
     /**** APPLICATION RoT DATA start here */
 {% for partition in partitions %}
diff --git a/lib/tf-m/platform/ext/common/iar/tfm_common_s.icf b/lib/tf-m/platform/ext/common/iar/tfm_common_s.icf
index 1f2e80d05..3da205dd3 100644
--- a/lib/tf-m/platform/ext/common/iar/tfm_common_s.icf
+++ b/lib/tf-m/platform/ext/common/iar/tfm_common_s.icf
@@ -24,9 +24,6 @@ define block ER_TFM_CODE with fixed order, alignment = 8, maximum size = S_CODE_
 #ifndef S_RAM_CODE_START
        rw section .textrw object *.o,           /* place __ramfunc in ROM if no TFM_RAM_CODE block */
 #endif
-       ro section .text  object *libplatform_s*,
-       ro section .rodata object *libplatform_s*,
-       ro object *libtfm_spm*,
        readonly
 };
 
@@ -83,17 +80,11 @@ define block TFM_APP_CODE_END with alignment = 32, size = 0 { };
 
 #if defined(S_CODE_SRAM_ALIAS_BASE)
     /* eFlash driver code that gets copied from Flash to SRAM */
-initialize by copy {
+define block ER_CODE_SRAM with alignment = 4 {
        ro object Driver_GFC100_EFlash.o,
        ro object gfc100_eflash_drv.o,
        ro object musca_b1_eflash_drv.o
-       };
-
-define block ER_CODE_SRAM  with fixed order, alignment = 8 {
-       rw section .text,
-       rw section .rodata
-       };
-
+    };
 place at address S_CODE_SRAM_ALIAS_BASE { block ER_CODE_SRAM };
 #endif
 
@@ -103,18 +94,18 @@ define block TFM_SECURE_DATA_START with size = 0 { };
 #ifndef TFM_MULTI_CORE_TOPOLOGY
     /* Shared area between BL2 and runtime to exchange data */
 define block TFM_SHARED_DATA with alignment = 32, size = BOOT_TFM_SHARED_DATA_SIZE { };
-define block ARM_LIB_STACK with alignment = 32, size = S_MSP_STACK_SIZE { };
+define block ARM_LIB_STACK_MSP with alignment = 32, size = S_MSP_STACK_SIZE { };
 define overlay STACK_DATA {block TFM_SHARED_DATA};
-define overlay STACK_DATA {block ARM_LIB_STACK};
+define overlay STACK_DATA {block ARM_LIB_STACK_MSP};
 
 # if !defined(TFM_PSA_API)
     /* Reserve space for stack seal (8 bytes) */
-define block ER_INITIAL_PSP with alignment = 32, size = S_PSP_STACK_SIZE - 0x8 { };
-define block ER_INITIAL_PSP_SEAL with size = 0x8 { };
+define block ARM_LIB_STACK with alignment = 32, size = S_PSP_STACK_SIZE - 0x8 { };
+define block ARM_LIB_STACK_SEAL with size = 0x8 { };
 # else
-define block ER_INITIAL_PSP with alignment = 32, size = S_PSP_STACK_SIZE { };
+define block ARM_LIB_STACK with alignment = 32, size = S_PSP_STACK_SIZE { };
 # endif
-keep {block TFM_SHARED_DATA, block ARM_LIB_STACK};
+keep {block TFM_SHARED_DATA, block ARM_LIB_STACK_MSP};
 #endif
 
 #if !defined(TFM_PSA_API)
@@ -155,14 +146,14 @@ define block TFM_SECURE_PRIV_DATA_BOUNDARY with size = 0 { };
 define block TFM_SHARED_DATA with alignment = 32, size = BOOT_TFM_SHARED_DATA_SIZE { };
 
     /* MSP */
-define block ARM_LIB_STACK with alignment = 32, size = S_MSP_STACK_SIZE { };
+define block ARM_LIB_STACK_MSP with alignment = 32, size = S_MSP_STACK_SIZE { };
 
 define overlay STACK_DATA {block TFM_SHARED_DATA};
-define overlay STACK_DATA {block ARM_LIB_STACK};
+define overlay STACK_DATA {block ARM_LIB_STACK_MSP};
 
     /* PSP is privileged in multi-core topology */
-define block ER_INITIAL_PSP with alignment = 32, size = S_PSP_STACK_SIZE { };
-keep {block TFM_SHARED_DATA, block ARM_LIB_STACK};
+define block ARM_LIB_STACK with alignment = 32, size = S_PSP_STACK_SIZE { };
+keep {block TFM_SHARED_DATA, block ARM_LIB_STACK_MSP};
 #endif
 
 define block HEAP         with alignment = 8, size = S_HEAP_SIZE { };
@@ -281,10 +272,10 @@ define block DATA with fixed order {
     /* Shared area between BL2 and runtime to exchange data */
     overlay STACK_DATA,
     /* PSP is unprivileged in single-core topology */
-    block ER_INITIAL_PSP,
+    block ARM_LIB_STACK,
 # if !defined(TFM_PSA_API)
     /* Define stack seal block for Library mode */
-    block ER_INITIAL_PSP_SEAL,
+    block ARM_LIB_STACK_SEAL,
 # endif
 #endif
 
@@ -326,7 +317,7 @@ define block PRIV_DATA with fixed order {
     /* Shared area between BL2 and runtime to exchange data */
     overlay STACK_DATA,
     /* PSP is privileged in multi-core topology */
-    block ER_INITIAL_PSP,
+    block ARM_LIB_STACK,
 #endif
 
     overlay HEAP_OVL,
diff --git a/lib/tf-m/platform/ext/common/template/attest_hal.c b/lib/tf-m/platform/ext/common/template/attest_hal.c
index 03fd29479..69bafdddb 100644
--- a/lib/tf-m/platform/ext/common/template/attest_hal.c
+++ b/lib/tf-m/platform/ext/common/template/attest_hal.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -7,132 +7,122 @@
 
 #include <stddef.h>
 #include <stdint.h>
-#include <string.h>
 #include "tfm_attest_hal.h"
 #include "tfm_plat_boot_seed.h"
 #include "tfm_plat_device_id.h"
-#include "tfm_plat_otp.h"
-
-static enum tfm_security_lifecycle_t map_otp_lcs_to_tfm_slc(enum plat_otp_lcs_t lcs) {
-    switch (lcs) {
-        case PLAT_OTP_LCS_ASSEMBLY_AND_TEST:
-            return TFM_SLC_ASSEMBLY_AND_TEST;
-        case PLAT_OTP_LCS_PSA_ROT_PROVISIONING:
-            return TFM_SLC_PSA_ROT_PROVISIONING;
-        case PLAT_OTP_LCS_SECURED:
-            return TFM_SLC_SECURED;
-        case PLAT_OTP_LCS_DECOMMISSIONED:
-            return TFM_SLC_DECOMMISSIONED;
-        case PLAT_OTP_LCS_UNKNOWN:
-        default:
-            return TFM_SLC_UNKNOWN;
-    }
-}
-
-enum tfm_security_lifecycle_t tfm_attest_hal_get_security_lifecycle(void)
-{
-    enum plat_otp_lcs_t otp_lcs;
-    enum tfm_plat_err_t err;
 
-    err = tfm_plat_otp_read(PLAT_OTP_ID_LCS, sizeof(otp_lcs), (uint8_t*)&otp_lcs);
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        return TFM_SLC_UNKNOWN;
-    }
+/*!
+ * \def BOOT_SEED
+ *
+ * \brief Fixed value for boot seed used for test.
+ */
+#define BOOT_SEED   0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, \
+                    0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, \
+                    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, \
+                    0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF
 
-    return map_otp_lcs_to_tfm_slc(otp_lcs);
-}
+static const uint8_t boot_seed[BOOT_SEED_SIZE] = {BOOT_SEED};
 
-enum tfm_plat_err_t
-tfm_attest_hal_get_verification_service(uint32_t *size, uint8_t *buf)
-{
-    enum tfm_plat_err_t err;
-    size_t otp_size;
+/* Example verification service URL for initial attestation token */
+static const char verification_service_url[] = "www.trustedfirmware.org";
 
-    err = tfm_plat_otp_read(PLAT_OTP_ID_VERIFICATION_SERVICE_URL, *size, buf);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+/* Example profile definition document for initial attestation token */
+static const char attestation_profile_definition[] = "PSA_IOT_PROFILE_1";
 
-    err =  tfm_plat_otp_get_size(PLAT_OTP_ID_VERIFICATION_SERVICE_URL, &otp_size);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+static const uint8_t implementation_id[] = {
+    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
+    0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
+    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
+    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
+};
 
-    *size = strnlen((char*)buf, otp_size);
+static const uint8_t example_ean_13[] = "060456527282910010";
 
-    return TFM_PLAT_ERR_SUCCESS;
+enum tfm_security_lifecycle_t tfm_attest_hal_get_security_lifecycle(void)
+{
+    return TFM_SLC_SECURED;
 }
 
-enum tfm_plat_err_t
-tfm_attest_hal_get_profile_definition(uint32_t *size, uint8_t *buf)
+const char *
+tfm_attest_hal_get_verification_service(uint32_t *size)
 {
-    enum tfm_plat_err_t err;
-    size_t otp_size;
+    *size = sizeof(verification_service_url) - 1;
 
-    err = tfm_plat_otp_read(PLAT_OTP_ID_PROFILE_DEFINITION, *size, buf);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+    return verification_service_url;
+}
 
-    err =  tfm_plat_otp_get_size(PLAT_OTP_ID_PROFILE_DEFINITION, &otp_size);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+const char *
+tfm_attest_hal_get_profile_definition(uint32_t *size)
+{
+    *size = sizeof(attestation_profile_definition) - 1;
 
-    *size = strnlen((char*)buf, otp_size);
+    return attestation_profile_definition;
+}
 
-    return TFM_PLAT_ERR_SUCCESS;
+/**
+ * \brief Copy data in source buffer to the destination buffer
+ *
+ * \param[out]  p_dst  Pointer to destation buffer
+ * \param[in]   p_src  Pointer to source buffer
+ * \param[in]   size   Length of data to be copied
+ */
+static inline void copy_buf(uint8_t *p_dst, const uint8_t *p_src, size_t size)
+{
+    uint32_t i;
+
+    for (i = size; i > 0; i--) {
+        *p_dst = *p_src;
+        p_src++;
+        p_dst++;
+    }
 }
 
 enum tfm_plat_err_t tfm_plat_get_boot_seed(uint32_t size, uint8_t *buf)
 {
-    enum tfm_plat_err_t err;
+    /* FixMe: - This getter function must be ported per target platform.
+     *        - Platform service shall provide an API to further interact this
+     *          getter function to retrieve the boot seed.
+     */
 
-    err = tfm_plat_otp_read(PLAT_OTP_ID_BOOT_SEED, size, buf);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
+    uint8_t *p_dst = buf;
+    const uint8_t *p_src = boot_seed;
+
+    if (size != BOOT_SEED_SIZE) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
+    copy_buf(p_dst, p_src, size);
+
     return TFM_PLAT_ERR_SUCCESS;
 }
 
 enum tfm_plat_err_t tfm_plat_get_implementation_id(uint32_t *size,
                                                    uint8_t  *buf)
 {
-    enum tfm_plat_err_t err;
-    size_t otp_size;
+    const uint8_t *p_impl_id = implementation_id;
+    uint32_t impl_id_size = sizeof(implementation_id);
 
-    err = tfm_plat_otp_read(PLAT_OTP_ID_IMPLEMENTATION_ID, *size, buf);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
+    if (*size < impl_id_size) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
-    err =  tfm_plat_otp_get_size(PLAT_OTP_ID_IMPLEMENTATION_ID, &otp_size);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
-
-    *size = otp_size;
+    copy_buf(buf, p_impl_id, impl_id_size);
+    *size = impl_id_size;
 
     return TFM_PLAT_ERR_SUCCESS;
 }
 
 enum tfm_plat_err_t tfm_plat_get_hw_version(uint32_t *size, uint8_t *buf)
 {
-    enum tfm_plat_err_t err;
-    size_t otp_size;
-
-    err = tfm_plat_otp_read(PLAT_OTP_ID_HW_VERSION, *size, buf);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+    const uint8_t *p_hw_version = example_ean_13;
+    uint32_t hw_version_size = sizeof(example_ean_13) - 1;
 
-    err =  tfm_plat_otp_get_size(PLAT_OTP_ID_HW_VERSION, &otp_size);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
+    if (*size < hw_version_size) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
-    *size = strnlen((char*)buf, otp_size);
+    copy_buf(buf, p_hw_version, hw_version_size);
+    *size = hw_version_size;
 
     return TFM_PLAT_ERR_SUCCESS;
 }
diff --git a/tf-m.old/platform/ext/common/template/crypto_dummy_nv_seed.c b/lib/tf-m/platform/ext/common/template/crypto_dummy_nv_seed.c
new file mode 100644
index 000000000..fd6c2c768
--- /dev/null
+++ b/lib/tf-m/platform/ext/common/template/crypto_dummy_nv_seed.c
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#include "mbedtls/entropy.h"
+#include "tfm_plat_crypto_dummy_nv_seed.h"
+
+/* NOTE: The seed value here is only an example, please do not use it in
+ * production. Platform vendor should implement their own seed value.
+ */
+#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
+const unsigned char seed_value[MBEDTLS_ENTROPY_BLOCK_SIZE] = {
+            0x12, 0x13, 0x23, 0x34, 0x0a, 0x05, 0x89, 0x78,
+            0xa3, 0x66, 0x8c, 0x0d, 0x97, 0x55, 0x53, 0xca,
+            0xb5, 0x76, 0x18, 0x62, 0x29, 0xc6, 0xb6, 0x79,
+            0x75, 0xc8, 0x5a, 0x8d, 0x9e, 0x11, 0x8f, 0x85,
+            0xde, 0xc4, 0x5f, 0x66, 0x21, 0x52, 0xf9, 0x39,
+            0xd9, 0x77, 0x93, 0x28, 0xb0, 0x5e, 0x02, 0xfa,
+            0x58, 0xb4, 0x16, 0xc8, 0x0f, 0x38, 0x91, 0xbb,
+            0x28, 0x17, 0xcd, 0x8a, 0xc9, 0x53, 0x72, 0x66,
+};
+#else
+const unsigned char seed_value[MBEDTLS_ENTROPY_BLOCK_SIZE] = {
+            0x12, 0x13, 0x23, 0x34, 0x0a, 0x05, 0x89, 0x78,
+            0xa3, 0x66, 0x8c, 0x0d, 0x97, 0x55, 0x53, 0xca,
+            0xb5, 0x76, 0x18, 0x62, 0x29, 0xc6, 0xb6, 0x79,
+            0x75, 0xc8, 0x5a, 0x8d, 0x9e, 0x11, 0x8f, 0x85,
+};
+#endif
+
+int tfm_plat_crypto_create_entropy_seed(void)
+{
+    return tfm_plat_crypto_nv_seed_write(seed_value,
+                                         MBEDTLS_ENTROPY_BLOCK_SIZE);
+}
diff --git a/lib/tf-m/platform/ext/common/template/crypto_keys.c b/lib/tf-m/platform/ext/common/template/crypto_keys.c
index b4cf6a770..6e907ce83 100644
--- a/lib/tf-m/platform/ext/common/template/crypto_keys.c
+++ b/lib/tf-m/platform/ext/common/template/crypto_keys.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,8 +19,47 @@
 
 #include "psa/crypto_types.h"
 #include "tfm_plat_crypto_keys.h"
-#include "tfm_plat_otp.h"
-#include "mbedtls/hkdf.h"
+
+/* FIXME: Functions in this file should be implemented by platform vendor. For
+ * the security of the storage system, it is critical to use a hardware unique
+ * key. For the security of the attestation, it is critical to use a unique key
+ * pair and keep the private key is secret.
+ */
+
+#define TFM_KEY_LEN_BYTES  16
+
+static const uint8_t sample_tfm_key[TFM_KEY_LEN_BYTES] =
+             {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, \
+              0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
+
+#ifdef SYMMETRIC_INITIAL_ATTESTATION
+extern const psa_algorithm_t tfm_attest_hmac_sign_alg;
+extern const uint8_t initial_attestation_hmac_sha256_key[];
+extern const size_t initial_attestation_hmac_sha256_key_size;
+extern const char *initial_attestation_kid;
+#else /* SYMMETRIC_INITIAL_ATTESTATION */
+extern const psa_ecc_family_t initial_attestation_curve_type;
+extern const uint8_t  initial_attestation_private_key[];
+extern const uint32_t initial_attestation_private_key_size;
+#endif /* SYMMETRIC_INITIAL_ATTESTATION */
+
+/**
+ * \brief Copy the key to the destination buffer
+ *
+ * \param[out]  p_dst  Pointer to buffer where to store the key
+ * \param[in]   p_src  Pointer to the key
+ * \param[in]   size   Length of the key
+ */
+static inline void copy_key(uint8_t *p_dst, const uint8_t *p_src, size_t size)
+{
+    uint32_t i;
+
+    for (i = size; i > 0; i--) {
+        *p_dst = *p_src;
+        p_src++;
+        p_dst++;
+    }
+}
 
 enum tfm_plat_err_t tfm_plat_get_huk_derived_key(const uint8_t *label,
                                                  size_t label_size,
@@ -29,44 +68,19 @@ enum tfm_plat_err_t tfm_plat_get_huk_derived_key(const uint8_t *label,
                                                  uint8_t *key,
                                                  size_t key_size)
 {
-#ifdef CRYPTO_HW_ACCLERATOR
-    return crypto_hw_accelerator_huk_derive_key(label, label_size, context,
-                                                context_size, key, key_size);
-#else
-    uint8_t huk_buf[32];
-    enum tfm_plat_err_t err;
-    int mbedtls_err;
-
-    if (key == NULL) {
-        return TFM_PLAT_ERR_INVALID_INPUT;
-    }
+    (void)label;
+    (void)label_size;
+    (void)context;
+    (void)context_size;
 
-    if (label == NULL && label_size != 0) {
-        return TFM_PLAT_ERR_INVALID_INPUT;
+    if (key_size > TFM_KEY_LEN_BYTES) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
-    if (context == NULL && context_size != 0) {
-        return TFM_PLAT_ERR_INVALID_INPUT;
-    }
+    /* FIXME: Do key derivation */
+    copy_key(key, sample_tfm_key, key_size);
 
-    err = tfm_plat_otp_read(PLAT_OTP_ID_HUK, sizeof(huk_buf), huk_buf);
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        goto out;
-    }
-
-    mbedtls_err = mbedtls_hkdf(mbedtls_md_info_from_type(MBEDTLS_MD_SHA256),
-                               label, label_size, huk_buf, sizeof(huk_buf),
-                               context, context_size, key, key_size);
-    if (mbedtls_err) {
-        err = TFM_PLAT_ERR_SYSTEM_ERR;
-        goto out;
-    }
-
-out:
-    memset(huk_buf, 0, sizeof(huk_buf));
-
-    return err;
-#endif /* CRYPTO_HW_ACCLERATOR */
+    return TFM_PLAT_ERR_SUCCESS;
 }
 
 #ifdef SYMMETRIC_INITIAL_ATTESTATION
@@ -75,55 +89,40 @@ enum tfm_plat_err_t tfm_plat_get_symmetric_iak(uint8_t *key_buf,
                                                size_t *key_len,
                                                psa_algorithm_t *key_alg)
 {
-    enum tfm_plat_err_t err;
-
-    if (key_buf == NULL || key_len == NULL) {
+    if (!key_buf || !key_len || !key_alg) {
         return TFM_PLAT_ERR_INVALID_INPUT;
     }
 
-    err = tfm_plat_otp_read(PLAT_OTP_ID_IAK, buf_len, key_buf);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
+    if (buf_len < initial_attestation_hmac_sha256_key_size) {
+        return TFM_PLAT_ERR_INVALID_INPUT;
     }
 
-    err = tfm_plat_otp_read(PLAT_OTP_ID_IAK_LEN, sizeof(size_t),
-                            (uint8_t*)key_len);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+    /*
+     * Actual implementation may derive a key with other input, other than
+     * directly providing provisioned symmetric initial attestation key.
+     */
+    copy_key(key_buf, initial_attestation_hmac_sha256_key,
+             initial_attestation_hmac_sha256_key_size);
 
-    err = tfm_plat_otp_read(PLAT_OTP_ID_IAK_TYPE,
-                            sizeof(psa_algorithm_t), (uint8_t*)key_alg);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+    *key_alg = tfm_attest_hmac_sign_alg;
+    *key_len = initial_attestation_hmac_sha256_key_size;
 
     return TFM_PLAT_ERR_SUCCESS;
-
 }
 
 enum tfm_plat_err_t tfm_plat_get_symmetric_iak_id(void *kid_buf,
                                                   size_t buf_len,
                                                   size_t *kid_len)
 {
-    enum tfm_plat_err_t err;
-    size_t otp_size;
+    /* kid is string in this example. '\0' is ignore. */
+    size_t len = strlen(initial_attestation_kid);
 
-    if (kid_buf == NULL || kid_len == NULL) {
+    if (!kid_buf || !kid_len || (buf_len < len)) {
         return TFM_PLAT_ERR_INVALID_INPUT;
     }
 
-    err = tfm_plat_otp_read(PLAT_OTP_ID_IAK_ID, buf_len, kid_buf);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
-
-    err =  tfm_plat_otp_get_size(PLAT_OTP_ID_IAK_ID, &otp_size);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
-
-    *kid_len = strlen(kid_buf) <= otp_size ? strlen(kid_buf) : otp_size;
+    copy_key(kid_buf, (const uint8_t *)initial_attestation_kid, len);
+    *kid_len = len;
 
     return TFM_PLAT_ERR_SUCCESS;
 }
@@ -134,33 +133,24 @@ tfm_plat_get_initial_attest_key(uint8_t          *key_buf,
                                 struct ecc_key_t *ecc_key,
                                 psa_ecc_family_t *curve_type)
 {
+    uint8_t *key_dst;
+    const uint8_t *key_src;
     uint32_t key_size;
-    enum tfm_plat_err_t err;
-
-    if (key_buf == NULL || ecc_key == NULL || curve_type == NULL) {
-        return TFM_PLAT_ERR_INVALID_INPUT;
-    }
+    uint32_t full_key_size = initial_attestation_private_key_size;
 
-    err = tfm_plat_otp_read(PLAT_OTP_ID_IAK, size, key_buf);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
-
-    err =  tfm_plat_otp_read(PLAT_OTP_ID_IAK_LEN, sizeof(key_size),
-                             (uint8_t*)&key_size);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
+    if (size < full_key_size) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
     /* Set the EC curve type which the key belongs to */
-    err = tfm_plat_otp_read(PLAT_OTP_ID_IAK_TYPE,
-                            sizeof(psa_ecc_family_t), curve_type);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+    *curve_type = initial_attestation_curve_type;
 
     /* Copy the private key to the buffer, it MUST be present */
-    ecc_key->priv_key = key_buf;
+    key_dst  = key_buf;
+    key_src  = initial_attestation_private_key;
+    key_size = initial_attestation_private_key_size;
+    copy_key(key_dst, key_src, key_size);
+    ecc_key->priv_key = key_dst;
     ecc_key->priv_key_size = key_size;
 
     ecc_key->pubx_key = NULL;
diff --git a/lib/tf-m/platform/ext/common/template/crypto_nv_seed.c b/lib/tf-m/platform/ext/common/template/crypto_nv_seed.c
index 960dbccad..90e3d0a84 100644
--- a/lib/tf-m/platform/ext/common/template/crypto_nv_seed.c
+++ b/lib/tf-m/platform/ext/common/template/crypto_nv_seed.c
@@ -5,21 +5,14 @@
  *
  */
 
+#include <stddef.h>
 #include "tfm_plat_crypto_nv_seed.h"
-#include "tfm_plat_otp.h"
 #include "psa/internal_trusted_storage.h"
 
 #ifndef TFM_PSA_API
 #include "mbedtls/entropy.h"
 
-/* This implementation stores the seed in ITS. Under library model, calling ITS
- * from the crypto_init function is forbidden and results in a crash. Therefore,
- * if library model is enabled then a dummy seed will be returned every time,
- * avoiding ITS calls, which is not secure. A runtime warning about this will be
- * emitted.
- */
-
-static unsigned char seed_buf[MBEDTLS_ENTROPY_BLOCK_SIZE] = {0};
+static unsigned char seed_buf[MBEDTLS_ENTROPY_BLOCK_SIZE];
 
 /*
  \brief Copy the seed to the destination buffer
@@ -38,34 +31,7 @@ static inline void copy_seed(uint8_t *p_dst, const uint8_t *p_src, size_t size)
         p_dst++;
     }
 }
-#endif /* !TFM_PSA_API */
-
-int tfm_plat_crypto_provision_entropy_seed(void)
-{
-#ifdef TFM_PSA_API
-    enum tfm_plat_err_t plat_err;
-    int err;
-    uint8_t buf[64];
-
-    /* If the seed is already provisioned, then return successfully */
-    err = tfm_plat_crypto_nv_seed_read(buf, sizeof(buf));
-    if (err == TFM_CRYPTO_NV_SEED_SUCCESS) {
-        return err;
-    }
-
-    plat_err = tfm_plat_otp_read(PLAT_OTP_ID_ENTROPY_SEED, sizeof(buf), buf);
-    if(plat_err != TFM_PLAT_ERR_SUCCESS) {
-        return TFM_CRYPTO_NV_SEED_FAILED;
-    }
-
-    err = tfm_plat_crypto_nv_seed_write(buf, sizeof(buf));
-    if (err != TFM_CRYPTO_NV_SEED_SUCCESS) {
-        return err;
-    }
-#endif /* TFM_PSA_API */
-
-    return TFM_CRYPTO_NV_SEED_SUCCESS;
-}
+#endif
 
 int tfm_plat_crypto_nv_seed_read(unsigned char *buf, size_t buf_len)
 {
diff --git a/lib/tf-m/platform/ext/common/template/nv_counters.c b/lib/tf-m/platform/ext/common/template/nv_counters.c
index 88870586a..2764644eb 100644
--- a/lib/tf-m/platform/ext/common/template/nv_counters.c
+++ b/lib/tf-m/platform/ext/common/template/nv_counters.c
@@ -1,14 +1,23 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
  */
 
-/* NOTE: For the security of the protected storage system, the bootloader
- * rollback protection, and the protection of cryptographic material  it is
- * CRITICAL to use a internal (in-die) persistent memory for the implementation
- * of the OTP_NV_COUNTERS flash area (see flash_otp_nv_layout.c).
+/* NOTE: This API should be implemented by platform vendor. For the security of
+ * the protected storage system's and the bootloader's rollback protection etc.
+ * it is CRITICAL to use a internal (in-die) persistent memory for multiple time
+ * programmable (MTP) non-volatile counters or use a One-time Programmable (OTP)
+ * non-volatile counters solution.
+ *
+ * This dummy implementation assumes that the NV counters are the only data in
+ * the flash sector. To use it, one flash sector should be allocated exclusively
+ * for the NV counters.
+ *
+ * The current software dummy implementation is not resistant to asynchronous
+ * power failures and should not be used in production code. It is exclusively
+ * for testing purposes.
  */
 
 #include "tfm_plat_nv_counters.h"
@@ -16,80 +25,100 @@
 #include <limits.h>
 #include "Driver_Flash.h"
 #include "flash_layout.h"
-#include "tfm_plat_otp.h"
-#include "cmsis_compiler.h"
-#include "flash_otp_nv_counters_backend.h"
-
-#include <string.h>
 
-#define OTP_COUNTER_MAX_SIZE    128u
-#define NV_COUNTER_SIZE         4
-
-enum flash_nv_counter_id_t {
-    FLASH_NV_COUNTER_ID_PS_0 = 0,
-    FLASH_NV_COUNTER_ID_PS_1,
-    FLASH_NV_COUNTER_ID_PS_2,
-    FLASH_NV_COUNTER_ID_MAX,
+/* Compilation time checks to be sure the defines are well defined */
+#ifndef TFM_NV_COUNTERS_AREA_ADDR
+#error "TFM_NV_COUNTERS_AREA_ADDR must be defined in flash_layout.h"
+#endif
+
+#ifndef TFM_NV_COUNTERS_AREA_SIZE
+#error "TFM_NV_COUNTERS_AREA_SIZE must be defined in flash_layout.h"
+#endif
+
+#ifndef TFM_NV_COUNTERS_SECTOR_ADDR
+#error "TFM_NV_COUNTERS_SECTOR_ADDR must be defined in flash_layout.h"
+#endif
+
+#ifndef TFM_NV_COUNTERS_SECTOR_SIZE
+#error "TFM_NV_COUNTERS_SECTOR_SIZE must be defined in flash_layout.h"
+#endif
+
+#ifndef NV_COUNTERS_FLASH_DEV_NAME
+    #ifndef FLASH_DEV_NAME
+    #error "NV_COUNTERS_FLASH_DEV_NAME or FLASH_DEV_NAME must be defined in flash_layout.h"
+    #else
+    #define NV_COUNTERS_FLASH_DEV_NAME FLASH_DEV_NAME
+    #endif
+#endif
+/* End of compilation time checks to be sure the defines are well defined */
+
+#define NV_COUNTER_SIZE  sizeof(uint32_t)
+#define INIT_VALUE_SIZE  NV_COUNTER_SIZE
+#define NUM_NV_COUNTERS  ((TFM_NV_COUNTERS_AREA_SIZE - INIT_VALUE_SIZE) \
+                          / NV_COUNTER_SIZE)
+
+#define NV_COUNTERS_INITIALIZED 0xC0DE0042U
+
+/**
+ * \brief Struct representing the NV counter data in flash.
+ */
+struct nv_counters_t {
+    uint32_t counters[NUM_NV_COUNTERS]; /**< Array of NV counters */
+    uint32_t init_value; /**< Watermark to indicate if the NV counters have been
+                          *   initialised
+                          */
 };
 
-enum tfm_plat_err_t tfm_plat_init_nv_counter(void)
-{
-    if (FLASH_NV_COUNTER_ID_MAX > FLASH_NV_COUNTER_AM) {
-        return TFM_PLAT_ERR_SYSTEM_ERR;
-    }
-
-    return init_otp_nv_counters_flash();
-}
+/* Import the CMSIS flash device driver */
+extern ARM_DRIVER_FLASH NV_COUNTERS_FLASH_DEV_NAME;
 
-static enum tfm_plat_err_t read_nv_counter_otp(enum tfm_otp_element_id_t id,
-                                               uint32_t size, uint8_t *val)
+enum tfm_plat_err_t tfm_plat_init_nv_counter(void)
 {
-    size_t counter_size;
-    enum tfm_plat_err_t err;
-    size_t byte_idx;
-    uint8_t bit_idx;
-    uint8_t counter_value[OTP_COUNTER_MAX_SIZE];
-    uint32_t count;
+    int32_t err;
+    uint32_t i;
+    struct nv_counters_t nv_counters = {{0}};
 
-    err = tfm_plat_otp_get_size(id, &counter_size);
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
+    err = NV_COUNTERS_FLASH_DEV_NAME.Initialize(NULL);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
-    counter_size = counter_size > OTP_COUNTER_MAX_SIZE ? OTP_COUNTER_MAX_SIZE : counter_size;
-
-    err = tfm_plat_otp_read(id, counter_size, counter_value);
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
+    /* Read the NV counter area to be able to erase the sector and write later
+     * in the flash.
+     */
+    err = NV_COUNTERS_FLASH_DEV_NAME.ReadData(TFM_NV_COUNTERS_AREA_ADDR,
+                                              &nv_counters,
+                                              TFM_NV_COUNTERS_AREA_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
-    count = 0;
-    for (byte_idx = 0; byte_idx < counter_size; byte_idx++) {
-        for (bit_idx = 0; bit_idx < 8; bit_idx++) {
-            count += (counter_value[byte_idx] >> bit_idx) & 1;
-        }
+    if (nv_counters.init_value == NV_COUNTERS_INITIALIZED) {
+        return TFM_PLAT_ERR_SUCCESS;
     }
 
-    memcpy(val, &count, NV_COUNTER_SIZE);
+    /* Add watermark, at the end of the NV counters area, to indicate that NV
+     * counters have been initialized.
+     */
+    nv_counters.init_value = NV_COUNTERS_INITIALIZED;
 
-    return TFM_PLAT_ERR_SUCCESS;
-}
-
-static enum tfm_plat_err_t read_nv_counter_flash(enum flash_nv_counter_id_t counter_id,
-                                                 uint32_t size, uint8_t *val)
-{
-    enum tfm_plat_err_t err = TFM_PLAT_ERR_SUCCESS;
+    /* Initialize all counters to 0 */
+    for (i = 0; i < NUM_NV_COUNTERS; i++) {
+        nv_counters.counters[i] = 0;
+    }
 
-    if (size != NV_COUNTER_SIZE) {
-        return TFM_PLAT_ERR_INVALID_INPUT;
+    /* Erase sector before write in it */
+    err = NV_COUNTERS_FLASH_DEV_NAME.EraseSector(TFM_NV_COUNTERS_SECTOR_ADDR);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
-    err = read_otp_nv_counters_flash(offsetof(struct flash_otp_nv_counters_region_t,
-                                              flash_nv_counters)
-                                     + counter_id * sizeof(uint32_t),
-                                     val, size);
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
+    /* Write in flash the in-memory NV counter content after modification */
+    err = NV_COUNTERS_FLASH_DEV_NAME.ProgramData(TFM_NV_COUNTERS_AREA_ADDR,
+                                                 &nv_counters,
+                                                 TFM_NV_COUNTERS_AREA_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
     return TFM_PLAT_ERR_SUCCESS;
@@ -98,142 +127,66 @@ static enum tfm_plat_err_t read_nv_counter_flash(enum flash_nv_counter_id_t coun
 enum tfm_plat_err_t tfm_plat_read_nv_counter(enum tfm_nv_counter_t counter_id,
                                              uint32_t size, uint8_t *val)
 {
+    int32_t  err;
+    uint32_t flash_addr;
+
     if (size != NV_COUNTER_SIZE) {
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
-    switch(counter_id) {
-#ifdef TFM_PARTITION_PROTECTED_STORAGE
-    case (PLAT_NV_COUNTER_PS_0):
-        return read_nv_counter_flash(FLASH_NV_COUNTER_ID_PS_0, size, val);
-    case (PLAT_NV_COUNTER_PS_1):
-        return read_nv_counter_flash(FLASH_NV_COUNTER_ID_PS_1, size, val);
-    case (PLAT_NV_COUNTER_PS_2):
-        return read_nv_counter_flash(FLASH_NV_COUNTER_ID_PS_2, size, val);
-#endif /* TFM_PARTITION_PROTECTED_STORAGE */
-
-#ifdef BL2
-    case (PLAT_NV_COUNTER_BL2_0):
-        return read_nv_counter_otp(PLAT_OTP_ID_NV_COUNTER_BL2_0, size, val);
-    case (PLAT_NV_COUNTER_BL2_1):
-        return read_nv_counter_otp(PLAT_OTP_ID_NV_COUNTER_BL2_1, size, val);
-    case (PLAT_NV_COUNTER_BL2_2):
-        return read_nv_counter_otp(PLAT_OTP_ID_NV_COUNTER_BL2_2, size, val);
-#endif /* BL2 */
-
-#ifdef BL1
-    case (PLAT_NV_COUNTER_BL1_0):
-        return read_nv_counter_otp(PLAT_OTP_ID_NV_COUNTER_BL1_0, size, val);
-#endif /* BL1 */
-
-    default:
-        return TFM_PLAT_ERR_UNSUPPORTED;
-    }
-}
-
-static enum tfm_plat_err_t set_nv_counter_otp(enum tfm_otp_element_id_t id,
-                                              uint32_t value)
-{
-    size_t counter_size;
-    enum tfm_plat_err_t err;
-    size_t byte_idx;
-    uint8_t counter_value[OTP_COUNTER_MAX_SIZE];
-
-    err = tfm_plat_otp_get_size(id, &counter_size);
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
-
-    counter_size = counter_size > OTP_COUNTER_MAX_SIZE ? OTP_COUNTER_MAX_SIZE : counter_size;
-
-    if (value > (8 * counter_size)) {
-        return TFM_PLAT_ERR_MAX_VALUE;
-    }
-
-    memset(counter_value, 0, OTP_COUNTER_MAX_SIZE);
-    for (byte_idx = 0; byte_idx < (value / 8); byte_idx++) {
-        counter_value[byte_idx] = UINT8_MAX;
-    }
-    counter_value[byte_idx] = (1 << (value % 8)) - 1;
+    flash_addr = TFM_NV_COUNTERS_AREA_ADDR + (counter_id * NV_COUNTER_SIZE);
 
-    err = tfm_plat_otp_write(id, counter_size, counter_value);
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
+    err = NV_COUNTERS_FLASH_DEV_NAME.ReadData(flash_addr, val, NV_COUNTER_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
     return TFM_PLAT_ERR_SUCCESS;
 }
 
-static enum tfm_plat_err_t set_nv_counter_flash(enum flash_nv_counter_id_t counter_id,
-                                                uint32_t value)
+enum tfm_plat_err_t tfm_plat_set_nv_counter(enum tfm_nv_counter_t counter_id,
+                                            uint32_t value)
 {
-    enum tfm_plat_err_t err = TFM_PLAT_ERR_SUCCESS;
-    uint32_t counter_value;
-
-    err = read_otp_nv_counters_flash(offsetof(struct flash_otp_nv_counters_region_t,
-                                              flash_nv_counters)
-                                     + counter_id * sizeof(uint32_t),
-                                     &counter_value, sizeof(counter_value));
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
+    int32_t err;
+    struct nv_counters_t nv_counters = {{0}};
+
+    /* Read the NV counter area to be able to erase the sector and write later
+     * in the flash.
+     */
+    err = NV_COUNTERS_FLASH_DEV_NAME.ReadData(TFM_NV_COUNTERS_AREA_ADDR,
+                                              &nv_counters,
+                                              TFM_NV_COUNTERS_AREA_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
-    if (value < counter_value) {
-        return TFM_PLAT_ERR_INVALID_INPUT;
-    }
+    if (value != nv_counters.counters[counter_id]) {
 
-    if (counter_value == UINT32_MAX) {
-        return TFM_PLAT_ERR_MAX_VALUE;
-    }
-
-    if (counter_value > value) {
-        return TFM_PLAT_ERR_INVALID_INPUT;
-    }
+        if (value > nv_counters.counters[counter_id]) {
+            nv_counters.counters[counter_id] = value;
+        } else {
+            return TFM_PLAT_ERR_INVALID_INPUT;
+        }
 
-    counter_value = value;
+        /* Erase sector before write in it */
+        err = NV_COUNTERS_FLASH_DEV_NAME.EraseSector(
+                                                TFM_NV_COUNTERS_SECTOR_ADDR);
+        if (err != ARM_DRIVER_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
 
-    err = read_otp_nv_counters_flash(offsetof(struct flash_otp_nv_counters_region_t,
-                                              flash_nv_counters)
-                                     + counter_id * sizeof(uint32_t),
-                                     &counter_value, sizeof(counter_value));
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
+        /* Write in flash the in-memory NV counter content after modification */
+        err = NV_COUNTERS_FLASH_DEV_NAME.ProgramData(TFM_NV_COUNTERS_AREA_ADDR,
+                                                     &nv_counters,
+                                                     TFM_NV_COUNTERS_AREA_SIZE);
+        if (err != ARM_DRIVER_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
     }
 
     return TFM_PLAT_ERR_SUCCESS;
 }
 
-enum tfm_plat_err_t tfm_plat_set_nv_counter(enum tfm_nv_counter_t counter_id,
-                                            uint32_t value)
-{
-    switch(counter_id) {
-#ifdef TFM_PARTITION_PROTECTED_STORAGE
-    case (PLAT_NV_COUNTER_PS_0):
-        return set_nv_counter_flash(FLASH_NV_COUNTER_ID_PS_0, value);
-    case (PLAT_NV_COUNTER_PS_1):
-        return set_nv_counter_flash(FLASH_NV_COUNTER_ID_PS_1, value);
-    case (PLAT_NV_COUNTER_PS_2):
-        return set_nv_counter_flash(FLASH_NV_COUNTER_ID_PS_2, value);
-#endif /* TFM_PARTITION_PROTECTED_STORAGE */
-
-#ifdef BL2
-    case (PLAT_NV_COUNTER_BL2_0):
-        return set_nv_counter_otp(PLAT_OTP_ID_NV_COUNTER_BL2_0, value);
-    case (PLAT_NV_COUNTER_BL2_1):
-        return set_nv_counter_otp(PLAT_OTP_ID_NV_COUNTER_BL2_1, value);
-    case (PLAT_NV_COUNTER_BL2_2):
-        return set_nv_counter_otp(PLAT_OTP_ID_NV_COUNTER_BL2_2, value);
-#endif /* BL2 */
-
-#ifdef BL1
-    case (PLAT_NV_COUNTER_BL1_0):
-        return set_nv_counter_otp(PLAT_OTP_ID_NV_COUNTER_BL1_0, value);
-#endif /* BL1 */
-    default:
-        return TFM_PLAT_ERR_UNSUPPORTED;
-    }
-}
-
 enum tfm_plat_err_t tfm_plat_increment_nv_counter(
                                            enum tfm_nv_counter_t counter_id)
 {
diff --git a/tf-m.old/platform/ext/common/template/tfm_initial_attestation_key_material.c b/lib/tf-m/platform/ext/common/template/tfm_initial_attestation_key_material.c
new file mode 100644
index 000000000..436ec2575
--- /dev/null
+++ b/lib/tf-m/platform/ext/common/template/tfm_initial_attestation_key_material.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#include <stdint.h>
+#include "tfm_plat_defs.h"
+#include "tfm_plat_crypto_keys.h"
+#include "psa/crypto_types.h"
+#include "psa/crypto_values.h"
+
+#ifdef SYMMETRIC_INITIAL_ATTESTATION
+/*
+ * This file contains the hard coded version of the secret key for HMAC.
+ *
+ * A HMAC-SHA256 key is 32 bytes long.
+ *
+ * This key is used to sign the initial attestation token in COSE_Mac0.
+ * The secret key is stored in raw format, without any encoding(ASN.1, COSE).
+ *
+ * #######  DO NOT USE THIS KEY IN PRODUCTION #######
+ */
+
+/* HMAC-SHA256 by default */
+const psa_algorithm_t tfm_attest_hmac_sign_alg = PSA_ALG_HMAC(PSA_ALG_SHA_256);
+
+/* Symmetric initial attestation key in raw format, without any encoding.
+ * It is used in HMAC-SHA256.
+ * It MUST be present on the device.
+ */
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_INITIAL_ATTESTATION", "PSA-ROT")
+const uint8_t initial_attestation_hmac_sha256_key[] =
+{
+    0xA9, 0xB4, 0x54, 0xB2, 0x6D, 0x6F, 0x90, 0xA4,
+    0xEA, 0x31, 0x19, 0x35, 0x64, 0xCB, 0xA9, 0x1F,
+    0xEC, 0x6F, 0x9A, 0x00, 0x2A, 0x7D, 0xC0, 0x50,
+    0x4B, 0x92, 0xA1, 0x93, 0x71, 0x34, 0x58, 0x5F
+};
+
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_INITIAL_ATTESTATION", "PSA-ROT")
+const size_t initial_attestation_hmac_sha256_key_size =
+        sizeof(initial_attestation_hmac_sha256_key);
+
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_INITIAL_ATTESTATION", "PSA-ROT")
+const char *initial_attestation_kid = "kid@trustedfirmware.example";
+#else /* SYMMETRIC_INITIAL_ATTESTATION */
+/*
+ * This file contains the hard coded version of the ECDSA P-256 secret key in:
+ * platform/ext/common/template/tfm_initial_attestation_key.pem
+ *
+ * As a P-256 key, the private key is 32 bytes long.
+ *
+ * This key is used to sign the initial attestation token.
+ * The secret key is stored in raw format, without any encoding(ASN.1, COSE).
+ *
+ * #######  DO NOT USE THIS KEY IN PRODUCTION #######
+ */
+
+/* Type of the EC curve which the key belongs to, in PSA curve ID form */
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_INITIAL_ATTESTATION", "PSA-ROT")
+const psa_ecc_family_t initial_attestation_curve_type = PSA_ECC_FAMILY_SECP_R1;
+
+/* Initial attestation private key in raw format, without any encoding.
+ * It belongs to the ECDSA P-256 curve.
+ * It MUST be present on the device.
+ */
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_INITIAL_ATTESTATION", "PSA-ROT")
+const uint8_t initial_attestation_private_key[] =
+{
+    0xA9, 0xB4, 0x54, 0xB2, 0x6D, 0x6F, 0x90, 0xA4,
+    0xEA, 0x31, 0x19, 0x35, 0x64, 0xCB, 0xA9, 0x1F,
+    0xEC, 0x6F, 0x9A, 0x00, 0x2A, 0x7D, 0xC0, 0x50,
+    0x4B, 0x92, 0xA1, 0x93, 0x71, 0x34, 0x58, 0x5F
+};
+
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_INITIAL_ATTESTATION", "PSA-ROT")
+const uint32_t initial_attestation_private_key_size =
+        sizeof(initial_attestation_private_key);
+#endif /* SYMMETRIC_INITIAL_ATTESTATION */
diff --git a/lib/tf-m/platform/ext/common/template/tfm_rotpk.c b/lib/tf-m/platform/ext/common/template/tfm_rotpk.c
index 25470c679..b222d6949 100644
--- a/lib/tf-m/platform/ext/common/template/tfm_rotpk.c
+++ b/lib/tf-m/platform/ext/common/template/tfm_rotpk.c
@@ -1,35 +1,97 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
  */
 
 #include <stdint.h>
-#include "tfm_plat_otp.h"
-
-#ifdef BL2
+#include "tfm_plat_crypto_keys.h"
+/**
+ * \file tfm_rotpk.c
+ *
+ * This file contains the hash value (SHA256) of the public parts of the
+ * firmware signing keys in bl2/ext/mcuboot folder (*.pem files).
+ * This simulates when the hash of the Root of Trust Public Key is programmed
+ * to an immutable device memory to be able to validate the image verification
+ * key.
+ *
+ * \note These key-hash values must be provisioned to the SoC during the
+ *       production, independently from firmware binaries. This solution
+ *       (hard-coded key-hash values in firmware) is not suited for use in
+ *       production!
+ */
 
-static enum tfm_plat_err_t get_rotpk_hash(enum tfm_otp_element_id_t id,
-                                          uint8_t* rotpk_hash,
-                                          uint32_t* rotpk_hash_size)
-{
-    enum tfm_plat_err_t err;
-    size_t otp_size;
+#if defined(BL2)
+#if (MCUBOOT_SIGN_RSA_LEN == 2048)
+/* Hash of public key: bl2/ext/mcuboot/root-rsa-2048.pem */
+uint8_t rotpk_hash_0[ROTPK_HASH_LEN] = {
+    0xfc, 0x57, 0x01, 0xdc, 0x61, 0x35, 0xe1, 0x32,
+    0x38, 0x47, 0xbd, 0xc4, 0x0f, 0x04, 0xd2, 0xe5,
+    0xbe, 0xe5, 0x83, 0x3b, 0x23, 0xc2, 0x9f, 0x93,
+    0x59, 0x3d, 0x00, 0x01, 0x8c, 0xfa, 0x99, 0x94,
+};
+/* Hash of public key: bl2/ext/mcuboot/root-rsa-2048_1.pem */
+#if (MCUBOOT_IMAGE_NUMBER == 2)
+uint8_t rotpk_hash_1[ROTPK_HASH_LEN] = {
+    0xe1, 0x80, 0x15, 0x99, 0x3d, 0x6d, 0x27, 0x60,
+    0xb4, 0x99, 0x27, 0x4b, 0xae, 0xf2, 0x64, 0xb8,
+    0x3a, 0xf2, 0x29, 0xe9, 0xa7, 0x85, 0xf3, 0xd5,
+    0xbf, 0x00, 0xb9, 0xd3, 0x2c, 0x1f, 0x03, 0x96,
+};
+#endif /* MCUBOOT_IMAGE_NUMBER */
 
-    err = tfm_plat_otp_read(id, *rotpk_hash_size, rotpk_hash);
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+#elif (MCUBOOT_SIGN_RSA_LEN == 3072)
+/* Hash of public key: bl2/ext/mcuboot/root-rsa-3072.pem */
+uint8_t rotpk_hash_0[ROTPK_HASH_LEN] = {
+    0xbf, 0xe6, 0xd8, 0x6f, 0x88, 0x26, 0xf4, 0xff,
+    0x97, 0xfb, 0x96, 0xc4, 0xe6, 0xfb, 0xc4, 0x99,
+    0x3e, 0x46, 0x19, 0xfc, 0x56, 0x5d, 0xa2, 0x6a,
+    0xdf, 0x34, 0xc3, 0x29, 0x48, 0x9a, 0xdc, 0x38,
+};
+/* Hash of public key: bl2/ext/mcuboot/root-rsa-3072_1.pem */
+#if (MCUBOOT_IMAGE_NUMBER == 2)
+uint8_t rotpk_hash_1[ROTPK_HASH_LEN] = {
+    0xb3, 0x60, 0xca, 0xf5, 0xc9, 0x8c, 0x6b, 0x94,
+    0x2a, 0x48, 0x82, 0xfa, 0x9d, 0x48, 0x23, 0xef,
+    0xb1, 0x66, 0xa9, 0xef, 0x6a, 0x6e, 0x4a, 0xa3,
+    0x7c, 0x19, 0x19, 0xed, 0x1f, 0xcc, 0xc0, 0x49,
+};
+#endif /* MCUBOOT_IMAGE_NUMBER */
+#else
+#error "No public key available for given signing algorithm."
+#endif
 
-    err = tfm_plat_otp_get_size(id, &otp_size);
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+const struct tfm_plat_rotpk_t device_rotpk[] = {
+    {
+        .key_hash = rotpk_hash_0,
+        .hash_len = ROTPK_HASH_LEN,
+    },
+#if (MCUBOOT_IMAGE_NUMBER == 2)
+    {
+        .key_hash = rotpk_hash_1,
+        .hash_len = ROTPK_HASH_LEN,
+    },
+#endif
+};
+const uint32_t rotpk_key_cnt = MCUBOOT_IMAGE_NUMBER;
 
-    *rotpk_hash_size = otp_size;
+/**
+ * \brief Copy the key to the destination buffer
+ *
+ * \param[out]  p_dst  Pointer to buffer where to store the key
+ * \param[in]   p_src  Pointer to the key
+ * \param[in]   size   Length of the key
+ */
+static inline void copy_key(uint8_t *p_dst, const uint8_t *p_src, size_t size)
+{
+    uint32_t i;
 
-    return TFM_PLAT_ERR_SUCCESS;
+    for (i = size; i > 0; i--) {
+        *p_dst = *p_src;
+        p_src++;
+        p_dst++;
+    }
 }
 
 enum tfm_plat_err_t
@@ -37,21 +99,18 @@ tfm_plat_get_rotpk_hash(uint8_t image_id,
                         uint8_t *rotpk_hash,
                         uint32_t *rotpk_hash_size)
 {
-    switch(image_id) {
-        case 0:
-            return get_rotpk_hash(PLAT_OTP_ID_BL2_ROTPK_0, rotpk_hash,
-                                  rotpk_hash_size);
-        case 1:
-            return get_rotpk_hash(PLAT_OTP_ID_BL2_ROTPK_1, rotpk_hash,
-                                  rotpk_hash_size);
-        case 2:
-            return get_rotpk_hash(PLAT_OTP_ID_BL2_ROTPK_2, rotpk_hash,
-                                  rotpk_hash_size);
-        default:
-            return TFM_PLAT_ERR_INVALID_INPUT;
+    if(*rotpk_hash_size < ROTPK_HASH_LEN) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
-    return TFM_PLAT_ERR_SYSTEM_ERR;
+    if (image_id >= rotpk_key_cnt) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    *rotpk_hash_size = ROTPK_HASH_LEN;
+    copy_key(rotpk_hash, device_rotpk[image_id].key_hash, *rotpk_hash_size);
+
+    return TFM_PLAT_ERR_SUCCESS;
 }
 
 #endif /* BL2 */
diff --git a/lib/tf-m/platform/ext/index.rst b/lib/tf-m/platform/ext/index.rst
index 2e0633c94..36e3af98f 100644
--- a/lib/tf-m/platform/ext/index.rst
+++ b/lib/tf-m/platform/ext/index.rst
@@ -9,7 +9,6 @@ Supported Platforms
     readme
     /platform/ext/platform_introduction.rst
     /platform/ext/platform_deprecation.rst
-    /platform/ext/platform_provisioning.rst
 
 .. toctree::
     :maxdepth: 1
@@ -17,6 +16,7 @@ Supported Platforms
     :glob:
 
     target/arm/**
+    otp_provisioning.rst
 
 .. toctree::
     :maxdepth: 1
diff --git a/tf-m.old/platform/ext/otp_provisioning.rst b/lib/tf-m/platform/ext/otp_provisioning.rst
new file mode 100644
index 000000000..c29e1a806
--- /dev/null
+++ b/lib/tf-m/platform/ext/otp_provisioning.rst
@@ -0,0 +1,88 @@
+############################
+Musca-B1/S1 OTP Provisioning
+############################
+
+This document assumes that the user has set up the build environment, is
+capable of compiling the TF-M project, and is in possession of at least one
+Musca-S1 board, or a Musca-B1 board that has not been provisioned before.
+
+.. Note::
+    During provisioning, the 'MCUBOOT_IMAGE_NUMBER' configuration's value
+    determines which Root of Trust public key's hash will be stored. Whichever
+    one is stored, it can only be checked against successfully in the matching
+    way later. This means that a board provisioned with a build in which
+    'MCUBOOT_IMAGE_NUMBER=1' can only be used with 'MCUBOOT_IMAGE_NUMBER=1',
+    as long as the OTP is enabled. Same goes with 'MCUBOOT_IMAGE_NUMBER=2'.
+
+*********************************
+Provisioning on Musca HW variants
+*********************************
+Even though most of the process is identical between the boards, there is
+a difference between them because of the underlying hardware.
+While the B1 has actual OTP memory, the S1 only has volatile registers in its
+place. Because a power cyclce wipes that area, the S1 merely imitates OTP
+memory by copying provisioned data to its non-volatile MRAM.
+
+Once the provisioning process is done, the CryptoCell-312 enters the Secure
+Enabled lifecycle, which it recognizes by the contents of the OTP.
+Debug and board reprogramming through USB is locked down in this state.
+This lock can be forced open, but only with DAPLink firmware v34 or above.
+
+Because the S1 "OTP" content is stored in the MRAM, it can be provisioned only
+once with the normal provisioning flow. However, a workaround to re-provision
+the board does exist. To achieve this, one needs to wipe the key area in the
+MRAM with the debugger in advance. The address and size of said area can be
+found at 'platform/ext/target/musca_s1/partition/flash_layout.h' as
+'TF-M key area'.
+
+For further information on the DAPLink firmware and update process, please
+refer to the `Musca-B1 Technical Reference Manual
+<https://developer.arm.com/docs/101312/0000>`__ or the `Musca-S1 Technical
+Reference Manual <https://developer.arm.com/docs/101835/0000>`__.
+
+Provisioning steps
+==================
+1. Build TF-M with -DCRYPTO_HW_ACCELERATOR_OTP_STATE=PROVISIONING given on
+the CMake command line.
+
+2. Load the tfm.hex file to the board and open the serial output.
+Once you see something like the following snippet:
+
+.. code-block:: bash
+
+    ...
+    First cycle: Attestation key is provisioned successfully
+    First cycle: HUK is provisioned successfully
+    Please reset the board to program ROTPK
+    ...
+
+3. Reset the board once by pressing the nSRST button and wait until you see
+something like this:
+
+::
+
+    ...
+    Second cycle: ROTPK is provisioned successfully
+    Provisioning finished, reset the board to get secure enabled lifecycle
+    ...
+
+4. Reset the board once more.
+If the provisioning process was succesful, you should see an output like:
+
+::
+
+    ...
+    Board is in invalid lifecycle for provisioning: 5
+    ...
+
+Using the provisioned data
+==========================
+1. Build TF-M with -DCRYPTO_HW_ACCELERATOR_OTP_STATE=ENABLED given
+on the CMake command line.
+
+2. Load the tfm.hex file to
+the board.
+
+--------------
+
+*Copyright (c) 2020, Arm Limited. All rights reserved.*
\ No newline at end of file
diff --git a/lib/tf-m/platform/ext/readme.rst b/lib/tf-m/platform/ext/readme.rst
index 3868e2bac..55f13cfb6 100644
--- a/lib/tf-m/platform/ext/readme.rst
+++ b/lib/tf-m/platform/ext/readme.rst
@@ -33,10 +33,27 @@ specified.
 
 - ``CRYPTO_HW_ACCELERATOR``
    - ``ON`` All possible mbedtls cryptographic operations will be offloaded to
-     the accelerator.
+     the accelerator. This mode is required for
+     ``CRYPTO_HW_ACCELERATOR_OTP_STATE`` to have an effect.
    - ``OFF`` The cryptographic accelerator will be ignored and software
      cryptography will be used.
 
+- ``CRYPTO_HW_ACCELERATOR_OTP_STATE``
+   - ``DISABLED`` The HW accelerator will not use any data from its onboard OTP
+     (One Time Programmable) memory.
+   - ``PROVISIONING`` This special mode is used to program cryptographic
+     material into the OTP memory. When the flag is set TF-M will not boot, but
+     will instead program the hardware unique key, the root of trust private key
+     and the attestation private key into the OTP memory.
+   - ``ENABLED`` The HW accelerator will use the previously programmed data as
+     the hardware unique key, the root of trust private key and the attestation
+     private key.
+
+.. Warning::
+
+   Provisioning **can not** be reversed, and data in the OTP memory **can not**
+   be changed once set.
+
 cmsis
 =====
 This folder contains core and compiler specific header files imported from the
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/armclang/startup_cmsdk_mps2_an519_s.s b/lib/tf-m/platform/ext/target/arm/mps2/an519/armclang/startup_cmsdk_mps2_an519_s.s
index fcc94d685..2bcbb6702 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/armclang/startup_cmsdk_mps2_an519_s.s
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/armclang/startup_cmsdk_mps2_an519_s.s
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2016-2021 ARM Limited
+; * Copyright (c) 2016-2018 ARM Limited
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -25,6 +25,7 @@
 ;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
 ; </h>
 
+                IMPORT |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|
                 IMPORT |Image$$ARM_LIB_STACK$$ZI$$Limit|
 
 ; Vector Table Mapped to Address 0 at Reset
@@ -36,7 +37,7 @@
 
                 PRESERVE8
 
-__Vectors       DCD     |Image$$ARM_LIB_STACK$$ZI$$Limit|  ; Top of Stack
+__Vectors       DCD     |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|  ; Top of Stack
                 DCD     Reset_Handler             ; Reset Handler
                 DCD     NMI_Handler               ; NMI Handler
                 DCD     HardFault_Handler         ; Hard Fault Handler
@@ -167,6 +168,14 @@ Reset_Handler   PROC
                 CPSID   i              ; Disable IRQs
                 LDR     R0, =SystemInit
                 BLX     R0
+                MRS     R0, control    ; Get control value
+                MOVS    R1, #2
+                ORRS    R0, R0, R1     ; Select switch to PSP
+                MSR     control, R0
+                LDR     R0, =|Image$$ARM_LIB_STACK$$ZI$$Limit|
+                MOVS    R1, #7
+                BICS    R0, R1         ; Make sure that the SP address is aligned to 8
+                MOV     SP, R0         ; Initialise PSP
                 LDR     R0, =__main
                 BX      R0
                 ENDP
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/gcc/startup_cmsdk_mps2_an519_s.S b/lib/tf-m/platform/ext/target/arm/mps2/an519/gcc/startup_cmsdk_mps2_an519_s.S
index e151ab6fe..aca6a49af 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/gcc/startup_cmsdk_mps2_an519_s.S
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/gcc/startup_cmsdk_mps2_an519_s.S
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2009-2021 ARM Limited
+; * Copyright (c) 2009-2020 ARM Limited
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -26,7 +26,7 @@
     .align 2
     .globl    __Vectors
 __Vectors:
-    .long    Image$$ARM_LIB_STACK$$ZI$$Limit/* Top of Stack */
+    .long    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit   /* Top of Stack */
 
     /* Core interrupts */
     .long    Reset_Handler                  /* Reset Handler */
@@ -310,6 +310,13 @@ Reset_Handler:
     cpsid   i              /* Disable IRQs */
     bl    SystemInit
 
+    mrs     r0, control    /* Get control value */
+    movs    r1, #2
+    orrs    r0, r0, r1     /* Select switch to PSP */
+    msr     control, r0
+    ldr     r0, =Image$$ARM_LIB_STACK$$ZI$$Limit
+    msr     psp, r0
+
 #ifndef __START
 #define __START _start
 #endif
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/iar/startup_cmsdk_mps2_an519_ns.s b/lib/tf-m/platform/ext/target/arm/mps2/an519/iar/startup_cmsdk_mps2_an519_ns.s
index d8cf50f45..62b98c6d4 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/iar/startup_cmsdk_mps2_an519_ns.s
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/iar/startup_cmsdk_mps2_an519_ns.s
@@ -1,6 +1,5 @@
 ;/*
 ; * Copyright (c) 2016-2020 ARM Limited
-; * Copyright (c) 2020-2021 IAR Systems AB
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -167,6 +166,8 @@ __Vectors_Size  EQU     __Vectors_End - __Vectors
 
 Reset_Handler
                 MRS     R0, control    ; Get control value
+                MOVS    R1, #1
+                ORRS    R0, R0, R1     ; Select switch to unprivileged mode
                 MOVS    R1, #2
                 ORRS    R0, R0, R1     ; Select switch to PSP
                 MSR     control, R0
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/iar/startup_cmsdk_mps2_an519_s.s b/lib/tf-m/platform/ext/target/arm/mps2/an519/iar/startup_cmsdk_mps2_an519_s.s
index 149c8a384..d1043e92c 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/iar/startup_cmsdk_mps2_an519_s.s
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/iar/startup_cmsdk_mps2_an519_s.s
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2016-2021 ARM Limited
+; * Copyright (c) 2016-2020 ARM Limited
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -28,6 +28,7 @@
                 MODULE   ?cstartup
 
                 ;; Forward declaration of sections.
+                SECTION  ARM_LIB_STACK_MSP:DATA:NOROOT(3)
                 SECTION  ARM_LIB_STACK:DATA:NOROOT(3)
 
                 SECTION  .intvec:CODE:NOROOT(2)
@@ -42,7 +43,7 @@
                 DATA
 
 __vector_table      ;Core Interrupts
-                DCD     sfe(ARM_LIB_STACK)        ; Top of Stack
+                DCD     sfe(ARM_LIB_STACK_MSP)    ; Top of Stack
                 DCD     Reset_Handler             ; Reset Handler
                 DCD     NMI_Handler               ; NMI Handler
                 DCD     HardFault_Handler         ; Hard Fault Handler
@@ -170,6 +171,14 @@ Reset_Handler
                 CPSID   i              ; Disable IRQs
                 LDR     R0, =SystemInit
                 BLX     R0
+                MRS     R0, control    ; Get control value
+                MOVS    R1, #2
+                ORRS    R0, R0, R1     ; Select switch to PSP
+                MSR     control, R0
+                LDR     R0, =sfe(ARM_LIB_STACK)      ; End of PROC_STACK
+                MOVS    R1, #7
+                BICS    R0, R1         ; Make sure that the SP address is aligned to 8
+                MOV     SP, R0         ; Initialise PSP
                 LDR     R0, =__iar_program_start
                 BX      R0
 
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/native_drivers/mpu_armv8m_drv.h b/lib/tf-m/platform/ext/target/arm/mps2/an519/native_drivers/mpu_armv8m_drv.h
index 920be3f56..70590bcd2 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/native_drivers/mpu_armv8m_drv.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/native_drivers/mpu_armv8m_drv.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2019, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -89,7 +89,7 @@ enum mpu_armv8m_error_t mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -100,7 +100,7 @@ enum mpu_armv8m_error_t mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev);
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -112,7 +112,7 @@ enum mpu_armv8m_error_t mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev);
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_cfg     MPU region config \ref mpu_armv8m_region_cfg_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -126,7 +126,7 @@ enum mpu_armv8m_error_t mpu_armv8m_region_enable(
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_nr            Region number
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/partition/flash_layout.h b/lib/tf-m/platform/ext/target/arm/mps2/an519/partition/flash_layout.h
index 19cf88c42..6c3208d8f 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/partition/flash_layout.h
@@ -28,8 +28,8 @@
  * 0x0028_0000 Scratch area (0.5 MB)
  * 0x0030_0000 Protected Storage Area (20 KB)
  * 0x0030_5000 Internal Trusted Storage Area (16 KB)
- * 0x0030_9000 OTP / NV counters area (8 KB)
- * 0x0030_B000 Unused (984 KB)
+ * 0x0030_9000 NV counters area (4 KB)
+ * 0x0030_A000 Unused (984 KB)
  *
  * Flash layout on MPS2 AN519 with BL2 (single image boot):
  *
@@ -43,8 +43,8 @@
  * 0x0028_0000 Scratch area (1 MB)
  * 0x0038_0000 Protected Storage Area (20 KB)
  * 0x0038_5000 Internal Trusted Storage Area (16 KB)
- * 0x0030_9000 OTP / NV counters area (8 KB)
- * 0x0030_B000 Unused (984 KB)
+ * 0x0038_9000 NV counters area (4 KB)
+ * 0x0038_A000 Unused (472 KB)
  *
  * Flash layout on MPS2 AN519, if BL2 not defined:
  *
@@ -149,11 +149,10 @@
                                          FLASH_PS_AREA_SIZE)
 #define FLASH_ITS_AREA_SIZE             (0x4000)   /* 16 KB */
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* Offset and size definition in flash area used by assemble.py */
 #define SECURE_IMAGE_OFFSET             (0x0)
@@ -167,8 +166,6 @@
  * Name is defined in flash driver file: Driver_Flash.c
  */
 #define FLASH_DEV_NAME Driver_FLASH0
-/* Smallest flash programmable unit in bytes */
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x1)
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -210,12 +207,11 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x1)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18) /* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
 
 /* Use SRAM1 memory to store Code data */
 #define S_ROM_ALIAS_BASE  (0x10000000)
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/partition/region_defs.h b/lib/tf-m/platform/ext/target/arm/mps2/an519/partition/region_defs.h
index 9a3f1874f..417aa23e1 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/partition/region_defs.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/partition/region_defs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -79,19 +79,8 @@
 #define BL2_TRAILER_SIZE     (0x10400)
 #endif /* BL2 */
 
-#if (MCUBOOT_IMAGE_NUMBER == 1) && \
-    (NS_IMAGE_PRIMARY_PARTITION_OFFSET > S_IMAGE_PRIMARY_PARTITION_OFFSET)
-/* If secure image and nonsecure image are concatenated, and nonsecure image
- * locates at the higher memory range, then the secure image does not need
- * the trailer area.
- */
-#define IMAGE_S_CODE_SIZE \
-            (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE)
-#else
 #define IMAGE_S_CODE_SIZE \
             (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
-#endif
-
 #define IMAGE_NS_CODE_SIZE \
             (FLASH_NS_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
 
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/plat_test.c b/lib/tf-m/platform/ext/target/arm/mps2/an519/plat_test.c
index 2ce291f90..89a0c54f4 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/plat_test.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/plat_test.c
@@ -13,6 +13,47 @@
 #include "smm_mps2.h"
 
 #define TIMER_RELOAD_VALUE (16*1024*1024)
+#define USERLED_MASK       (0x3)
+#define MPS2_USERPB0_BASE  (0x50302008)
+#define MPS2_USERPB0_MASK  (0x1)
+
+void tfm_plat_test_wait_user_button_pressed(void)
+{
+    volatile uint32_t *p_btn = (volatile uint32_t *) MPS2_USERPB0_BASE;
+
+    /* Wait until user button 0 is pressed */
+    while (!(*p_btn & MPS2_USERPB0_MASK)) {
+      ;
+    }
+}
+
+void tfm_plat_test_wait_user_button_released(void)
+{
+    volatile uint32_t *p_btn = (volatile uint32_t *) MPS2_USERPB0_BASE;
+
+    /* Wait until user button 0 is released */
+    while ((*p_btn & MPS2_USERPB0_MASK)) {
+      ;
+    }
+}
+
+uint32_t tfm_plat_test_get_led_status(void)
+{
+    struct arm_mps2_fpgaio_t *fpgaio = SEC_MPS2_FPGAIO;
+    return  fpgaio->LED;
+}
+
+void tfm_plat_test_set_led_status(uint32_t status)
+{
+    struct arm_mps2_fpgaio_t *fpgaio = SEC_MPS2_FPGAIO;
+    fpgaio->LED = status;
+}
+
+uint32_t tfm_plat_test_get_userled_mask(void)
+{
+    return USERLED_MASK;
+}
+
 
 void tfm_plat_test_secure_timer_start(void)
 {
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/retarget/platform_retarget_dev.c b/lib/tf-m/platform/ext/target/arm/mps2/an519/retarget/platform_retarget_dev.c
index b732b9516..44cd13542 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/retarget/platform_retarget_dev.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/retarget/platform_retarget_dev.c
@@ -302,24 +302,24 @@ struct ppc_sse200_dev_t APB_PPCEXP3_DEV_S = {
 /* CMSDK Timer driver structures */
 #ifdef CMSDK_TIMER0_S
 static const struct cmsdk_timer_dev_cfg_t CMSDK_TIMER0_DEV_CFG_S
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
-#elif defined(TEST_NS_FLIH_IRQ)
+#elif defined(TFM_ENABLE_FLIH_TEST)
     TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
     = {.base = CMSDK_TIMER0_BASE_S};
 static struct cmsdk_timer_dev_data_t CMSDK_TIMER0_DEV_DATA_S
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
-#elif defined(TEST_NS_FLIH_IRQ)
+#elif defined(TFM_ENABLE_FLIH_TEST)
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
     = {.is_initialized = 0};
 
 struct cmsdk_timer_dev_t CMSDK_TIMER0_DEV_S
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
-#elif defined(TEST_NS_FLIH_IRQ)
+#elif defined(TFM_ENABLE_FLIH_TEST)
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
        = {&(CMSDK_TIMER0_DEV_CFG_S), &(CMSDK_TIMER0_DEV_DATA_S)};
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/spm_hal.c b/lib/tf-m/platform/ext/target/arm/mps2/an519/spm_hal.c
index 690c3153c..9e2e044f4 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/spm_hal.c
@@ -5,11 +5,14 @@
  *
  */
 
+#include <stdio.h>
 #include "cmsis.h"
 #include "tfm_spm_hal.h"
 #include "tfm_platform_core_api.h"
 #include "target_cfg.h"
 #include "Driver_MPC.h"
+#include "mpu_armv8m_drv.h"
+#include "region_defs.h"
 #include "utilities.h"
 
 /* Import MPC driver */
@@ -18,6 +21,66 @@ extern ARM_DRIVER_MPC Driver_SRAM1_MPC;
 /* Get address of memory regions to configure MPU */
 extern const struct memory_region_limits memory_regions;
 
+#ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
+struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
+
+#define PARTITION_REGION_PERIPH_START   5
+#define PARTITION_REGION_PERIPH_MAX_NUM 2
+
+uint32_t periph_num_count = 0;
+#endif /* CONFIG_TFM_ENABLE_MEMORY_PROTECT */
+
+enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
+                  bool privileged,
+                  const struct platform_data_t *platform_data)
+{
+#if defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1)
+    struct mpu_armv8m_region_cfg_t region_cfg;
+#endif
+
+    if (!platform_data) {
+        return TFM_PLAT_ERR_INVALID_INPUT;
+    }
+
+#if defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1)
+    if (!privileged) {
+        region_cfg.region_nr = PARTITION_REGION_PERIPH_START + periph_num_count;
+        periph_num_count++;
+        if (periph_num_count >= PARTITION_REGION_PERIPH_MAX_NUM) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+        region_cfg.region_base = platform_data->periph_start;
+        region_cfg.region_limit = platform_data->periph_limit;
+        region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
+        region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
+        region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
+        region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
+
+        mpu_armv8m_disable(&dev_mpu_s);
+
+        if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg)
+            != MPU_ARMV8M_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+        mpu_armv8m_enable(&dev_mpu_s, PRIVILEGED_DEFAULT_ENABLE,
+                          HARDFAULT_NMI_ENABLE);
+    }
+#endif /* defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1) */
+
+    if (platform_data->periph_ppc_bank != PPC_SP_DO_NOT_CONFIGURE) {
+        ppc_configure_to_secure(platform_data->periph_ppc_bank,
+                                platform_data->periph_ppc_loc);
+        if (privileged) {
+            ppc_clr_secure_unpriv(platform_data->periph_ppc_bank,
+                                  platform_data->periph_ppc_loc);
+        } else {
+            ppc_en_secure_unpriv(platform_data->periph_ppc_bank,
+                                 platform_data->periph_ppc_loc);
+        }
+    }
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
 void MPC_Handler(void)
 {
     /* Clear MPC interrupt flag and pending MPC IRQ */
@@ -129,29 +192,3 @@ enum tfm_plat_err_t tfm_spm_hal_nvic_interrupt_enable(void)
 {
     return nvic_interrupt_enable();
 }
-
-#ifndef TFM_PSA_API
-
-enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
-                  bool privileged,
-                  const struct platform_data_t *platform_data)
-{
-    if (!platform_data) {
-        return TFM_PLAT_ERR_INVALID_INPUT;
-    }
-
-    if (platform_data->periph_ppc_bank != PPC_SP_DO_NOT_CONFIGURE) {
-        ppc_configure_to_secure(platform_data->periph_ppc_bank,
-                                platform_data->periph_ppc_loc);
-        if (privileged) {
-            ppc_clr_secure_unpriv(platform_data->periph_ppc_bank,
-                                  platform_data->periph_ppc_loc);
-        } else {
-            ppc_en_secure_unpriv(platform_data->periph_ppc_bank,
-                                 platform_data->periph_ppc_loc);
-        }
-    }
-    return TFM_PLAT_ERR_SUCCESS;
-}
-
-#endif /* TFM_PSA_API */
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/target_cfg.c b/lib/tf-m/platform/ext/target/arm/mps2/an519/target_cfg.c
index 7df902e1c..9127926bf 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/target_cfg.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/target_cfg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021 Arm Limited
+ * Copyright (c) 2018-2020 Arm Limited
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -105,6 +105,13 @@ struct platform_data_t tfm_peripheral_uart1 = {
         CMSDK_UART1_APB_PPC_POS
 };
 
+struct platform_data_t tfm_peripheral_fpga_io = {
+        MPS2_IO_FPGAIO_BASE_S,
+        MPS2_IO_FPGAIO_BASE_S + 0xFFF,
+        PPC_SP_APB_PPC_EXP2,
+        CMSDK_FPGA_IO_PPC_POS
+};
+
 struct platform_data_t tfm_peripheral_timer0 = {
         CMSDK_TIMER0_BASE_S,
         CMSDK_TIMER1_BASE_S - 1,
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/tfm_hal_isolation.c b/lib/tf-m/platform/ext/target/arm/mps2/an519/tfm_hal_isolation.c
index 41b4d9c93..a396e51ab 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/tfm_hal_isolation.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/tfm_hal_isolation.c
@@ -1,30 +1,29 @@
 /*
- * Copyright (c) 2020-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
  */
 
-#include "array.h"
 #include "cmsis.h"
 #include "Driver_Common.h"
-#include "mmio_defs.h"
 #include "mpu_armv8m_drv.h"
 #include "region.h"
 #include "target_cfg.h"
 #include "tfm_hal_isolation.h"
-#include "tfm_peripherals_def.h"
-#include "tfm_core_utils.h"
-#include "load/partition_defs.h"
-#include "load/asset_defs.h"
-#include "load/spm_load_api.h"
-
-/* It can be retrieved from the MPU_TYPE register. */
-#define MPU_REGION_NUM                  8
 
 #ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
-static uint32_t n_configured_regions = 0;
-struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
+#define ARRAY_SIZE(arr) (sizeof(arr)/sizeof(arr[0]))
+
+#define MPU_REGION_VENEERS           0
+#define MPU_REGION_TFM_UNPRIV_CODE   1
+#define MPU_REGION_NS_STACK          2
+#define PARTITION_REGION_RO          3
+#define PARTITION_REGION_RW_STACK    4
+#define PARTITION_REGION_PERIPH      5
+#ifdef TFM_SP_META_PTR_ENABLE
+#define MPU_REGION_SP_META_PTR       7
+#endif /* TFM_SP_META_PTR_ENABLE */
 
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Base);
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Limit);
@@ -34,8 +33,8 @@ REGION_DECLARE(Image$$, TFM_APP_CODE_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_CODE_END, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_END, $$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Base);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
 #ifdef TFM_SP_META_PTR_ENABLE
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Base);
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
@@ -44,7 +43,7 @@ REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
 const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     /* Veneer region */
     {
-        0, /* will be updated before using */
+        MPU_REGION_VENEERS,
         (uint32_t)&REGION_NAME(Load$$LR$$, LR_VENEER, $$Base),
         (uint32_t)&REGION_NAME(Load$$LR$$, LR_VENEER, $$Limit),
         MPU_ARMV8M_MAIR_ATTR_CODE_IDX,
@@ -54,7 +53,7 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     },
     /* TFM Core unprivileged code region */
     {
-        0, /* will be updated before using */
+        MPU_REGION_TFM_UNPRIV_CODE,
         (uint32_t)&REGION_NAME(Image$$, TFM_UNPRIV_CODE, $$RO$$Base),
         (uint32_t)&REGION_NAME(Image$$, TFM_UNPRIV_CODE, $$RO$$Limit),
         MPU_ARMV8M_MAIR_ATTR_CODE_IDX,
@@ -64,9 +63,9 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     },
     /* NSPM PSP */
     {
-        0, /* will be updated before using */
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Base),
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Limit),
+        MPU_REGION_NS_STACK,
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base),
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit),
         MPU_ARMV8M_MAIR_ATTR_DATA_IDX,
         MPU_ARMV8M_XN_EXEC_NEVER,
         MPU_ARMV8M_AP_RW_PRIV_UNPRIV,
@@ -74,7 +73,7 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     },
     /* RO region */
     {
-        0, /* will be updated before using */
+        PARTITION_REGION_RO,
         (uint32_t)&REGION_NAME(Image$$, TFM_APP_CODE_START, $$Base),
         (uint32_t)&REGION_NAME(Image$$, TFM_APP_CODE_END, $$Base),
         MPU_ARMV8M_MAIR_ATTR_CODE_IDX,
@@ -84,7 +83,7 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     },
     /* RW, ZI and stack as one region */
     {
-        0, /* will be updated before using */
+        PARTITION_REGION_RW_STACK,
         (uint32_t)&REGION_NAME(Image$$, TFM_APP_RW_STACK_START, $$Base),
         (uint32_t)&REGION_NAME(Image$$, TFM_APP_RW_STACK_END, $$Base),
         MPU_ARMV8M_MAIR_ATTR_DATA_IDX,
@@ -95,7 +94,7 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
 #ifdef TFM_SP_META_PTR_ENABLE
     /* TFM partition metadata pointer region */
     {
-        0, /* will be updated before using */
+        MPU_REGION_SP_META_PTR,
         (uint32_t)&REGION_NAME(Image$$, TFM_SP_META_PTR, $$RW$$Base),
         (uint32_t)&REGION_NAME(Image$$, TFM_SP_META_PTR, $$RW$$Limit),
         MPU_ARMV8M_MAIR_ATTR_DATA_IDX,
@@ -109,9 +108,6 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
 
 enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
 {
-#ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
-    struct mpu_armv8m_region_cfg_t localcfg;
-#endif
     /* Set up isolation boundaries between SPE and NSPE */
     sau_and_idau_cfg();
     if (mpc_init_cfg() != ARM_DRIVER_OK) {
@@ -121,23 +117,18 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
 
     /* Set up static isolation boundaries inside SPE */
 #ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
+    struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
     int32_t i;
 
     mpu_armv8m_clean(&dev_mpu_s);
 
-    if (ARRAY_SIZE(region_cfg) > MPU_REGION_NUM) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
     for (i = 0; i < ARRAY_SIZE(region_cfg); i++) {
-        spm_memcpy(&localcfg, &region_cfg[i], sizeof(localcfg));
-        localcfg.region_nr = i;
         if (mpu_armv8m_region_enable(&dev_mpu_s,
-            (struct mpu_armv8m_region_cfg_t *)&localcfg)
+            (struct mpu_armv8m_region_cfg_t *)&region_cfg[i])
             != MPU_ARMV8M_OK) {
             return TFM_HAL_ERROR_GENERIC;
         }
     }
-    n_configured_regions = i;
 
     mpu_armv8m_enable(&dev_mpu_s, PRIVILEGED_DEFAULT_ENABLE,
                       HARDFAULT_NMI_ENABLE);
@@ -145,111 +136,3 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
 
     return TFM_HAL_SUCCESS;
 }
-
-/*
- * Implementation of tfm_hal_bind_boundaries() on AN519:
- *
- * The API encodes some attributes into a handle and returns it to SPM.
- * The attributes include isolation boundaries, privilege, and MMIO information.
- * When scheduler switches running partitions, SPM compares the handle between
- * partitions to know if boundary update is necessary. If update is required,
- * SPM passes the handle to platform to do platform settings and update
- * isolation boundaries.
- */
-enum tfm_hal_status_t tfm_hal_bind_boundaries(
-                                    const struct partition_load_info_t *p_ldinf,
-                                    void **pp_boundaries)
-{
-    uint32_t i, j;
-    bool privileged;
-    const struct asset_desc_t *p_asset;
-    struct platform_data_t *plat_data_ptr;
-#if TFM_LVL == 2
-    struct mpu_armv8m_region_cfg_t localcfg;
-#endif
-    if (!p_ldinf || !pp_boundaries) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-
-#if TFM_LVL == 1
-    privileged = true;
-#else
-    privileged = !!(p_ldinf->flags & SPM_PART_FLAG_PSA_ROT);
-#endif
-
-    p_asset = (const struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
-
-    /*
-     * Validate if the named MMIO of partition is allowed by the platform.
-     * Otherwise, skip validation.
-     *
-     * NOTE: Need to add validation of numbered MMIO if platform requires.
-     */
-    for (i = 0; i < p_ldinf->nassets; i++) {
-        if (!(p_asset[i].attr & ASSET_ATTR_NAMED_MMIO)) {
-            continue;
-        }
-        for (j = 0; j < ARRAY_SIZE(partition_named_mmio_list); j++) {
-            if (p_asset[i].dev.dev_ref == partition_named_mmio_list[j]) {
-                break;
-            }
-        }
-
-        if (j == ARRAY_SIZE(partition_named_mmio_list)) {
-            /* The MMIO asset is not in the allowed list of platform. */
-            return TFM_HAL_ERROR_GENERIC;
-        }
-        /* Assume PPC & MPC settings are required even under level 1 */
-        plat_data_ptr = REFERENCE_TO_PTR(p_asset[i].dev.dev_ref,
-                                         struct platform_data_t *);
-
-        ppc_configure_to_secure(plat_data_ptr->periph_ppc_bank,
-                                plat_data_ptr->periph_ppc_loc);
-        if (privileged) {
-            ppc_clr_secure_unpriv(plat_data_ptr->periph_ppc_bank,
-                                  plat_data_ptr->periph_ppc_loc);
-        } else {
-            ppc_en_secure_unpriv(plat_data_ptr->periph_ppc_bank,
-                                 plat_data_ptr->periph_ppc_loc);
-        }
-#if TFM_LVL == 2
-        /*
-         * Static boundaries are set. Set up MPU region for MMIO.
-         * Setup regions for unprivileged assets only.
-         */
-        if (!privileged) {
-            localcfg.region_base = plat_data_ptr->periph_start;
-            localcfg.region_limit = plat_data_ptr->periph_limit;
-            localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
-            localcfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
-            localcfg.attr_sh = MPU_ARMV8M_SH_NONE;
-            localcfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
-            localcfg.region_nr = n_configured_regions++;
-
-            if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg)
-                != MPU_ARMV8M_OK) {
-                return TFM_HAL_ERROR_GENERIC;
-            }
-        }
-#endif
-    }
-
-    *pp_boundaries = (void *)(((uint32_t)privileged) & HANDLE_ATTR_PRIV_MASK);
-
-    return TFM_HAL_SUCCESS;
-}
-
-enum tfm_hal_status_t tfm_hal_update_boundaries(
-                             const struct partition_load_info_t *p_ldinf,
-                             void *p_boundaries)
-{
-    CONTROL_Type ctrl;
-    bool privileged = !!((uint32_t)p_boundaries & HANDLE_ATTR_PRIV_MASK);
-
-    /* Privileged level is required to be set always */
-    ctrl.w = __get_CONTROL();
-    ctrl.b.nPRIV = privileged ? 0 : 1;
-    __set_CONTROL(ctrl.w);
-
-    return TFM_HAL_SUCCESS;
-}
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/arm/mps2/an519/tfm_peripherals_def.h
index a0e1998d8..4ddf169ea 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/tfm_peripherals_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2019, Arm Limited. All rights reserved.
  * Copyright (c) 2020, Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -15,12 +15,6 @@
 extern "C" {
 #endif
 
-/*
- * Quantized default IRQ priority, the value is:
- * (Number of configurable priority) / 4: (1UL << __NVIC_PRIO_BITS) / 4
- */
-#define DEFAULT_IRQ_PRIORITY    (1UL << (__NVIC_PRIO_BITS - 2))
-
 #define TFM_TIMER0_IRQ    (TIMER0_IRQn)
 #define TFM_TIMER1_IRQ    (TIMER1_IRQn)
 
@@ -28,10 +22,12 @@ struct platform_data_t;
 
 extern struct platform_data_t tfm_peripheral_std_uart;
 extern struct platform_data_t tfm_peripheral_uart1;
+extern struct platform_data_t tfm_peripheral_fpga_io;
 extern struct platform_data_t tfm_peripheral_timer0;
 
 #define TFM_PERIPHERAL_STD_UART  (&tfm_peripheral_std_uart)
 #define TFM_PERIPHERAL_UART1     (&tfm_peripheral_uart1)
+#define TFM_PERIPHERAL_FPGA_IO   (&tfm_peripheral_fpga_io)
 #define TFM_PERIPHERAL_TIMER0    (&tfm_peripheral_timer0)
 
 #ifdef __cplusplus
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/armclang/startup_cmsdk_mps2_an521_s.s b/lib/tf-m/platform/ext/target/arm/mps2/an521/armclang/startup_cmsdk_mps2_an521_s.s
index 5db755f21..23f2cc88d 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/armclang/startup_cmsdk_mps2_an521_s.s
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/armclang/startup_cmsdk_mps2_an521_s.s
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2016-2021 ARM Limited
+; * Copyright (c) 2016-2018 ARM Limited
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -25,7 +25,7 @@
 ;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
 ; </h>
 
-                IMPORT |Image$$ARM_LIB_STACK$$ZI$$Limit|
+                IMPORT |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|
 
 ; Vector Table Mapped to Address 0 at Reset
 
@@ -34,7 +34,7 @@
                 EXPORT  __Vectors_End
                 EXPORT  __Vectors_Size
 
-__Vectors       DCD     |Image$$ARM_LIB_STACK$$ZI$$Limit|  ; Top of Stack
+__Vectors       DCD     |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|  ; Top of Stack
                 DCD     Reset_Handler             ; Reset Handler
                 DCD     NMI_Handler               ; NMI Handler
                 DCD     HardFault_Handler         ; Hard Fault Handler
@@ -165,6 +165,9 @@ Reset_Handler   PROC
                 CPSID   i              ; Disable IRQs
                 LDR     R0, =SystemInit
                 BLX     R0
+                MRS     R0, control    ; Get control value
+                ORR     R0, R0, #2     ; Select switch to PSP
+                MSR     control, R0
                 LDR     R0, =__main
                 BX      R0
                 ENDP
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/gcc/startup_cmsdk_mps2_an521_s.S b/lib/tf-m/platform/ext/target/arm/mps2/an521/gcc/startup_cmsdk_mps2_an521_s.S
index 5f2e23af5..b2063174d 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/gcc/startup_cmsdk_mps2_an521_s.S
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/gcc/startup_cmsdk_mps2_an521_s.S
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2009-2021 ARM Limited
+; * Copyright (c) 2009-2020 ARM Limited
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -26,7 +26,7 @@
     .align 2
     .globl    __Vectors
 __Vectors:
-    .long    Image$$ARM_LIB_STACK$$ZI$$Limit   /* Top of Stack */
+    .long    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit   /* Top of Stack */
 
     /* Core interrupts */
     .long    Reset_Handler                  /* Reset Handler */
@@ -272,6 +272,12 @@ Reset_Handler:
     cpsid   i              /* Disable IRQs */
     bl    SystemInit
 
+    mrs     r0, control    /* Get control value */
+    orr     r0, r0, #2     /* Select switch to PSP */
+    msr     control, r0
+    ldr     r0, =Image$$ARM_LIB_STACK$$ZI$$Limit
+    msr     psp, r0
+
 #ifndef __START
 #define __START _start
 #endif
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/iar/startup_cmsdk_mps2_an521_ns.s b/lib/tf-m/platform/ext/target/arm/mps2/an521/iar/startup_cmsdk_mps2_an521_ns.s
index 00e978c4e..403a90e3c 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/iar/startup_cmsdk_mps2_an521_ns.s
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/iar/startup_cmsdk_mps2_an521_ns.s
@@ -1,6 +1,5 @@
 ;/*
 ; * Copyright (c) 2016-2020 ARM Limited
-; * Copyright (c) 2020-2021 IAR Systems AB
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -169,6 +168,7 @@ Reset_Handler
                 LDR      R0, =sfe(ARM_LIB_STACK)       ; End of ARM_LIB_STACK
                 MSR      PSP, R0
                 MRS      R0, CONTROL    ; Get control value
+                ORR      R0, R0, #1     ; Select switch to non privileged mode
                 ORR      R0, R0, #2     ; Select switch to PSP
                 MSR      CONTROL, R0
                 LDR      R0, =__iar_program_start
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/iar/startup_cmsdk_mps2_an521_s.s b/lib/tf-m/platform/ext/target/arm/mps2/an521/iar/startup_cmsdk_mps2_an521_s.s
index 52f8fe95c..713f22ce7 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/iar/startup_cmsdk_mps2_an521_s.s
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/iar/startup_cmsdk_mps2_an521_s.s
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2016-2021 ARM Limited
+; * Copyright (c) 2016-2020 ARM Limited
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -28,6 +28,7 @@
                 MODULE   ?cstartup
 
                 ;; Forward declaration of sections.
+                SECTION  ARM_LIB_STACK_MSP:DATA:NOROOT(3)
                 SECTION  ARM_LIB_STACK:DATA:NOROOT(3)
 
                 SECTION  .intvec:CODE:NOROOT(2)
@@ -42,7 +43,7 @@
                 DATA
 
 __vector_table      ;Core Interrupts
-                DCD     sfe(ARM_LIB_STACK)        ; Top of Stack
+                DCD     sfe(ARM_LIB_STACK_MSP)    ; Top of Stack
                 DCD     Reset_Handler             ; Reset Handler
                 DCD     NMI_Handler               ; NMI Handler
                 DCD     HardFault_Handler         ; Hard Fault Handler
@@ -170,6 +171,11 @@ Reset_Handler
                 CPSID   i              ; Disable IRQs
                 LDR     R0, =SystemInit
                 BLX     R0
+                LDR     R0, =sfe(ARM_LIB_STACK)      ; End of PROC_STACK
+                MSR     PSP, R0
+                MRS     R0, control    ; Get control value
+                ORR     R0, R0, #2     ; Select switch to PSP
+                MSR     control, R0
                 LDR     R0, =__iar_program_start
                 BX      R0
 
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/native_drivers/mpu_armv8m_drv.c b/lib/tf-m/platform/ext/target/arm/mps2/an521/native_drivers/mpu_armv8m_drv.c
index 960ee09a8..823181123 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/native_drivers/mpu_armv8m_drv.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/native_drivers/mpu_armv8m_drv.c
@@ -7,15 +7,16 @@
 
 #include "mpu_armv8m_drv.h"
 #include "cmsis_cpu.h"
+#include "fih.h"
 
 /*
  * FixMe:
  * This is a beta quality driver for MPU in v8M. To be finalized.
  */
 
-enum mpu_armv8m_error_t mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
-                                          uint32_t privdef_en,
-                                          uint32_t hfnmi_en)
+fih_int mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
+                          uint32_t privdef_en,
+                          uint32_t hfnmi_en)
 {
     /*No error checking*/
 
@@ -45,22 +46,22 @@ enum mpu_armv8m_error_t mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
     __DSB();
     __ISB();
 
-    return MPU_ARMV8M_OK;
+    FIH_RET(fih_int_encode(MPU_ARMV8M_OK));
 }
 
-enum mpu_armv8m_error_t mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev)
+fih_int mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev)
 {
     MPU_Type *mpu = (MPU_Type *)dev->base;
 
     /* Reset all fields as enable does full setup */
     mpu->CTRL = 0;
 
-    return MPU_ARMV8M_OK;
+    FIH_RET(fih_int_encode(MPU_ARMV8M_OK));
 }
 
-enum mpu_armv8m_error_t mpu_armv8m_region_enable(
-                                struct mpu_armv8m_dev_t *dev,
-                                struct mpu_armv8m_region_cfg_t *region_cfg)
+
+fih_int mpu_armv8m_region_enable(struct mpu_armv8m_dev_t *dev,
+                                 struct mpu_armv8m_region_cfg_t *region_cfg)
 {
     MPU_Type *mpu = (MPU_Type *)dev->base;
 
@@ -70,7 +71,7 @@ enum mpu_armv8m_error_t mpu_armv8m_region_enable(
 
     /*FIXME : Add complete error checking*/
     if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0) {
-        return MPU_ARMV8M_ERROR;
+        FIH_RET(fih_int_encode(MPU_ARMV8M_ERROR));
     }
     /* region_limit doesn't need to be aligned but the scatter
      * file needs to be setup to ensure that partitions do not overlap.
@@ -106,11 +107,12 @@ enum mpu_armv8m_error_t mpu_armv8m_region_enable(
     __DSB();
     __ISB();
 
-    return MPU_ARMV8M_OK;
+    FIH_RET(fih_int_encode(MPU_ARMV8M_OK));
 }
 
-enum mpu_armv8m_error_t mpu_armv8m_region_disable(struct mpu_armv8m_dev_t *dev,
-                                                  uint32_t region_nr)
+
+fih_int mpu_armv8m_region_disable(struct mpu_armv8m_dev_t *dev,
+                                  uint32_t region_nr)
 {
 
     MPU_Type *mpu = (MPU_Type *)dev->base;
@@ -129,18 +131,25 @@ enum mpu_armv8m_error_t mpu_armv8m_region_disable(struct mpu_armv8m_dev_t *dev,
     /*Restore main MPU control*/
     mpu->CTRL = ctrl_before;
 
-    return MPU_ARMV8M_OK;
+    FIH_RET(fih_int_encode(MPU_ARMV8M_OK));
 }
 
-enum mpu_armv8m_error_t mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev)
+fih_int mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev)
 {
     MPU_Type *mpu = (MPU_Type *)dev->base;
     uint32_t i = (mpu->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos;
+    fih_int fih_rc = fih_int_encode(MPU_ARMV8M_ERROR);
 
     while (i > 0) {
-        mpu_armv8m_region_disable(dev, i - 1);
+        FIH_CALL(mpu_armv8m_region_disable, fih_rc, dev, i - 1);
         i--;
     }
 
-    return MPU_ARMV8M_OK;
+#ifdef TFM_FIH_PROFILE_ON
+    if (i > 0) {
+        FIH_PANIC;
+    }
+#endif
+
+    FIH_RET(fih_int_encode(MPU_ARMV8M_OK));
 }
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/native_drivers/mpu_armv8m_drv.h b/lib/tf-m/platform/ext/target/arm/mps2/an521/native_drivers/mpu_armv8m_drv.h
index 9dccafefb..78da63930 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/native_drivers/mpu_armv8m_drv.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/native_drivers/mpu_armv8m_drv.h
@@ -11,6 +11,7 @@
 #include <stdint.h>
 
 #include "cmsis.h"
+#include "fih.h"
 
 #define PRIVILEGED_DEFAULT_ENABLE 1
 #define HARDFAULT_NMI_ENABLE      1
@@ -80,31 +81,31 @@ struct mpu_armv8m_region_cfg_raw_t {
  * \note This function doesn't check if dev is NULL.
  */
 
-enum mpu_armv8m_error_t mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
-                                          uint32_t privdef_en,
-                                          uint32_t hfnmi_en);
+fih_int mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
+                          uint32_t privdef_en,
+                          uint32_t hfnmi_en);
 
 /**
  * \brief Disable MPU
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
-enum mpu_armv8m_error_t mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev);
+fih_int mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev);
 
 /**
  * \brief Disable MPU and clean all regions
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
-enum mpu_armv8m_error_t mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev);
+fih_int mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev);
 
 /**
  * \brief Enable MPU Region
@@ -112,13 +113,12 @@ enum mpu_armv8m_error_t mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev);
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_cfg     MPU region config \ref mpu_armv8m_region_cfg_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
-enum mpu_armv8m_error_t mpu_armv8m_region_enable(
-                                struct mpu_armv8m_dev_t *dev,
-                                struct mpu_armv8m_region_cfg_t *region_cfg);
+fih_int mpu_armv8m_region_enable(struct mpu_armv8m_dev_t *dev,
+                                 struct mpu_armv8m_region_cfg_t *region_cfg);
 
 /**
  * \brief Disable MPU Region
@@ -126,11 +126,11 @@ enum mpu_armv8m_error_t mpu_armv8m_region_enable(
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_nr            Region number
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
-enum mpu_armv8m_error_t mpu_armv8m_region_disable(struct mpu_armv8m_dev_t *dev,
-                                                  uint32_t region_nr);
+fih_int mpu_armv8m_region_disable(struct mpu_armv8m_dev_t *dev,
+                                  uint32_t region_nr);
 
 #endif /* __MPU_ARMV8M_DRV_H__ */
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/partition/flash_layout.h b/lib/tf-m/platform/ext/target/arm/mps2/an521/partition/flash_layout.h
index cdfb8aa29..6a0e442e6 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/partition/flash_layout.h
@@ -28,8 +28,8 @@
  * 0x0028_0000 Scratch area (0.5 MB)
  * 0x0030_0000 Protected Storage Area (20 KB)
  * 0x0030_5000 Internal Trusted Storage Area (16 KB)
- * 0x0030_9000 OTP / NV counters area (8 KB)
- * 0x0030_B000 Unused (984 KB)
+ * 0x0030_9000 NV counters area (4 KB)
+ * 0x0030_A000 Unused (984 KB)
  *
  * Flash layout on MPS2 AN521 with BL2 (single image boot):
  *
@@ -43,8 +43,8 @@
  * 0x0028_0000 Scratch area (1 MB)
  * 0x0038_0000 Protected Storage Area (20 KB)
  * 0x0038_5000 Internal Trusted Storage Area (16 KB)
- * 0x0038_9000 OTP / NV counters area (8 KB)
- * 0x0038_B000 Unused (984 KB)
+ * 0x0038_9000 NV counters area (4 KB)
+ * 0x0038_A000 Unused (472 KB)
  *
  * Flash layout on MPS2 AN521, if BL2 not defined:
  *
@@ -149,11 +149,10 @@
                                          FLASH_PS_AREA_SIZE)
 #define FLASH_ITS_AREA_SIZE             (0x4000)   /* 16 KB */
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* Offset and size definition in flash area used by assemble.py */
 #define SECURE_IMAGE_OFFSET             (0x0)
@@ -167,8 +166,6 @@
  * Name is defined in flash driver file: Driver_Flash.c
  */
 #define FLASH_DEV_NAME Driver_FLASH0
-/* Smallest flash programmable unit in bytes */
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x1)
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -210,12 +207,11 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x1)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18) /* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
 
 /* Use SRAM1 memory to store Code data */
 #define S_ROM_ALIAS_BASE  (0x10000000)
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/partition/region_defs.h b/lib/tf-m/platform/ext/target/arm/mps2/an521/partition/region_defs.h
index 0a1f84935..bef2b5120 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/partition/region_defs.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/partition/region_defs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -79,19 +79,8 @@
 #define BL2_TRAILER_SIZE     (0x10400)
 #endif /* BL2 */
 
-#if (MCUBOOT_IMAGE_NUMBER == 1) && \
-    (NS_IMAGE_PRIMARY_PARTITION_OFFSET > S_IMAGE_PRIMARY_PARTITION_OFFSET)
-/* If secure image and nonsecure image are concatenated, and nonsecure image
- * locates at the higher memory range, then the secure image does not need
- * the trailer area.
- */
-#define IMAGE_S_CODE_SIZE \
-            (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE)
-#else
 #define IMAGE_S_CODE_SIZE \
             (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
-#endif
-
 #define IMAGE_NS_CODE_SIZE \
             (FLASH_NS_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
 
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/plat_test.c b/lib/tf-m/platform/ext/target/arm/mps2/an521/plat_test.c
index 9f48001e7..ba336218d 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/plat_test.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/plat_test.c
@@ -13,6 +13,46 @@
 #include "smm_mps2.h"
 
 #define TIMER_RELOAD_VALUE (16*1024*1024)
+#define USERLED_MASK       (0x3)
+#define MPS2_USERPB0_BASE  (0x50302008)
+#define MPS2_USERPB0_MASK  (0x1)
+
+void tfm_plat_test_wait_user_button_pressed(void)
+{
+    volatile uint32_t *p_btn = (volatile uint32_t *) MPS2_USERPB0_BASE;
+
+    /* Wait until user button 0 is pressed */
+    while (!(*p_btn & MPS2_USERPB0_MASK)) {
+      ;
+    }
+}
+
+void tfm_plat_test_wait_user_button_released(void)
+{
+    volatile uint32_t *p_btn = (volatile uint32_t *) MPS2_USERPB0_BASE;
+
+    /* Wait until user button 0 is released */
+    while ((*p_btn & MPS2_USERPB0_MASK)) {
+      ;
+    }
+}
+
+uint32_t tfm_plat_test_get_led_status(void)
+{
+    struct arm_mps2_fpgaio_t *fpgaio = SEC_MPS2_FPGAIO;
+    return  fpgaio->LED;
+}
+
+void tfm_plat_test_set_led_status(uint32_t status)
+{
+    struct arm_mps2_fpgaio_t *fpgaio = SEC_MPS2_FPGAIO;
+    fpgaio->LED = status;
+}
+
+uint32_t tfm_plat_test_get_userled_mask(void)
+{
+    return USERLED_MASK;
+}
 
 void tfm_plat_test_secure_timer_start(void)
 {
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/retarget/platform_retarget_dev.c b/lib/tf-m/platform/ext/target/arm/mps2/an521/retarget/platform_retarget_dev.c
index bcbfd1830..fa071dba0 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/retarget/platform_retarget_dev.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/retarget/platform_retarget_dev.c
@@ -302,24 +302,24 @@ struct ppc_sse200_dev_t APB_PPCEXP3_DEV_S = {
 /* CMSDK Timer driver structures */
 #ifdef CMSDK_TIMER0_S
 static const struct cmsdk_timer_dev_cfg_t CMSDK_TIMER0_DEV_CFG_S
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
-#elif defined(TEST_NS_FLIH_IRQ)
+#elif defined(TFM_ENABLE_FLIH_TEST)
     TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
     = {.base = CMSDK_TIMER0_BASE_S};
 static struct cmsdk_timer_dev_data_t CMSDK_TIMER0_DEV_DATA_S
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
-#elif defined(TEST_NS_FLIH_IRQ)
+#elif defined(TFM_ENABLE_FLIH_TEST)
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
     = {.is_initialized = 0};
 
 struct cmsdk_timer_dev_t CMSDK_TIMER0_DEV_S
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
-#elif defined(TEST_NS_FLIH_IRQ)
+#elif defined(TFM_ENABLE_FLIH_TEST)
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
        = {&(CMSDK_TIMER0_DEV_CFG_S), &(CMSDK_TIMER0_DEV_DATA_S)};
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/spm_hal.c b/lib/tf-m/platform/ext/target/arm/mps2/an521/spm_hal.c
index 045129b34..33e20b5a8 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/spm_hal.c
@@ -5,11 +5,15 @@
  *
  */
 
+#include <stdio.h>
 #include "cmsis.h"
+#include "fih.h"
 #include "tfm_spm_hal.h"
 #include "tfm_platform_core_api.h"
 #include "target_cfg.h"
 #include "Driver_MPC.h"
+#include "mpu_armv8m_drv.h"
+#include "region_defs.h"
 #include "utilities.h"
 
 /* Import MPC driver */
@@ -18,6 +22,105 @@ extern ARM_DRIVER_MPC Driver_SRAM1_MPC;
 /* Get address of memory regions to configure MPU */
 extern const struct memory_region_limits memory_regions;
 
+struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
+
+#ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
+#define PARTITION_REGION_PERIPH_START   5
+#define PARTITION_REGION_PERIPH_MAX_NUM 2
+
+uint32_t periph_num_count = 0;
+#endif /* CONFIG_TFM_ENABLE_MEMORY_PROTECT */
+
+#ifdef TFM_FIH_PROFILE_ON
+fih_int tfm_spm_hal_configure_default_isolation(
+                  bool privileged,
+                  const struct platform_data_t *platform_data)
+#else /* TFM_FIH_PROFILE_ON */
+enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
+                  bool privileged,
+                  const struct platform_data_t *platform_data)
+#endif /* TFM_FIH_PROFILE_ON */
+{
+    fih_int fih_rc = FIH_FAILURE;
+#if defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1)
+    struct mpu_armv8m_region_cfg_t region_cfg;
+#endif
+
+    if (!platform_data) {
+        FIH_RET(fih_int_encode(TFM_PLAT_ERR_INVALID_INPUT));
+    }
+
+#if defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1)
+    if (!privileged) {
+        region_cfg.region_nr = PARTITION_REGION_PERIPH_START + periph_num_count;
+        periph_num_count++;
+        if (periph_num_count >= PARTITION_REGION_PERIPH_MAX_NUM) {
+            FIH_RET(fih_int_encode(TFM_PLAT_ERR_MAX_VALUE));
+        }
+        region_cfg.region_base = platform_data->periph_start;
+        region_cfg.region_limit = platform_data->periph_limit;
+        region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
+        region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
+        region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
+        region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
+
+#ifdef TFM_FIH_PROFILE_ON
+        FIH_CALL(mpu_armv8m_disable, fih_rc, &dev_mpu_s);
+
+        FIH_CALL(mpu_armv8m_region_enable, fih_rc, &dev_mpu_s, &region_cfg);
+        if (fih_not_eq(fih_rc, fih_int_encode(MPU_ARMV8M_OK))) {
+            FIH_RET(fih_int_encode(TFM_PLAT_ERR_SYSTEM_ERR));
+        }
+
+        FIH_CALL(mpu_armv8m_enable, fih_rc, &dev_mpu_s,
+                 PRIVILEGED_DEFAULT_ENABLE, HARDFAULT_NMI_ENABLE);
+        if (fih_not_eq(fih_rc, fih_int_encode(MPU_ARMV8M_OK))) {
+            FIH_RET(fih_int_encode(TFM_PLAT_ERR_SYSTEM_ERR));
+        }
+#else /* TFM_FIH_PROFILE_ON */
+        mpu_armv8m_disable(&dev_mpu_s);
+
+        if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg)
+            != MPU_ARMV8M_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+        mpu_armv8m_enable(&dev_mpu_s, PRIVILEGED_DEFAULT_ENABLE,
+                          HARDFAULT_NMI_ENABLE);
+#endif /* TFM_FIH_PROFILE_ON */
+    }
+#endif /* defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1) */
+
+    if (platform_data->periph_ppc_bank != PPC_SP_DO_NOT_CONFIGURE) {
+#ifdef TFM_FIH_PROFILE_ON
+        FIH_CALL(ppc_configure_to_secure, fih_rc,
+                 platform_data->periph_ppc_bank,
+                 platform_data->periph_ppc_loc);
+        if (privileged) {
+            FIH_CALL(ppc_clr_secure_unpriv, fih_rc,
+                     platform_data->periph_ppc_bank,
+                     platform_data->periph_ppc_loc);
+        } else {
+            FIH_CALL(ppc_en_secure_unpriv, fih_rc,
+                     platform_data->periph_ppc_bank,
+                     platform_data->periph_ppc_loc);
+        }
+#else /* TFM_FIH_PROFILE_ON */
+        ppc_configure_to_secure(platform_data->periph_ppc_bank,
+                                platform_data->periph_ppc_loc);
+        if (privileged) {
+            ppc_clr_secure_unpriv(platform_data->periph_ppc_bank,
+                                  platform_data->periph_ppc_loc);
+        } else {
+            ppc_en_secure_unpriv(platform_data->periph_ppc_bank,
+                                 platform_data->periph_ppc_loc);
+        }
+#endif /* TFM_FIH_PROFILE_ON */
+    }
+
+    fih_rc = fih_int_encode(TFM_PLAT_ERR_SUCCESS);
+    FIH_RET(fih_rc);
+}
+
 void MPC_Handler(void)
 {
     /* Clear MPC interrupt flag and pending MPC IRQ */
@@ -115,10 +218,21 @@ enum tfm_plat_err_t tfm_spm_hal_system_reset_cfg(void)
     return system_reset_cfg();
 }
 
+#ifdef TFM_FIH_PROFILE_ON
+fih_int tfm_spm_hal_init_debug(void)
+{
+    fih_int fih_rc = FIH_FAILURE;
+
+    FIH_CALL(init_debug, fih_rc);
+
+    FIH_RET(fih_rc);
+}
+#else /* TFM_FIH_PROFILE_ON */
 enum tfm_plat_err_t tfm_spm_hal_init_debug(void)
 {
     return init_debug();
 }
+#endif /* TFM_FIH_PROFILE_ON */
 
 enum tfm_plat_err_t tfm_spm_hal_nvic_interrupt_target_state_cfg(void)
 {
@@ -130,69 +244,16 @@ enum tfm_plat_err_t tfm_spm_hal_nvic_interrupt_enable(void)
     return nvic_interrupt_enable();
 }
 
-#ifndef TFM_PSA_API
-
-#include "mpu_armv8m_drv.h"
-#include "region_defs.h"
-
-struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
-
-#ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
-#define PARTITION_REGION_PERIPH_START   5
-#define PARTITION_REGION_PERIPH_MAX_NUM 2
-
-uint32_t periph_num_count = 0;
-#endif /* CONFIG_TFM_ENABLE_MEMORY_PROTECT */
-
-enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
-                  bool privileged,
-                  const struct platform_data_t *platform_data)
+#ifdef TFM_FIH_PROFILE_ON
+fih_int tfm_spm_hal_verify_isolation_hw(void)
 {
-#if defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1)
-    struct mpu_armv8m_region_cfg_t region_cfg;
-#endif
+    fih_int fih_rc = FIH_INT_INIT(TFM_PLAT_ERR_SYSTEM_ERR);
 
-    if (!platform_data) {
-        return TFM_PLAT_ERR_INVALID_INPUT;
+    FIH_CALL(verify_isolation_hw, fih_rc);
+    if (fih_not_eq(fih_rc, FIH_SUCCESS)) {
+        FIH_PANIC;
     }
 
-#if defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1)
-    if (!privileged) {
-        region_cfg.region_nr = PARTITION_REGION_PERIPH_START + periph_num_count;
-        periph_num_count++;
-        if (periph_num_count >= PARTITION_REGION_PERIPH_MAX_NUM) {
-            return TFM_PLAT_ERR_MAX_VALUE;
-        }
-        region_cfg.region_base = platform_data->periph_start;
-        region_cfg.region_limit = platform_data->periph_limit;
-        region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
-        region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
-        region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
-        region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
-
-        mpu_armv8m_disable(&dev_mpu_s);
-
-        if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg)
-            != MPU_ARMV8M_OK) {
-            return TFM_PLAT_ERR_SYSTEM_ERR;
-        }
-        mpu_armv8m_enable(&dev_mpu_s, PRIVILEGED_DEFAULT_ENABLE,
-                          HARDFAULT_NMI_ENABLE);
-    }
-#endif /* defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1) */
-
-    if (platform_data->periph_ppc_bank != PPC_SP_DO_NOT_CONFIGURE) {
-        ppc_configure_to_secure(platform_data->periph_ppc_bank,
-                                platform_data->periph_ppc_loc);
-        if (privileged) {
-            ppc_clr_secure_unpriv(platform_data->periph_ppc_bank,
-                                  platform_data->periph_ppc_loc);
-        } else {
-            ppc_en_secure_unpriv(platform_data->periph_ppc_bank,
-                                 platform_data->periph_ppc_loc);
-        }
-    }
-
-    return TFM_PLAT_ERR_SUCCESS;
+    FIH_RET(fih_int_encode(TFM_PLAT_ERR_SUCCESS));
 }
-#endif
+#endif /* TFM_FIH_PROFILE_ON */
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/target_cfg.c b/lib/tf-m/platform/ext/target/arm/mps2/an521/target_cfg.c
index c5432ca06..a57a2e80c 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/target_cfg.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/target_cfg.c
@@ -21,6 +21,10 @@
 #include "region_defs.h"
 #include "tfm_plat_defs.h"
 #include "region.h"
+#include "fih.h"
+#ifdef TFM_FIH_PROFILE_ON
+#include "mpc_sie200_drv.h"
+#endif
 
 #ifdef PSA_API_TEST_IPC
 #define PSA_FF_TEST_SECURE_UART2
@@ -106,6 +110,13 @@ struct platform_data_t tfm_peripheral_uart1 = {
         CMSDK_UART1_APB_PPC_POS
 };
 
+struct platform_data_t tfm_peripheral_fpga_io = {
+        MPS2_IO_FPGAIO_BASE_S,
+        MPS2_IO_FPGAIO_BASE_S + 0xFFF,
+        PPC_SP_APB_PPC_EXP2,
+        CMSDK_FPGA_IO_PPC_POS
+};
+
 struct platform_data_t tfm_peripheral_timer0 = {
         CMSDK_TIMER0_BASE_S,
         CMSDK_TIMER1_BASE_S - 1,
@@ -202,7 +213,7 @@ enum tfm_plat_err_t system_reset_cfg(void)
     return TFM_PLAT_ERR_SUCCESS;
 }
 
-enum tfm_plat_err_t init_debug(void)
+fih_int init_debug(void)
 {
     volatile struct sysctrl_t *sys_ctrl =
                                        (struct sysctrl_t *)CMSDK_SYSCTRL_BASE_S;
@@ -239,7 +250,7 @@ enum tfm_plat_err_t init_debug(void)
      */
 #endif
 
-    return TFM_PLAT_ERR_SUCCESS;
+    FIH_RET(fih_int_encode(TFM_PLAT_ERR_SUCCESS));
 }
 
 /*----------------- NVIC interrupt target state to NS configuration ----------*/
@@ -367,14 +378,22 @@ const struct sau_cfg_t sau_cfg[] = {
 
 #define NR_SAU_INIT_STEP                 3
 
-void sau_and_idau_cfg(void)
+fih_int sau_and_idau_cfg(void)
 {
     struct spctrl_def *spctrl = CMSDK_SPCTRL;
     uint32_t i;
 
+    FIH_CFI_STEP_INIT(NR_SAU_INIT_STEP);
+
     /* Enables SAU */
+#ifdef TFM_FIH_PROFILE_ON
+    TZ_SAU_Enable();
+    TZ_SAU_Enable();
+#endif
     TZ_SAU_Enable();
 
+    FIH_CFI_STEP_DECREMENT();
+
     for (i = 0; i < ARRAY_SIZE(sau_cfg); i++) {
         SAU->RNR = i;
         SAU->RBAR = sau_cfg[i].RBAR & SAU_RBAR_BADDR_Msk;
@@ -383,8 +402,20 @@ void sau_and_idau_cfg(void)
                     SAU_RLAR_ENABLE_Msk;
     }
 
+    FIH_CFI_STEP_DECREMENT();
+
     /* Allows SAU to define the code region as a NSC */
     spctrl->nsccfg |= NSCCFG_CODENSC;
+
+    FIH_CFI_STEP_DECREMENT();
+
+    FIH_RET(fih_int_encode(TFM_PLAT_ERR_SUCCESS));
+
+    /*
+     * Dummy operation to avoid unused variable warning of the saved FIH counter
+     * variable.
+     */
+    FIH_CFI_STEP_ERR_RESET();
 }
 
 /*------------------- Memory configuration functions -------------------------*/
@@ -394,21 +425,30 @@ void sau_and_idau_cfg(void)
 #define NR_MPC_INIT_STEP                 6
 #endif
 
-int32_t mpc_init_cfg(void)
+fih_int mpc_init_cfg(void)
 {
-    int32_t ret = ARM_DRIVER_OK;
+    int32_t ret = ARM_DRIVER_ERROR;
+    fih_int fih_rc = FIH_FAILURE;
+
+    FIH_CFI_STEP_INIT(NR_MPC_INIT_STEP);
 
     ret = Driver_SRAM1_MPC.Initialize();
+    FIH_CFI_STEP_DECREMENT();
     if (ret != ARM_DRIVER_OK) {
-        return ret;
+        fih_rc = fih_int_encode(ret);
+        FIH_CFI_STEP_ERR_RESET();
+        goto Done;
     }
 
     ret = Driver_SRAM1_MPC.ConfigRegion(
                                       memory_regions.non_secure_partition_base,
                                       memory_regions.non_secure_partition_limit,
                                       ARM_MPC_ATTR_NONSECURE);
+    FIH_CFI_STEP_DECREMENT();
     if (ret != ARM_DRIVER_OK) {
-        return ret;
+        fih_rc = fih_int_encode(ret);
+        FIH_CFI_STEP_ERR_RESET();
+        goto Done;
     }
 
 #ifdef BL2
@@ -416,31 +456,46 @@ int32_t mpc_init_cfg(void)
     ret = Driver_SRAM1_MPC.ConfigRegion(memory_regions.secondary_partition_base,
                                   memory_regions.secondary_partition_limit,
                                   ARM_MPC_ATTR_NONSECURE);
+    FIH_CFI_STEP_DECREMENT();
     if (ret != ARM_DRIVER_OK) {
-        return ret;
+        fih_rc = fih_int_encode(ret);
+        FIH_CFI_STEP_ERR_RESET();
+        goto Done;
     }
 #endif /* BL2 */
 
     ret = Driver_SRAM2_MPC.Initialize();
+    FIH_CFI_STEP_DECREMENT();
     if (ret != ARM_DRIVER_OK) {
-        return ret;
+        fih_rc = fih_int_encode(ret);
+        FIH_CFI_STEP_ERR_RESET();
+        goto Done;
     }
 
     ret = Driver_SRAM2_MPC.ConfigRegion(NS_DATA_START, NS_DATA_LIMIT,
                                         ARM_MPC_ATTR_NONSECURE);
+    FIH_CFI_STEP_DECREMENT();
     if (ret != ARM_DRIVER_OK) {
-        return ret;
+        fih_rc = fih_int_encode(ret);
+        FIH_CFI_STEP_ERR_RESET();
+        goto Done;
     }
 
     /* Lock down the MPC configuration */
     ret = Driver_SRAM1_MPC.LockDown();
+    FIH_CFI_STEP_DECREMENT();
     if (ret != ARM_DRIVER_OK) {
-        return ret;
+        fih_rc = fih_int_encode(ret);
+        FIH_CFI_STEP_ERR_RESET();
+        goto Done;
     }
 
     ret = Driver_SRAM2_MPC.LockDown();
+    FIH_CFI_STEP_DECREMENT();
     if (ret != ARM_DRIVER_OK) {
-        return ret;
+        fih_rc = fih_int_encode(ret);
+        FIH_CFI_STEP_ERR_RESET();
+        goto Done;
     }
 
     /* Add barriers to assure the MPC configuration is done before continue
@@ -449,17 +504,22 @@ int32_t mpc_init_cfg(void)
     __DSB();
     __ISB();
 
-    return ARM_DRIVER_OK;
+    fih_rc = fih_int_encode(ARM_DRIVER_OK);
+
+Done:
+    FIH_RET(fih_rc);
 }
 
 /*---------------------- PPC configuration functions -------------------------*/
 #define NR_PPC_INIT_STEP                 4
 
-void ppc_init_cfg(void)
+fih_int ppc_init_cfg(void)
 {
     struct spctrl_def* spctrl = CMSDK_SPCTRL;
     struct nspctrl_def* nspctrl = CMSDK_NSPCTRL;
 
+    FIH_CFI_STEP_INIT(NR_PPC_INIT_STEP);
+
     /* Grant non-secure access to peripherals in the PPC0
      * (timer0 and 1, dualtimer, watchdog, mhu 0 and 1)
      */
@@ -499,6 +559,8 @@ void ppc_init_cfg(void)
                             (1U << CMSDK_FPGA_AUDIO_PPC_POS) |
                             (1U << CMSDK_FPGA_IO_PPC_POS);
 
+    FIH_CFI_STEP_DECREMENT();
+
     /* Grant non-secure access to all peripherals on AHB EXP:
      * Make sure that all possible peripherals are enabled by default
      */
@@ -514,6 +576,8 @@ void ppc_init_cfg(void)
                             (1U << CMSDK_DMA2_PPC_POS) |
                             (1U << CMSDK_DMA3_PPC_POS);
 
+    FIH_CFI_STEP_DECREMENT();
+
     /* in NS, grant un-privileged for UART0 */
     nspctrl->apbnspppcexp1 |= (1U << CMSDK_UART0_APB_PPC_POS);
 
@@ -521,36 +585,56 @@ void ppc_init_cfg(void)
     nspctrl->apbnspppcexp2 |= (1U << CMSDK_FPGA_SCC_PPC_POS) |
                               (1U << CMSDK_FPGA_IO_PPC_POS);
 
+    FIH_CFI_STEP_DECREMENT();
+
     /* Configure the response to a security violation as a
      * bus error instead of RAZ/WI
      */
     spctrl->secrespcfg |= 1U;
+
+    FIH_CFI_STEP_DECREMENT();
+
+    FIH_RET(fih_int_encode(TFM_PLAT_ERR_SUCCESS));
+
+    /*
+     * Dummy operation to avoid unused variable warning of the saved FIH counter
+     * variable.
+     */
+    FIH_CFI_STEP_ERR_RESET();
 }
 
-void ppc_configure_to_non_secure(enum ppc_bank_e bank, uint16_t pos)
+fih_int ppc_configure_to_non_secure(enum ppc_bank_e bank, uint16_t pos)
 {
     /* Setting NS flag for peripheral to enable NS access */
     struct spctrl_def* spctrl = CMSDK_SPCTRL;
     ((uint32_t*)&(spctrl->ahbnsppc0))[bank] |= (1U << pos);
+
+    FIH_RET(fih_int_encode(TFM_PLAT_ERR_SUCCESS));
 }
 
-void ppc_configure_to_secure(enum ppc_bank_e bank, uint16_t pos)
+fih_int ppc_configure_to_secure(enum ppc_bank_e bank, uint16_t pos)
 {
     /* Clear NS flag for peripheral to prevent NS access */
     struct spctrl_def* spctrl = CMSDK_SPCTRL;
     ((uint32_t*)&(spctrl->ahbnsppc0))[bank] &= ~(1U << pos);
+
+    FIH_RET(fih_int_encode(TFM_PLAT_ERR_SUCCESS));
 }
 
-void ppc_en_secure_unpriv(enum ppc_bank_e bank, uint16_t pos)
+fih_int ppc_en_secure_unpriv(enum ppc_bank_e bank, uint16_t pos)
 {
     struct spctrl_def* spctrl = CMSDK_SPCTRL;
     ((uint32_t*)&(spctrl->ahbspppc0))[bank] |= (1U << pos);
+
+    FIH_RET(fih_int_encode(TFM_PLAT_ERR_SUCCESS));
 }
 
-void ppc_clr_secure_unpriv(enum ppc_bank_e bank, uint16_t pos)
+fih_int ppc_clr_secure_unpriv(enum ppc_bank_e bank, uint16_t pos)
 {
     struct spctrl_def* spctrl = CMSDK_SPCTRL;
     ((uint32_t*)&(spctrl->ahbspppc0))[bank] &= ~(1U << pos);
+
+    FIH_RET(fih_int_encode(TFM_PLAT_ERR_SUCCESS));
 }
 
 void ppc_clear_irq(void)
@@ -559,3 +643,88 @@ void ppc_clear_irq(void)
     /* Clear APB PPC EXP2 IRQ */
     spctrl->secppcintclr = CMSDK_APB_PPCEXP2_INT_POS_MASK;
 }
+
+#ifdef TFM_FIH_PROFILE_ON
+#ifdef BL2
+#define NR_VERIFY_STEP                 4
+#else
+#define NR_VERIFY_STEP                 3
+#endif
+
+fih_int verify_isolation_hw(void)
+{
+    enum tfm_plat_err_t ret = ARM_DRIVER_ERROR;
+    ARM_MPC_SEC_ATTR attr;
+    fih_int fih_rc = FIH_FAILURE;
+
+    FIH_CFI_STEP_INIT(NR_VERIFY_STEP);
+
+    /* Check SAU config */
+    if (!(SAU->CTRL & SAU_CTRL_ENABLE_Msk ||
+          SAU->CTRL | SAU_CTRL_ALLNS_Msk)) {
+        FIH_PANIC;
+    }
+
+    FIH_CFI_STEP_DECREMENT();
+
+    /* Check MPC config */
+    ret = Driver_SRAM1_MPC.GetRegionConfig(
+                                  memory_regions.non_secure_partition_base,
+                                  memory_regions.non_secure_partition_limit,
+                                  &attr);
+    FIH_CFI_STEP_DECREMENT();
+    if (ret != ARM_DRIVER_OK) {
+        fih_rc = FIH_FAILURE;
+        FIH_CFI_STEP_ERR_RESET();
+        goto Done;
+    }
+
+    if (attr != ARM_MPC_ATTR_NONSECURE) {
+        fih_rc = FIH_FAILURE;
+        FIH_CFI_STEP_ERR_RESET();
+        goto Done;
+    }
+
+#ifdef BL2
+    ret = Driver_SRAM1_MPC.GetRegionConfig(
+                                  memory_regions.secondary_partition_base,
+                                  memory_regions.secondary_partition_limit,
+                                  &attr);
+    FIH_CFI_STEP_DECREMENT();
+    if (ret != ARM_DRIVER_OK) {
+        fih_rc = FIH_FAILURE;
+        FIH_CFI_STEP_ERR_RESET();
+        goto Done;
+    }
+
+    if (attr != ARM_MPC_ATTR_NONSECURE) {
+        fih_rc = FIH_FAILURE;
+        FIH_CFI_STEP_ERR_RESET();
+        goto Done;
+    }
+#endif
+
+    ret = Driver_SRAM2_MPC.GetRegionConfig(NS_DATA_START, NS_DATA_LIMIT, &attr);
+    FIH_CFI_STEP_DECREMENT();
+    if (ret != ARM_DRIVER_OK) {
+        fih_rc = FIH_FAILURE;
+        FIH_CFI_STEP_ERR_RESET();
+        goto Done;
+    }
+
+    if (attr != ARM_MPC_ATTR_NONSECURE) {
+        fih_rc = FIH_FAILURE;
+        FIH_CFI_STEP_ERR_RESET();
+        goto Done;
+    }
+
+    /* Todo: Check PPC config */
+
+    /* Todo: Check static MPU config */
+
+    fih_rc = FIH_SUCCESS;
+
+Done:
+    FIH_RET(fih_rc);
+}
+#endif /* TFM_FIH_PROFILE_ON */
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/target_cfg.h b/lib/tf-m/platform/ext/target/arm/mps2/an521/target_cfg.h
index 32f972145..25cc28ae5 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/target_cfg.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/target_cfg.h
@@ -21,6 +21,7 @@
 #include "tfm_peripherals_def.h"
 #include "tfm_plat_defs.h"
 #include "arm_uart_drv.h"
+#include "fih.h"
 
 #define TFM_DRIVER_STDIO    Driver_USART0
 #define NS_DRIVER_STDIO     Driver_USART0
@@ -81,32 +82,32 @@ struct platform_data_t
  *
  * \return  Returns error code.
  */
-int32_t mpc_init_cfg(void);
+fih_int mpc_init_cfg(void);
 
 /**
  * \brief Configures the Peripheral Protection Controller.
  */
-void ppc_init_cfg(void);
+fih_int ppc_init_cfg(void);
 
 /**
  * \brief Restict access to peripheral to secure
  */
-void ppc_configure_to_secure(enum ppc_bank_e bank, uint16_t loc);
+fih_int ppc_configure_to_secure(enum ppc_bank_e bank, uint16_t loc);
 
 /**
  * \brief Allow non-secure access to peripheral
  */
-void ppc_configure_to_non_secure(enum ppc_bank_e bank, uint16_t loc);
+fih_int ppc_configure_to_non_secure(enum ppc_bank_e bank, uint16_t loc);
 
 /**
  * \brief Enable secure unprivileged access to peripheral
  */
-void ppc_en_secure_unpriv(enum ppc_bank_e bank, uint16_t pos);
+fih_int ppc_en_secure_unpriv(enum ppc_bank_e bank, uint16_t pos);
 
 /**
  * \brief Clear secure unprivileged access to peripheral
  */
-void ppc_clr_secure_unpriv(enum ppc_bank_e bank, uint16_t pos);
+fih_int ppc_clr_secure_unpriv(enum ppc_bank_e bank, uint16_t pos);
 
 /**
  * \brief Clears PPC interrupt.
@@ -116,7 +117,7 @@ void ppc_clear_irq(void);
 /**
  * \brief Configures SAU and IDAU.
  */
-void sau_and_idau_cfg(void);
+fih_int sau_and_idau_cfg(void);
 
 /**
  * \brief Enables the fault handlers and sets priorities.
@@ -137,7 +138,7 @@ enum tfm_plat_err_t system_reset_cfg(void);
  *
  * \return Returns values as specified by the \ref fih_int
  */
-enum tfm_plat_err_t init_debug(void);
+fih_int init_debug(void);
 
 /**
  * \brief Configures all external interrupts to target the
@@ -157,4 +158,18 @@ enum tfm_plat_err_t nvic_interrupt_target_state_cfg(void);
  */
 enum tfm_plat_err_t nvic_interrupt_enable(void);
 
+#ifdef TFM_FIH_PROFILE_ON
+/**
+ * \brief This function verifies the settings of HW used for memory isolation,
+ *        to make sure that important settings was not skipped due to fault
+ *        injection attacks.
+ *
+ * This function is called during TF-M core late startup, before passing
+ * execution to non-secure code.
+ *
+ * \return Returns values as specified by the \ref fih_int.
+ */
+fih_int verify_isolation_hw(void);
+#endif /* TFM_FIH_PROFILE_ON */
+
 #endif /* __TARGET_CFG_H__ */
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/tfm_hal_isolation.c b/lib/tf-m/platform/ext/target/arm/mps2/an521/tfm_hal_isolation.c
index 795b74c78..dfafd3909 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/tfm_hal_isolation.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/tfm_hal_isolation.c
@@ -5,28 +5,16 @@
  *
  */
 
-#include "array.h"
 #include "cmsis.h"
 #include "Driver_Common.h"
-#include "mmio_defs.h"
+#include "fih.h"
 #include "mpu_armv8m_drv.h"
 #include "region.h"
 #include "target_cfg.h"
 #include "tfm_hal_isolation.h"
-#include "tfm_peripherals_def.h"
-#include "tfm_core_utils.h"
-#include "load/partition_defs.h"
-#include "load/asset_defs.h"
-#include "load/spm_load_api.h"
-
-/* It can be retrieved from the MPU_TYPE register. */
-#define MPU_REGION_NUM                  8
 
 #ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
-static uint32_t n_configured_regions = 0;
-struct mpu_armv8m_dev_t dev_mpu_s = {MPU_BASE};
 #if TFM_LVL == 3
-static uint32_t idx_boundary_handle = 0;
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Base);
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Limit);
 REGION_DECLARE(Image$$, PT_RO_START, $$Base);
@@ -34,7 +22,9 @@ REGION_DECLARE(Image$$, PT_RO_END, $$Base);
 REGION_DECLARE(Image$$, PT_PRIV_RWZI_START, $$Base);
 REGION_DECLARE(Image$$, PT_PRIV_RWZI_END, $$Base);
 
-const static struct mpu_armv8m_region_cfg_t isolation_regions[] = {
+static uint32_t g_static_region_cnt;
+
+static struct mpu_armv8m_region_cfg_t isolation_regions[] = {
     {
         0, /* will be updated before using */
         (uint32_t)&REGION_NAME(Load$$LR$$, LR_VENEER, $$Base),
@@ -54,7 +44,7 @@ const static struct mpu_armv8m_region_cfg_t isolation_regions[] = {
         MPU_ARMV8M_SH_NONE,
     },
     /* For isolation Level 3, set up static isolation for privileged data.
-     * Unprivileged data is dynamically set during Partition scheduling.
+     * Unprivileged data is dynamically set during Partition sheduling.
      */
     {
         0, /* will be updated before using */
@@ -67,6 +57,16 @@ const static struct mpu_armv8m_region_cfg_t isolation_regions[] = {
     },
 };
 #else /* TFM_LVL == 3 */
+#define ARRAY_SIZE(arr) (sizeof(arr)/sizeof(arr[0]))
+
+#define MPU_REGION_VENEERS              0
+#define MPU_REGION_TFM_UNPRIV_CODE      1
+#define MPU_REGION_NS_STACK             2
+#define PARTITION_REGION_RO             3
+#define PARTITION_REGION_RW_STACK       4
+#ifdef TFM_SP_META_PTR_ENABLE
+#define MPU_REGION_SP_META_PTR          7
+#endif /* TFM_SP_META_PTR_ENABLE */
 
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Base);
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Limit);
@@ -76,8 +76,8 @@ REGION_DECLARE(Image$$, TFM_APP_CODE_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_CODE_END, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_END, $$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Base);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
 #ifdef TFM_SP_META_PTR_ENABLE
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Base);
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
@@ -86,7 +86,7 @@ REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
 const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     /* Veneer region */
     {
-        0, /* will be updated before using */
+        MPU_REGION_VENEERS,
         (uint32_t)&REGION_NAME(Load$$LR$$, LR_VENEER, $$Base),
         (uint32_t)&REGION_NAME(Load$$LR$$, LR_VENEER, $$Limit),
         MPU_ARMV8M_MAIR_ATTR_CODE_IDX,
@@ -96,7 +96,7 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     },
     /* TFM Core unprivileged code region */
     {
-        0, /* will be updated before using */
+        MPU_REGION_TFM_UNPRIV_CODE,
         (uint32_t)&REGION_NAME(Image$$, TFM_UNPRIV_CODE, $$RO$$Base),
         (uint32_t)&REGION_NAME(Image$$, TFM_UNPRIV_CODE, $$RO$$Limit),
         MPU_ARMV8M_MAIR_ATTR_CODE_IDX,
@@ -106,9 +106,9 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     },
     /* NSPM PSP */
     {
-        0, /* will be updated before using */
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Base),
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Limit),
+        MPU_REGION_NS_STACK,
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base),
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit),
         MPU_ARMV8M_MAIR_ATTR_DATA_IDX,
         MPU_ARMV8M_XN_EXEC_NEVER,
         MPU_ARMV8M_AP_RW_PRIV_UNPRIV,
@@ -116,7 +116,7 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     },
     /* RO region */
     {
-        0, /* will be updated before using */
+        PARTITION_REGION_RO,
         (uint32_t)&REGION_NAME(Image$$, TFM_APP_CODE_START, $$Base),
         (uint32_t)&REGION_NAME(Image$$, TFM_APP_CODE_END, $$Base),
         MPU_ARMV8M_MAIR_ATTR_CODE_IDX,
@@ -126,7 +126,7 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     },
     /* RW, ZI and stack as one region */
     {
-        0, /* will be updated before using */
+        PARTITION_REGION_RW_STACK,
         (uint32_t)&REGION_NAME(Image$$, TFM_APP_RW_STACK_START, $$Base),
         (uint32_t)&REGION_NAME(Image$$, TFM_APP_RW_STACK_END, $$Base),
         MPU_ARMV8M_MAIR_ATTR_DATA_IDX,
@@ -137,7 +137,7 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
 #ifdef TFM_SP_META_PTR_ENABLE
     /* TFM partition metadata pointer region */
     {
-        0, /* will be updated before using */
+        MPU_REGION_SP_META_PTR,
         (uint32_t)&REGION_NAME(Image$$, TFM_SP_META_PTR, $$RW$$Base),
         (uint32_t)&REGION_NAME(Image$$, TFM_SP_META_PTR, $$RW$$Limit),
         MPU_ARMV8M_MAIR_ATTR_DATA_IDX,
@@ -150,289 +150,176 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
 #endif /* TFM_LVL == 3 */
 #endif /* CONFIG_TFM_ENABLE_MEMORY_PROTECT */
 
-enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
+#ifdef TFM_FIH_PROFILE_ON
+fih_int tfm_hal_set_up_static_boundaries(void)
 {
+    fih_int fih_rc = fih_int_encode(TFM_HAL_ERROR_GENERIC);
+
     /* Set up isolation boundaries between SPE and NSPE */
-    sau_and_idau_cfg();
-    if (mpc_init_cfg() != ARM_DRIVER_OK) {
-        return TFM_HAL_ERROR_GENERIC;
+    FIH_CALL(sau_and_idau_cfg, fih_rc);
+    if (fih_not_eq(fih_rc, fih_int_encode(TFM_PLAT_ERR_SUCCESS))) {
+        FIH_PANIC;
+    }
+
+    FIH_CALL(mpc_init_cfg, fih_rc);
+    if (fih_not_eq(fih_rc, fih_int_encode(TFM_PLAT_ERR_SUCCESS))) {
+        FIH_PANIC;
+    }
+
+    FIH_CALL(ppc_init_cfg, fih_rc);
+    if (fih_not_eq(fih_rc, fih_int_encode(TFM_PLAT_ERR_SUCCESS))) {
+        FIH_PANIC;
     }
-    ppc_init_cfg();
 
     /* Set up static isolation boundaries inside SPE */
 #ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
-    struct mpu_armv8m_region_cfg_t localcfg;
     int32_t i;
+    struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 
-    mpu_armv8m_clean(&dev_mpu_s);
+    FIH_CALL(mpu_armv8m_clean, fih_rc, &dev_mpu_s);
+    if (fih_not_eq(fih_rc, fih_int_encode(MPU_ARMV8M_OK))) {
+        FIH_PANIC;
+    }
 
 #if TFM_LVL == 3
-    /*
-     * Update MPU region numbers. The numbers start from 0 and are continuous.
-     * Under isolation level3, at lease one MPU region is reserved for private
-     * data asset.
-     */
-    if (ARRAY_SIZE(isolation_regions) >= MPU_REGION_NUM) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-    for (i = 0; i < ARRAY_SIZE(isolation_regions); i++) {
-        spm_memcpy(&localcfg, &isolation_regions[i], sizeof(localcfg));
+    uint32_t cnt;
+
+    /* Update MPU region numbers. The numbers start from 0 and are continuous */
+    cnt = sizeof(isolation_regions) / sizeof(isolation_regions[0]);
+    g_static_region_cnt = cnt;
+    for (i = 0; i < cnt; i++) {
         /* Update region number */
-        localcfg.region_nr = i;
+        isolation_regions[i].region_nr = i;
         /* Enable regions */
-        if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg) != MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
+        FIH_CALL(mpu_armv8m_region_enable, fih_rc, &dev_mpu_s,
+                 &isolation_regions[i]);
+        if (fih_not_eq(fih_rc, fih_int_encode(MPU_ARMV8M_OK))) {
+            FIH_RET(fih_int_encode(TFM_HAL_ERROR_GENERIC));
         }
     }
-    n_configured_regions = i;
 #else /* TFM_LVL == 3 */
-    if (ARRAY_SIZE(region_cfg) > MPU_REGION_NUM) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
     for (i = 0; i < ARRAY_SIZE(region_cfg); i++) {
-        spm_memcpy(&localcfg, &region_cfg[i], sizeof(localcfg));
-        localcfg.region_nr = i;
-        if (mpu_armv8m_region_enable(&dev_mpu_s,
-            (struct mpu_armv8m_region_cfg_t *)&localcfg)
-            != MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
+
+        FIH_CALL(mpu_armv8m_region_enable, fih_rc, &dev_mpu_s,
+                 (struct mpu_armv8m_region_cfg_t *)&region_cfg[i]);
+        if (fih_not_eq(fih_rc, fih_int_encode(MPU_ARMV8M_OK))) {
+            FIH_RET(fih_int_encode(TFM_HAL_ERROR_GENERIC));
         }
     }
-    n_configured_regions = i;
 #endif /* TFM_LVL == 3 */
 
     /* Enable MPU */
-    if (mpu_armv8m_enable(&dev_mpu_s,
-                          PRIVILEGED_DEFAULT_ENABLE,
-                          HARDFAULT_NMI_ENABLE) != MPU_ARMV8M_OK) {
-        return TFM_HAL_ERROR_GENERIC;
+    FIH_CALL(mpu_armv8m_enable, fih_rc, &dev_mpu_s,
+             PRIVILEGED_DEFAULT_ENABLE, HARDFAULT_NMI_ENABLE);
+    if (fih_not_eq(fih_rc, fih_int_encode(MPU_ARMV8M_OK))) {
+        FIH_RET(fih_int_encode(TFM_HAL_ERROR_GENERIC));
     }
 #endif /* CONFIG_TFM_ENABLE_MEMORY_PROTECT */
 
-    return TFM_HAL_SUCCESS;
+    fih_rc = fih_int_encode(TFM_HAL_SUCCESS);
+    FIH_RET(fih_rc);
 }
 
-/*
- * Implementation of tfm_hal_bind_boundaries() on AN521:
- *
- * The API encodes some attributes into a handle and returns it to SPM.
- * The attributes include isolation boundaries, privilege, and mmio information.
- * When scheduler switches running partitions, SPM compares the handle between
- * partitions to know if boundary update is necessary. If update is required,
- * SPM passes the handle to platform to do platform settings and update
- * isolation boundaries.
- *
- * The handle should be unique under isolation level 3. The implementation
- * encodes an index at the highest 8 bits to assure handle uniqueness. While
- * under isolation level 1/2, handles may not be unique.
- *
- * The encoding format assignment:
- * - For isolation level 3
- *      BIT | 31        24 | 23         20 | ... | 7           4 | 3        0 |
- *          | Unique Index | Region Attr 5 | ... | Region Attr 1 | Privileged |
- *
- *      In which the "Region Attr i" is:
- *      BIT |       3      | 2        0 |
- *          | 1: RW, 0: RO | MMIO Index |
- *
- * - For isolation level 1/2
- *      BIT | 31                           0 |
- *          | 1: privileged, 0: unprivileged |
- *
- * This is a reference implementation on AN521, and may have some limitations.
- * 1. The maximum number of allowed MMIO regions is 5.
- * 2. Highest 8 bits are for index. It supports 256 unique handles at most.
- */
-enum tfm_hal_status_t tfm_hal_bind_boundaries(
-                                    const struct partition_load_info_t *p_ldinf,
-                                    void **pp_boundaries)
+#if TFM_LVL == 3
+fih_int tfm_hal_mpu_update_partition_boundary(uintptr_t start,
+                                              uintptr_t end)
 {
-    uint32_t i, j;
-    bool privileged;
-    const struct asset_desc_t *p_asset;
-    struct platform_data_t *plat_data_ptr;
-#if TFM_LVL == 2
-    struct mpu_armv8m_region_cfg_t localcfg;
-#elif TFM_LVL == 3
-    uint32_t partition_attrs = 0;
-#endif
+    fih_int fih_rc = fih_int_encode(TFM_HAL_ERROR_GENERIC);
+    struct mpu_armv8m_region_cfg_t cfg;
+    struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
+
+    /* Partition boundary regions is right after static regions */
+    cfg.region_nr = g_static_region_cnt;
+    cfg.region_base = start;
+    cfg.region_limit = end;
+    cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
+    cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
+    cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
+    cfg.attr_sh = MPU_ARMV8M_SH_NONE;
+
+    FIH_CALL(mpu_armv8m_region_enable, fih_rc, &dev_mpu_s, &cfg);
+    if (fih_not_eq(fih_rc, fih_int_encode(MPU_ARMV8M_OK))) {
+        FIH_RET(fih_int_encode(TFM_HAL_ERROR_GENERIC));
+    }
 
-    if (!p_ldinf || !pp_boundaries) {
+    fih_rc = fih_int_encode(TFM_HAL_SUCCESS);
+    FIH_RET(fih_rc);
+}
+#endif /* TFM_LVL == 3 */
+#else /* TFM_FIH_PROFILE_ON */
+enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
+{
+    /* Set up isolation boundaries between SPE and NSPE */
+    sau_and_idau_cfg();
+    if (mpc_init_cfg() != ARM_DRIVER_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
+    ppc_init_cfg();
 
-#if TFM_LVL == 1
-    privileged = true;
-#else
-    privileged = !!(p_ldinf->flags & SPM_PART_FLAG_PSA_ROT);
-#endif
+    /* Set up static isolation boundaries inside SPE */
+#ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
+    int32_t i;
+    struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 
-    p_asset = (const struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
+    mpu_armv8m_clean(&dev_mpu_s);
 
-    /*
-     * Validate if the named MMIO of partition is allowed by the platform.
-     * Otherwise, skip validation.
-     *
-     * NOTE: Need to add validation of numbered MMIO if platform requires.
-     */
-    for (i = 0; i < p_ldinf->nassets; i++) {
-        if (!(p_asset[i].attr & ASSET_ATTR_NAMED_MMIO)) {
-            continue;
-        }
-        for (j = 0; j < ARRAY_SIZE(partition_named_mmio_list); j++) {
-            if (p_asset[i].dev.dev_ref == partition_named_mmio_list[j]) {
-                break;
-            }
-        }
+#if TFM_LVL == 3
+    uint32_t cnt;
 
-        if (j == ARRAY_SIZE(partition_named_mmio_list)) {
-            /* The MMIO asset is not in the allowed list of platform. */
+    /* Update MPU region numbers. The numbers start from 0 and are continuous */
+    cnt = sizeof(isolation_regions) / sizeof(isolation_regions[0]);
+    g_static_region_cnt = cnt;
+    for (i = 0; i < cnt; i++) {
+        /* Update region number */
+        isolation_regions[i].region_nr = i;
+        /* Enable regions */
+        if (mpu_armv8m_region_enable(&dev_mpu_s, &isolation_regions[i])
+                                                             != MPU_ARMV8M_OK) {
             return TFM_HAL_ERROR_GENERIC;
         }
-        /* Assume PPC & MPC settings are required even under level 1 */
-        plat_data_ptr = REFERENCE_TO_PTR(p_asset[i].dev.dev_ref,
-                                         struct platform_data_t *);
-
-        ppc_configure_to_secure(plat_data_ptr->periph_ppc_bank,
-                                plat_data_ptr->periph_ppc_loc);
-        if (privileged) {
-            ppc_clr_secure_unpriv(plat_data_ptr->periph_ppc_bank,
-                                  plat_data_ptr->periph_ppc_loc);
-        } else {
-            ppc_en_secure_unpriv(plat_data_ptr->periph_ppc_bank,
-                                 plat_data_ptr->periph_ppc_loc);
-        }
-#if TFM_LVL == 2
-        /*
-         * Static boundaries are set. Set up MPU region for MMIO.
-         * Setup regions for unprivileged assets only.
-         */
-        if (!privileged) {
-            localcfg.region_base = plat_data_ptr->periph_start;
-            localcfg.region_limit = plat_data_ptr->periph_limit;
-            localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
-            localcfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
-            localcfg.attr_sh = MPU_ARMV8M_SH_NONE;
-            localcfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
-            localcfg.region_nr = n_configured_regions++;
-
-            if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg)
-                != MPU_ARMV8M_OK) {
-                return TFM_HAL_ERROR_GENERIC;
-            }
-        }
-#elif TFM_LVL == 3
-        /* Encode MMIO attributes into the "partition_attrs". */
-        partition_attrs <<= HANDLE_PER_ATTR_BITS;
-        partition_attrs |= ((j + 1) & HANDLE_ATTR_INDEX_MASK);
-        if (p_asset[i].attr & ASSET_ATTR_READ_WRITE) {
-            partition_attrs |= HANDLE_ATTR_RW_POS;
+    }
+#else /* TFM_LVL == 3 */
+    for (i = 0; i < ARRAY_SIZE(region_cfg); i++) {
+        if (mpu_armv8m_region_enable(&dev_mpu_s,
+            (struct mpu_armv8m_region_cfg_t *)&region_cfg[i])
+            != MPU_ARMV8M_OK) {
+            return TFM_HAL_ERROR_GENERIC;
         }
-#endif
     }
+#endif /* TFM_LVL == 3 */
 
-#if TFM_LVL == 3
-    partition_attrs <<= HANDLE_PER_ATTR_BITS;
-    partition_attrs |= ((uint8_t)privileged) & HANDLE_ATTR_PRIV_MASK;
-    /*
-     * Highest 8 bits are reserved for index, if they are non-zero, MMIO numbers
-     * must have exceeded the limit of 5.
-     */
-    if (partition_attrs & HANDLE_INDEX_MASK) {
+    /* Enable MPU */
+    if (mpu_armv8m_enable(&dev_mpu_s,
+                          PRIVILEGED_DEFAULT_ENABLE,
+                          HARDFAULT_NMI_ENABLE) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    HANDLE_ENCODE_INDEX(partition_attrs, idx_boundary_handle);
-    *pp_boundaries = (void *)partition_attrs;
-#else
-    *pp_boundaries = (void *)(((uint32_t)privileged) & HANDLE_ATTR_PRIV_MASK);
-#endif
+#endif /* CONFIG_TFM_ENABLE_MEMORY_PROTECT */
 
     return TFM_HAL_SUCCESS;
 }
 
-enum tfm_hal_status_t tfm_hal_update_boundaries(
-                             const struct partition_load_info_t *p_ldinf,
-                             void *p_boundaries)
-{
-    CONTROL_Type ctrl;
-    uint32_t local_handle = (uint32_t)p_boundaries;
-    bool privileged = !!(local_handle & HANDLE_ATTR_PRIV_MASK);
-#if TFM_LVL == 3
-    struct mpu_armv8m_region_cfg_t localcfg;
-    uint32_t i, mmio_index;
-    struct platform_data_t *plat_data_ptr;
-    struct asset_desc_t *rt_mem;
-#endif
-
-    /* Privileged level is required to be set always */
-    ctrl.w = __get_CONTROL();
-    ctrl.b.nPRIV = privileged ? 0 : 1;
-    __set_CONTROL(ctrl.w);
-
 #if TFM_LVL == 3
-    if (!p_ldinf) {
+enum tfm_hal_status_t tfm_hal_mpu_update_partition_boundary(uintptr_t start,
+                                                            uintptr_t end)
+{
+    struct mpu_armv8m_region_cfg_t cfg;
+    enum mpu_armv8m_error_t mpu_err;
+    struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
+
+    /* Partition boundary regions is right after static regions */
+    cfg.region_nr = g_static_region_cnt;
+    cfg.region_base = start;
+    cfg.region_limit = end;
+    cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
+    cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
+    cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
+    cfg.attr_sh = MPU_ARMV8M_SH_NONE;
+    mpu_err = mpu_armv8m_region_enable(&dev_mpu_s, &cfg);
+    if (mpu_err != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-
-    /* Update regions, for unprivileged partitions only */
-    if (privileged) {
-        return TFM_HAL_SUCCESS;
-    }
-
-    /* Setup runtime memory first */
-    localcfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
-    localcfg.attr_sh = MPU_ARMV8M_SH_NONE;
-    localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
-    localcfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
-    rt_mem = (struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
-    /*
-     * AN521 shortcut: The first item is the only runtime memory asset.
-     * Platforms with many memory assets please check this part.
-     */
-    for (i = 0;
-         i < p_ldinf->nassets && !(rt_mem[i].attr & ASSET_ATTR_MMIO);
-         i++) {
-        localcfg.region_nr = n_configured_regions + i;
-        localcfg.region_base = rt_mem[i].mem.start;
-        localcfg.region_limit = rt_mem[i].mem.limit;
-
-        if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg) != MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
-        }
-    }
-
-    /* Named MMIO part */
-    local_handle = local_handle & (~HANDLE_INDEX_MASK);
-    local_handle >>= HANDLE_PER_ATTR_BITS;
-    mmio_index = local_handle & HANDLE_ATTR_INDEX_MASK;
-
-    localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
-
-    i = n_configured_regions + i;
-    while (mmio_index && i < MPU_REGION_NUM) {
-        plat_data_ptr =
-          (struct platform_data_t *)partition_named_mmio_list[mmio_index - 1];
-        localcfg.region_nr = i++;
-        localcfg.attr_access = (local_handle & HANDLE_ATTR_RW_POS)?
-                            MPU_ARMV8M_AP_RW_PRIV_UNPRIV :
-                            MPU_ARMV8M_AP_RO_PRIV_UNPRIV;
-        localcfg.region_base = plat_data_ptr->periph_start;
-        localcfg.region_limit = plat_data_ptr->periph_limit;
-
-        if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg) != MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
-        }
-
-        local_handle >>= HANDLE_PER_ATTR_BITS;
-        mmio_index = local_handle & HANDLE_ATTR_INDEX_MASK;
-    }
-
-    /* Disable unused regions */
-    while (i < MPU_REGION_NUM) {
-        if (mpu_armv8m_region_disable(&dev_mpu_s, i++)!= MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
-        }
-    }
-#endif
     return TFM_HAL_SUCCESS;
 }
+#endif /* TFM_LVL == 3 */
+#endif /* TFM_FIH_PROFILE_ON */
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/arm/mps2/an521/tfm_peripherals_def.h
index 00e9b366a..c5b80bf3b 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/tfm_peripherals_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
  * Copyright (c) 2020, Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -15,12 +15,6 @@
 extern "C" {
 #endif
 
-/*
- * Quantized default IRQ priority, the value is:
- * (Number of configurable priority) / 4: (1UL << __NVIC_PRIO_BITS) / 4
- */
-#define DEFAULT_IRQ_PRIORITY    (1UL << (__NVIC_PRIO_BITS - 2))
-
 #define TFM_TIMER0_IRQ           (TIMER0_IRQn)
 #define TFM_TIMER1_IRQ           (TIMER1_IRQn)
 #define FF_TEST_UART_IRQ         (UARTTX2_IRQn)
@@ -30,10 +24,12 @@ struct platform_data_t;
 
 extern struct platform_data_t tfm_peripheral_std_uart;
 extern struct platform_data_t tfm_peripheral_uart1;
+extern struct platform_data_t tfm_peripheral_fpga_io;
 extern struct platform_data_t tfm_peripheral_timer0;
 
 #define TFM_PERIPHERAL_STD_UART  (&tfm_peripheral_std_uart)
 #define TFM_PERIPHERAL_UART1     (&tfm_peripheral_uart1)
+#define TFM_PERIPHERAL_FPGA_IO   (&tfm_peripheral_fpga_io)
 #define TFM_PERIPHERAL_TIMER0    (&tfm_peripheral_timer0)
 
 #ifdef PSA_API_TEST_IPC
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/device/source/startup_fvp_sse300_mps2_s.c b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/device/source/startup_fvp_sse300_mps2_s.c
index 54be0ac56..8c6046fb2 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/device/source/startup_fvp_sse300_mps2_s.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/device/source/startup_fvp_sse300_mps2_s.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: Apache-2.0
  *
@@ -33,12 +33,15 @@ typedef void( *pFunc )( void );
   External References
  *----------------------------------------------------------------------------*/
 
-#define __MSP_INITIAL_SP              REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit)
-#define __MSP_STACK_LIMIT             REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base)
+#define __MSP_INITIAL_SP              REGION_NAME(Image$$, ARM_LIB_STACK_MSP, $$ZI$$Limit)
+#define __MSP_STACK_LIMIT             REGION_NAME(Image$$, ARM_LIB_STACK_MSP, $$ZI$$Base)
 
 extern uint32_t __MSP_INITIAL_SP;
 extern uint32_t __MSP_STACK_LIMIT;
 
+extern uint32_t __INITIAL_SP;
+extern uint32_t __STACK_LIMIT;
+
 extern void __PROGRAM_START(void) __NO_RETURN;
 
 /*----------------------------------------------------------------------------
@@ -231,6 +234,11 @@ void Reset_Handler(void)
   __set_MSPLIM((uint32_t)(&__MSP_STACK_LIMIT));
 
   SystemInit();                             /* CMSIS System Initialization */
-
+  __ASM volatile("MRS     R0, control\n"    /* Get control value */
+                 "ORR     R0, R0, #2\n"     /* Select switch to PSP */
+                 "MSR     control, R0\n"    /* Load control register */
+                 :
+                 :
+                 : "r0");
   __PROGRAM_START();                        /* Enter PreMain (C library entry point) */
 }
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/native_drivers/mpu_armv8m_drv.h b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/native_drivers/mpu_armv8m_drv.h
index 6bfb0b293..de51999c3 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/native_drivers/mpu_armv8m_drv.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/native_drivers/mpu_armv8m_drv.h
@@ -101,7 +101,7 @@ enum mpu_armv8m_error_t mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -112,7 +112,7 @@ enum mpu_armv8m_error_t mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev);
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -124,7 +124,7 @@ enum mpu_armv8m_error_t mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev);
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_cfg     MPU region config \ref mpu_armv8m_region_cfg_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -138,7 +138,7 @@ enum mpu_armv8m_error_t mpu_armv8m_region_enable(
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_nr            Region number
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/partition/flash_layout.h b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/partition/flash_layout.h
index e2cfe2216..9fc1db022 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/partition/flash_layout.h
@@ -29,8 +29,8 @@
  * 0x0014_0000 Scratch area (384 KB)
  * 0x001A_0000 Protected Storage Area (20 KB)
  * 0x001A_5000 Internal Trusted Storage Area (16 KB)
- * 0x001A_9000 OTP / NV counters area (8 KB)
- * 0x001A_B000 Unused
+ * 0x001A_9000 NV counters area (4 KB)
+ * 0x001A_A000 Unused
  *
  * Flash layout on fvp_sse300_mps2 with BL2 (single image boot):
  *
@@ -43,8 +43,8 @@
  * 0x0014_0000 Scratch area (640 KB)
  * 0x001E_0000 Protected Storage Area (20 KB)
  * 0x001E_5000 Internal Trusted Storage Area (16 KB)
- * 0x001A_9000 OTP / NV counters area (8 KB)
- * 0x001A_B000 Unused
+ * 0x001E_9000 NV counters area (4 KB)
+ * 0x001E_A000 Unused
  */
 
 
@@ -152,11 +152,10 @@
                                          FLASH_PS_AREA_SIZE)
 #define FLASH_ITS_AREA_SIZE             (0x4000)   /* 16 KB */
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* Offset and size definition in flash area used by assemble.py */
 #define SECURE_IMAGE_OFFSET             (0x0)
@@ -170,8 +169,6 @@
  * Name is defined in flash driver file: Driver_Flash.c
  */
 #define FLASH_DEV_NAME Driver_FLASH0
-/* Smallest flash programmable unit in bytes */
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x1)
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -213,11 +210,10 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x1)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18) /* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
 
 #endif /* __FLASH_LAYOUT_H__ */
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/partition/region_defs.h b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/partition/region_defs.h
index da8f6716e..9f9d50616 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/partition/region_defs.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/partition/region_defs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020 Arm Limited. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -81,19 +81,8 @@
 #define BL2_TRAILER_SIZE     (0xC00)
 #endif /* BL2 */
 
-#if (MCUBOOT_IMAGE_NUMBER == 1) && \
-    (NS_IMAGE_PRIMARY_PARTITION_OFFSET > S_IMAGE_PRIMARY_PARTITION_OFFSET)
-/* If secure image and nonsecure image are concatenated, and nonsecure image
- * locates at the higher memory range, then the secure image does not need
- * the trailer area.
- */
-#define IMAGE_S_CODE_SIZE \
-            (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE)
-#else
 #define IMAGE_S_CODE_SIZE \
             (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
-#endif
-
 #define IMAGE_NS_CODE_SIZE \
             (FLASH_NS_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
 
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/plat_test.c b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/plat_test.c
index cf25c7560..bdcbd48e4 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/plat_test.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/plat_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -13,6 +13,46 @@
 #include "smm_mps2.h"
 
 #define TIMER_RELOAD_VALUE (16*1024*1024)
+#define USERLED_MASK       (0x3)
+#define MPS2_USERPB0_BASE  (0x50302008)
+#define MPS2_USERPB0_MASK  (0x1)
+
+void tfm_plat_test_wait_user_button_pressed(void)
+{
+    volatile uint32_t *p_btn = (volatile uint32_t *) MPS2_USERPB0_BASE;
+
+    /* Wait until user button 0 is pressed */
+    while (!(*p_btn & MPS2_USERPB0_MASK)) {
+      ;
+    }
+}
+
+void tfm_plat_test_wait_user_button_released(void)
+{
+    volatile uint32_t *p_btn = (volatile uint32_t *) MPS2_USERPB0_BASE;
+
+    /* Wait until user button 0 is released */
+    while ((*p_btn & MPS2_USERPB0_MASK)) {
+      ;
+    }
+}
+
+uint32_t tfm_plat_test_get_led_status(void)
+{
+    struct arm_mps2_fpgaio_t *fpgaio = SEC_MPS2_FPGAIO;
+    return  fpgaio->LED;
+}
+
+void tfm_plat_test_set_led_status(uint32_t status)
+{
+    struct arm_mps2_fpgaio_t *fpgaio = SEC_MPS2_FPGAIO;
+    fpgaio->LED = status;
+}
+
+uint32_t tfm_plat_test_get_userled_mask(void)
+{
+    return USERLED_MASK;
+}
 
 void tfm_plat_test_secure_timer_start(void)
 {
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/target_cfg.c b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/target_cfg.c
index 9b3c6012c..717661650 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/target_cfg.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/target_cfg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020 Arm Limited. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -126,6 +126,13 @@ struct platform_data_t tfm_peripheral_uart1 = {
         UART1_PERIPH_PPCEXP1_POS_MASK
 };
 
+struct platform_data_t tfm_peripheral_fpga_io = {
+        MPS2_IO_FPGAIO_BASE_S,
+        MPS2_IO_FPGAIO_BASE_S + 0xFFF,
+        PPC_SP_PERIPH_EXP2,
+        FPGA_IO_PERIPH_PPCEXP2_POS_MASK
+};
+
 struct platform_data_t tfm_peripheral_timer0 = {
         SYSTIMER0_ARMV8_M_BASE_S,
         SYSTIMER0_ARMV8_M_BASE_S + 0xFFF,
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/tfm_hal_isolation.c b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/tfm_hal_isolation.c
index 7f18a882c..4cbce3014 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/tfm_hal_isolation.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/tfm_hal_isolation.c
@@ -33,8 +33,8 @@ REGION_DECLARE(Image$$, TFM_APP_CODE_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_CODE_END, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_END, $$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Base);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
 #ifdef TFM_SP_META_PTR_ENABLE
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Base);
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
@@ -70,8 +70,8 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     /* NSPM PSP */
     {
         MPU_REGION_NS_STACK,
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Base),
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Limit),
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base),
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit),
         MPU_ARMV8M_MAIR_ATTR_DATA_IDX,
         MPU_ARMV8M_XN_EXEC_NEVER,
         MPU_ARMV8M_AP_RW_PRIV_UNPRIV,
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/tfm_peripherals_def.h
index 7cc305dc1..ae21ca295 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/tfm_peripherals_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  * Copyright (c) 2020, Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -24,10 +24,12 @@ struct platform_data_t;
 
 extern struct platform_data_t tfm_peripheral_std_uart;
 extern struct platform_data_t tfm_peripheral_uart1;
+extern struct platform_data_t tfm_peripheral_fpga_io;
 extern struct platform_data_t tfm_peripheral_timer0;
 
 #define TFM_PERIPHERAL_STD_UART  (&tfm_peripheral_std_uart)
 #define TFM_PERIPHERAL_UART1     (&tfm_peripheral_uart1)
+#define TFM_PERIPHERAL_FPGA_IO   (&tfm_peripheral_fpga_io)
 #define TFM_PERIPHERAL_TIMER0    (&tfm_peripheral_timer0)
 
 #ifdef PSA_API_TEST_IPC
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/cmsis_drivers/Driver_Flash.c b/lib/tf-m/platform/ext/target/arm/mps3/an524/cmsis_drivers/Driver_Flash.c
index 864ee9713..0582300f8 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/cmsis_drivers/Driver_Flash.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/cmsis_drivers/Driver_Flash.c
@@ -44,7 +44,7 @@
 #define FLASH_REDIRECT_LIMIT  (FLASH_REDIRECT_BASE   \
                                + FLASH_PS_AREA_SIZE \
                                + FLASH_ITS_AREA_SIZE \
-                               + FLASH_OTP_NV_COUNTERS_AREA_SIZE)
+                               + FLASH_NV_COUNTERS_AREA_SIZE)
 #define FLASH_REDIRECT_DEST   0x38000000
 
 #define FLASH0_BASE_S         0x10000000
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/armclang/startup_cmsdk_mps3_an524_s.s b/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/armclang/startup_cmsdk_mps3_an524_s.s
index cfdd1313c..ff9a8d322 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/armclang/startup_cmsdk_mps3_an524_s.s
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/armclang/startup_cmsdk_mps3_an524_s.s
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2016-2021 Arm Limited. All rights reserved.
+; * Copyright (c) 2016-2019 Arm Limited. All rights reserved.
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -25,7 +25,7 @@
 ;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
 ; </h>
 
-    IMPORT |Image$$ARM_LIB_STACK$$ZI$$Limit|
+    IMPORT |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|
 
 ; Vector Table Mapped to Address 0 at Reset
 
@@ -35,7 +35,7 @@
     EXPORT  __Vectors_Size
 
 __Vectors
-    DCD     |Image$$ARM_LIB_STACK$$ZI$$Limit|  ; Top of Stack
+    DCD     |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|  ; Top of Stack
     DCD     Reset_Handler             ; Reset Handler
     DCD     NMI_Handler               ; NMI Handler
     DCD     HardFault_Handler         ; Hard Fault Handler
@@ -200,6 +200,9 @@ Reset_Handler \
     CPSID   i              ; Disable IRQs
     LDR     R0, =SystemInit
     BLX     R0
+    MRS     R0, control    ; Get control value
+    ORR     R0, R0, #2     ; Select switch to PSP
+    MSR     control, R0
     LDR     R0, =__main
     BX      R0
     ENDP
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/device_definition.c b/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/device_definition.c
index 40ca53b2d..0dda9e976 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/device_definition.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/device_definition.c
@@ -344,21 +344,21 @@ struct ppc_sse200_dev_t APB_PPCEXP2_DEV_S = {
 /* CMSDK Timer driver structures */
 #ifdef CMSDK_TIMER0_S
 static const struct timer_cmsdk_dev_cfg_t CMSDK_TIMER0_DEV_CFG_S
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
 #endif
   = {
         .base = CMSDK_TIMER0_BASE_S
     };
 static struct timer_cmsdk_dev_data_t CMSDK_TIMER0_DEV_DATA_S
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
 #endif
   = {
         .is_initialized = 0
     };
 struct timer_cmsdk_dev_t CMSDK_TIMER0_DEV_S
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
 #endif
   = {
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/gcc/startup_cmsdk_mps3_an524_s.S b/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/gcc/startup_cmsdk_mps3_an524_s.S
index 18a4fd4cf..b8fb9302f 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/gcc/startup_cmsdk_mps3_an524_s.S
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/gcc/startup_cmsdk_mps3_an524_s.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,7 +28,7 @@
     .align 2
     .globl    __Vectors
 __Vectors:
-    .long    Image$$ARM_LIB_STACK$$ZI$$Limit   /* Top of Stack */
+    .long    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit   /* Top of Stack */
 
     /* Core interrupts */
     .long    Reset_Handler                  /* Reset Handler */
@@ -306,6 +306,12 @@ Reset_Handler:
     cpsid   i              /* Disable IRQs */
     bl    SystemInit
 
+    mrs     r0, control    /* Get control value */
+    orr     r0, r0, #2     /* Select switch to PSP */
+    msr     control, r0
+    ldr     r0, =Image$$ARM_LIB_STACK$$ZI$$Limit
+    msr     psp, r0
+
 #ifndef __START
 #define __START _start
 #endif
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/iar/startup_cmsdk_mps3_an524_ns.s b/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/iar/startup_cmsdk_mps3_an524_ns.s
index d8dcc6e8c..66f060d52 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/iar/startup_cmsdk_mps3_an524_ns.s
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/iar/startup_cmsdk_mps3_an524_ns.s
@@ -1,6 +1,5 @@
 ;/*
 ; * Copyright (c) 2016-2020 ARM Limited
-; * Copyright (c) 2020-2021 IAR Systems AB
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -202,6 +201,7 @@ Reset_Handler
         LDR      R0, =sfe(ARM_LIB_STACK)       ; End of ARM_LIB_STACK
         MSR      PSP, R0
         MRS      R0, CONTROL    ; Get control value
+        ORR      R0, R0, #1     ; Select switch to non privileged mode
         ORR      R0, R0, #2     ; Select switch to PSP
         MSR      CONTROL, R0
         LDR      R0, =__iar_program_start
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/iar/startup_cmsdk_mps3_an524_s.s b/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/iar/startup_cmsdk_mps3_an524_s.s
index 6064861c7..855a7af8e 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/iar/startup_cmsdk_mps3_an524_s.s
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/device/source/iar/startup_cmsdk_mps3_an524_s.s
@@ -28,6 +28,7 @@
         MODULE   ?cstartup
 
         ;; Forward declaration of sections.
+        SECTION  ARM_LIB_STACK_MSP:DATA:NOROOT(3)
         SECTION  ARM_LIB_STACK:DATA:NOROOT(3)
 
         SECTION  .intvec:CODE:NOROOT(2)
@@ -42,7 +43,7 @@
         DATA
 
 __vector_table      ;Core Interrupts
-        DCD     sfe(ARM_LIB_STACK)        ; Top of Stack
+        DCD     sfe(ARM_LIB_STACK_MSP)    ; Top of Stack
         DCD     Reset_Handler             ; Reset Handler
         DCD     NMI_Handler               ; NMI Handler
         DCD     HardFault_Handler         ; Hard Fault Handler
@@ -203,6 +204,11 @@ Reset_Handler
         CPSID   i              ; Disable IRQs
         LDR     R0, =SystemInit
         BLX     R0
+        LDR     R0, =sfe(ARM_LIB_STACK)      ; End of PROC_STACK
+        MSR     PSP, R0
+        MRS     R0, control    ; Get control value
+        ORR     R0, R0, #2     ; Select switch to PSP
+        MSR     control, R0
         LDR     R0, =__iar_program_start
         BX      R0
 
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/native_drivers/mpu_armv8m_drv.h b/lib/tf-m/platform/ext/target/arm/mps3/an524/native_drivers/mpu_armv8m_drv.h
index 9244cdf2b..d427604f3 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/native_drivers/mpu_armv8m_drv.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/native_drivers/mpu_armv8m_drv.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2019, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -91,7 +91,7 @@ enum mpu_armv8m_error_t mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -102,7 +102,7 @@ enum mpu_armv8m_error_t mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev);
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -114,7 +114,7 @@ enum mpu_armv8m_error_t mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev);
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_cfg     MPU region config \ref mpu_armv8m_region_cfg_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -128,7 +128,7 @@ enum mpu_armv8m_error_t mpu_armv8m_region_enable(
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_nr            Region number
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/partition/flash_layout.h b/lib/tf-m/platform/ext/target/arm/mps3/an524/partition/flash_layout.h
index 621e1a581..35e7d1e20 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/partition/flash_layout.h
@@ -36,8 +36,8 @@
  *     0x0018_0000 Non-secure image     (256 KB)
  * 0x001C_0000 PS area                  (20 KB)
  * 0x001C_5000 ITS area                 (16 KB)
- * 0x001C_9000 OTP / NV counters area   (8 KB)
- * 0x001C_B000 Unused
+ * 0x001C_9000 NV counters              (4 KB)
+ * 0x001C_A000 Unused
  *
  * Flash layout without BL2
  *
@@ -45,8 +45,8 @@
  * 0x000C_0000 Non-secure image         (256 KB)
  * 0x001C_0000 PS area                  (20 KB)
  * 0x001C_5000 ITS area                 (16 KB)
- * 0x001C_9000 OTP / NV counters area   (8 KB)
- * 0x001C_B000 Unused
+ * 0x001C_9000 NV counters              (4 KB)
+ * 0x001C_A000 Unused
  */
 
 /* Size of a Secure and of a Non-secure image */
@@ -136,11 +136,10 @@
                                          FLASH_PS_AREA_SIZE)
 #define FLASH_ITS_AREA_SIZE             (0x4000)   /* 16 KB */
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* Offset and size definition in flash area used by assemble.py */
 #define SECURE_IMAGE_OFFSET             (0x0)
@@ -154,8 +153,6 @@
  * Name is defined in flash driver file: Driver_Flash.c
  */
 #define FLASH_DEV_NAME Driver_FLASH0
-/* Smallest flash programmable unit in bytes */
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x1)
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -197,12 +194,11 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x1)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18) /* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
 
 /* Use Internal SRAM0~3 to store RW data
  * ISRAM0 and ISRAM1 for Secure Data
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/partition/region_defs.h b/lib/tf-m/platform/ext/target/arm/mps3/an524/partition/region_defs.h
index ab1fc522a..089a3b72e 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/partition/region_defs.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/partition/region_defs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020 Arm Limited. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -74,19 +74,8 @@
 #define BL2_TRAILER_SIZE     (0x800)
 #endif /* BL2 */
 
-#if (MCUBOOT_IMAGE_NUMBER == 1) && \
-    (NS_IMAGE_PRIMARY_PARTITION_OFFSET > S_IMAGE_PRIMARY_PARTITION_OFFSET)
-/* If secure image and nonsecure image are concatenated, and nonsecure image
- * locates at the higher memory range, then the secure image does not need
- * the trailer area.
- */
-#define IMAGE_S_CODE_SIZE \
-            (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE)
-#else
 #define IMAGE_S_CODE_SIZE \
             (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
-#endif
-
 #define IMAGE_NS_CODE_SIZE \
             (FLASH_NS_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
 
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/plat_test.c b/lib/tf-m/platform/ext/target/arm/mps3/an524/plat_test.c
index edc29d1c4..cdfcfa209 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/plat_test.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/plat_test.c
@@ -10,8 +10,58 @@
 #include "tfm_plat_test.h"
 #include "device_definition.h"
 
+#define USERLED_MASK                (0x3)
+#define BTN_WAIT_INIT_COUNTER_VALUE (10000u)
 #define TIMER_RELOAD_VALUE          (16*1024*1024)
 
+/**
+ * \brief Store the state of the mocked LED
+ *
+ * This variable have to be linked to the data section of the partition
+ * TFM_SP_CORE_TEST so that in case of in case of isolation within the secure
+ * domain the Core Test service can access it.
+ */
+uint32_t led_status
+    TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_CORE_TEST", "PSA-ROT")
+    = 0x02u;
+
+/**
+ * \brief Simulate user reaction time
+ */
+static void busy_wait_to_simulate_user(void)
+{
+    volatile uint32_t counter = BTN_WAIT_INIT_COUNTER_VALUE;
+    while (counter)
+    {
+        --counter;
+    }
+}
+
+void tfm_plat_test_wait_user_button_pressed(void)
+{
+    busy_wait_to_simulate_user();
+}
+
+void tfm_plat_test_wait_user_button_released(void)
+{
+    busy_wait_to_simulate_user();
+}
+
+uint32_t tfm_plat_test_get_led_status(void)
+{
+    return led_status;
+}
+
+void tfm_plat_test_set_led_status(uint32_t status)
+{
+    led_status = status & USERLED_MASK;
+}
+
+uint32_t tfm_plat_test_get_userled_mask(void)
+{
+    return USERLED_MASK;
+}
+
 void tfm_plat_test_secure_timer_start(void)
 {
     if (!timer_cmsdk_is_initialized(&CMSDK_TIMER0_DEV_S)) {
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/spm_hal.c b/lib/tf-m/platform/ext/target/arm/mps3/an524/spm_hal.c
index ac228633b..6debc62b3 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/spm_hal.c
@@ -5,10 +5,13 @@
  *
  */
 
+#include <stdio.h>
 #include "cmsis.h"
 #include "tfm_spm_hal.h"
 #include "tfm_platform_core_api.h"
 #include "target_cfg.h"
+#include "mpu_armv8m_drv.h"
+#include "region_defs.h"
 #include "platform_description.h"
 #include "Driver_Common.h"
 #include "region.h"
@@ -29,6 +32,26 @@
 /* Get address of memory regions to configure MPU */
 extern const struct memory_region_limits memory_regions;
 
+enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
+                  bool privileged,
+                  const struct platform_data_t *platform_data)
+{
+    if (!platform_data) {
+        return TFM_PLAT_ERR_INVALID_INPUT;
+    }
+
+    if (platform_data->periph_ppc_bank != PPC_SP_DO_NOT_CONFIGURE) {
+        if (privileged) {
+            ppc_configure_to_secure_priv(platform_data->periph_ppc_bank,
+                                         platform_data->periph_ppc_loc);
+        } else {
+            ppc_en_secure_unpriv(platform_data->periph_ppc_bank,
+                                 platform_data->periph_ppc_loc);
+        }
+    }
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
 void MPC_Handler(void)
 {
     /* Clear MPC interrupt flag and pending MPC IRQ */
@@ -168,25 +191,3 @@ enum tfm_plat_err_t tfm_spm_hal_nvic_interrupt_enable(void)
 {
     return nvic_interrupt_enable();
 }
-
-#ifndef TFM_PSA_API
-enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
-                  bool privileged,
-                  const struct platform_data_t *platform_data)
-{
-    if (!platform_data) {
-        return TFM_PLAT_ERR_INVALID_INPUT;
-    }
-
-    if (platform_data->periph_ppc_bank != PPC_SP_DO_NOT_CONFIGURE) {
-        if (privileged) {
-            ppc_configure_to_secure_priv(platform_data->periph_ppc_bank,
-                                         platform_data->periph_ppc_loc);
-        } else {
-            ppc_en_secure_unpriv(platform_data->periph_ppc_bank,
-                                 platform_data->periph_ppc_loc);
-        }
-    }
-    return TFM_PLAT_ERR_SUCCESS;
-}
-#endif
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/tfm_hal_isolation.c b/lib/tf-m/platform/ext/target/arm/mps3/an524/tfm_hal_isolation.c
index b09c95bfc..0f27cba96 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/tfm_hal_isolation.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/tfm_hal_isolation.c
@@ -1,27 +1,18 @@
 /*
- * Copyright (c) 2020-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
  */
 
-#include "array.h"
 #include "cmsis.h"
 #include "Driver_Common.h"
-#include "mmio_defs.h"
 #include "mpu_armv8m_drv.h"
 #include "region.h"
 #include "target_cfg.h"
 #include "tfm_hal_isolation.h"
-#include "tfm_peripherals_def.h"
-#include "tfm_core_utils.h"
-#include "load/partition_defs.h"
-#include "load/asset_defs.h"
-#include "load/spm_load_api.h"
 
 #ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
-static uint32_t n_configured_regions = 0;
-struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 
 #define MPU_REGION_VENEERS           0
 #define MPU_REGION_TFM_UNPRIV_CODE   1
@@ -39,8 +30,8 @@ REGION_DECLARE(Image$$, TFM_APP_CODE_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_CODE_END, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_END, $$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Base);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
 #ifdef TFM_SP_META_PTR_ENABLE
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Base);
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
@@ -79,7 +70,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_region_enable(&region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
     /* TFM Core unprivileged code region */
     region_cfg.region_nr = MPU_REGION_TFM_UNPRIV_CODE;
@@ -94,14 +84,13 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_region_enable(&region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
     /* NSPM PSP */
     region_cfg.region_nr = MPU_REGION_NS_STACK;
     region_cfg.region_base =
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base);
     region_cfg.region_limit =
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
     region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
     region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
     region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
@@ -109,7 +98,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_region_enable(&region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
     /* RO region */
     region_cfg.region_nr = PARTITION_REGION_RO;
@@ -124,7 +112,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_region_enable(&region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
     /* RW, ZI and stack as one region */
     region_cfg.region_nr = PARTITION_REGION_RW_STACK;
@@ -139,7 +126,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_region_enable(&region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
 #ifdef TFM_SP_META_PTR_ENABLE
     /* TFM partition metadata pointer region */
@@ -155,8 +141,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_region_enable(&region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
-
 #endif
 
     mpu_enable(PRIVILEGED_DEFAULT_ENABLE, HARDFAULT_NMI_ENABLE);
@@ -164,99 +148,3 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
 
     return TFM_HAL_SUCCESS;
 }
-
-/*
- * Implementation of tfm_hal_bind_boundaries() on AN524:
- *
- * The API encodes some attributes into a handle and returns it to SPM.
- * The attributes include isolation boundaries, privilege, and MMIO information.
- * When scheduler switches running partitions, SPM compares the handle between
- * partitions to know if boundary update is necessary. If update is required,
- * SPM passes the handle to platform to do platform settings and update
- * isolation boundaries.
- */
-enum tfm_hal_status_t tfm_hal_bind_boundaries(
-                                    const struct partition_load_info_t *p_ldinf,
-                                    void **pp_boundaries)
-{
-    uint32_t i, j;
-    bool privileged;
-    const struct asset_desc_t *p_asset;
-    struct platform_data_t *plat_data_ptr;
-#if TFM_LVL == 2
-    struct mpu_armv8m_region_cfg_t localcfg;
-#endif
-    if (!p_ldinf || !pp_boundaries) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-
-#if TFM_LVL == 1
-    privileged = true;
-#else
-    privileged = !!(p_ldinf->flags & SPM_PART_FLAG_PSA_ROT);
-#endif
-
-    p_asset = (const struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
-
-    /*
-     * Validate if the named MMIO of partition is allowed by the platform.
-     * Otherwise, skip validation.
-     *
-     * NOTE: Need to add validation of numbered MMIO if platform requires.
-     */
-    for (i = 0; i < p_ldinf->nassets; i++) {
-        if (!(p_asset[i].attr & ASSET_ATTR_NAMED_MMIO)) {
-            continue;
-        }
-        for (j = 0; j < ARRAY_SIZE(partition_named_mmio_list); j++) {
-            if (p_asset[i].dev.dev_ref == partition_named_mmio_list[j]) {
-                break;
-            }
-        }
-
-        if (j == ARRAY_SIZE(partition_named_mmio_list)) {
-            /* The MMIO asset is not in the allowed list of platform. */
-            return TFM_HAL_ERROR_GENERIC;
-        }
-
-#if TFM_LVL == 2
-        /*
-         * Static boundaries are set. Set up MPU region for MMIO.
-         * Setup regions for unprivileged assets only.
-         */
-        if (!privileged) {
-            localcfg.region_base = plat_data_ptr->periph_start;
-            localcfg.region_limit = plat_data_ptr->periph_limit;
-            localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
-            localcfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
-            localcfg.attr_sh = MPU_ARMV8M_SH_NONE;
-            localcfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
-            localcfg.region_nr = n_configured_regions++;
-
-            if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg)
-                != MPU_ARMV8M_OK) {
-                return TFM_HAL_ERROR_GENERIC;
-            }
-        }
-#endif
-    }
-
-    *pp_boundaries = (void *)(((uint32_t)privileged) & HANDLE_ATTR_PRIV_MASK);
-
-    return TFM_HAL_SUCCESS;
-}
-
-enum tfm_hal_status_t tfm_hal_update_boundaries(
-                             const struct partition_load_info_t *p_ldinf,
-                             void *p_boundaries)
-{
-    CONTROL_Type ctrl;
-    bool privileged = !!((uint32_t)p_boundaries & HANDLE_ATTR_PRIV_MASK);
-
-    /* Privileged level is required to be set always */
-    ctrl.w = __get_CONTROL();
-    ctrl.b.nPRIV = privileged ? 0 : 1;
-    __set_CONTROL(ctrl.w);
-
-    return TFM_HAL_SUCCESS;
-}
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/arm/mps3/an524/tfm_peripherals_def.h
index a745036ec..643046cd0 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/tfm_peripherals_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019, Arm Limited. All rights reserved.
  * Copyright (c) 2020, Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -15,12 +15,6 @@
 extern "C" {
 #endif
 
-/*
- * Quantized default IRQ priority, the value is:
- * (Number of configurable priority) / 4: (1UL << __NVIC_PRIO_BITS) / 4
- */
-#define DEFAULT_IRQ_PRIORITY    (1UL << (__NVIC_PRIO_BITS - 2))
-
 #define TFM_TIMER0_IRQ    (TIMER0_IRQn)
 #define TFM_TIMER1_IRQ    (TIMER1_IRQn)
 
@@ -31,6 +25,7 @@ extern struct platform_data_t tfm_peripheral_timer0;
 
 #define TFM_PERIPHERAL_STD_UART  (&tfm_peripheral_std_uart)
 #define TFM_PERIPHERAL_TIMER0    (&tfm_peripheral_timer0)
+#define TFM_PERIPHERAL_FPGA_IO   (0)
 
 #ifdef __cplusplus
 }
diff --git a/tf-m.old/platform/ext/target/arm/mps3/an547/.README.rst.swp b/lib/tf-m/platform/ext/target/arm/mps3/an547/.README.rst.swp
new file mode 100644
index 000000000..2ea42f898
Binary files /dev/null and b/lib/tf-m/platform/ext/target/arm/mps3/an547/.README.rst.swp differ
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_AN547_MPC.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_AN547_MPC.c
index 4b24631f7..2a6b8b247 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_AN547_MPC.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_AN547_MPC.c
@@ -624,26 +624,73 @@ ARM_DRIVER_MPC Driver_QSPI_MPC = {
 #endif /* RTE_QSPI_MPC */
 
 #if (RTE_DDR4_MPC)
-/* Ranges controlled by this DDR4_MPC */
-static const struct mpc_sie_memory_range_t MPC_DDR4_RANGE_S = {
-    .base         = MPC_DDR4_RANGE_BASE_S,
-    .limit        = MPC_DDR4_RANGE_LIMIT_S,
-    .range_offset = 0,
+#define MPC_DDR4_RANGE_LIST_LEN  8u
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK0_RANGE_NS = {
+    .base         = MPC_DDR4_BLK0_RANGE_BASE_NS,
+    .limit        = MPC_DDR4_BLK0_RANGE_LIMIT_NS,
+    .range_offset = MPC_DDR4_BLK0_RANGE_OFFSET_NS,
+    .attr         = MPC_SIE_SEC_ATTR_NONSECURE
+};
+
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK1_RANGE_S = {
+    .base         = MPC_DDR4_BLK1_RANGE_BASE_S,
+    .limit        = MPC_DDR4_BLK1_RANGE_LIMIT_S,
+    .range_offset = MPC_DDR4_BLK1_RANGE_OFFSET_S,
     .attr         = MPC_SIE_SEC_ATTR_SECURE
 };
 
-static const struct mpc_sie_memory_range_t MPC_DDR4_RANGE_NS = {
-    .base         = MPC_DDR4_RANGE_BASE_NS,
-    .limit        = MPC_DDR4_RANGE_LIMIT_NS,
-    .range_offset = 0,
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK2_RANGE_NS = {
+    .base         = MPC_DDR4_BLK2_RANGE_BASE_NS,
+    .limit        = MPC_DDR4_BLK2_RANGE_LIMIT_NS,
+    .range_offset = MPC_DDR4_BLK2_RANGE_OFFSET_NS,
+    .attr         = MPC_SIE_SEC_ATTR_NONSECURE
+};
+
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK3_RANGE_S = {
+    .base         = MPC_DDR4_BLK3_RANGE_BASE_S,
+    .limit        = MPC_DDR4_BLK3_RANGE_LIMIT_S,
+    .range_offset = MPC_DDR4_BLK3_RANGE_OFFSET_S,
+    .attr         = MPC_SIE_SEC_ATTR_SECURE
+};
+
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK4_RANGE_NS = {
+    .base         = MPC_DDR4_BLK4_RANGE_BASE_NS,
+    .limit        = MPC_DDR4_BLK4_RANGE_LIMIT_NS,
+    .range_offset = MPC_DDR4_BLK4_RANGE_OFFSET_NS,
+    .attr         = MPC_SIE_SEC_ATTR_NONSECURE
+};
+
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK5_RANGE_S = {
+    .base         = MPC_DDR4_BLK5_RANGE_BASE_S,
+    .limit        = MPC_DDR4_BLK5_RANGE_LIMIT_S,
+    .range_offset = MPC_DDR4_BLK5_RANGE_OFFSET_S,
+    .attr         = MPC_SIE_SEC_ATTR_SECURE
+};
+
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK6_RANGE_NS = {
+    .base         = MPC_DDR4_BLK6_RANGE_BASE_NS,
+    .limit        = MPC_DDR4_BLK6_RANGE_LIMIT_NS,
+    .range_offset = MPC_DDR4_BLK6_RANGE_OFFSET_NS,
     .attr         = MPC_SIE_SEC_ATTR_NONSECURE
 };
 
-#define MPC_DDR4_RANGE_LIST_LEN  2u
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK7_RANGE_S = {
+    .base         = MPC_DDR4_BLK7_RANGE_BASE_S,
+    .limit        = MPC_DDR4_BLK7_RANGE_LIMIT_S,
+    .range_offset = MPC_DDR4_BLK7_RANGE_OFFSET_S,
+    .attr         = MPC_SIE_SEC_ATTR_SECURE
+};
+
 static const struct mpc_sie_memory_range_t*
     MPC_DDR4_RANGE_LIST[MPC_DDR4_RANGE_LIST_LEN] = {
-        &MPC_DDR4_RANGE_S,
-        &MPC_DDR4_RANGE_NS
+        &MPC_DDR4_BLK0_RANGE_NS,
+        &MPC_DDR4_BLK1_RANGE_S,
+        &MPC_DDR4_BLK2_RANGE_NS,
+        &MPC_DDR4_BLK3_RANGE_S,
+        &MPC_DDR4_BLK4_RANGE_NS,
+        &MPC_DDR4_BLK5_RANGE_S,
+        &MPC_DDR4_BLK6_RANGE_NS,
+        &MPC_DDR4_BLK7_RANGE_S,
     };
 
 /* DDR4_MPC Driver wrapper functions */
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_Flash.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_Flash.c
index 06d3546f0..fb32e14bd 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_Flash.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_Flash.c
@@ -26,9 +26,9 @@
 #define ARG_UNUSED(arg)  ((void)arg)
 #endif
 
-#define FLASH0_BASE_S         SRAM_BASE_S
-#define FLASH0_BASE_NS        SRAM_BASE_NS
-#define FLASH0_SIZE           SRAM_SIZE
+#define FLASH0_BASE_S         QSPI_SRAM_BASE_S
+#define FLASH0_BASE_NS        QSPI_SRAM_BASE_NS
+#define FLASH0_SIZE           QSPI_SRAM_SIZE
 #define FLASH0_SECTOR_SIZE    0x00001000 /* 4 kB */
 #define FLASH0_PAGE_SIZE      0x00001000 /* 4 kB */
 #define FLASH0_PROGRAM_UNIT   0x1        /* Minimum write size */
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/config/RTE_Device.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/config/RTE_Device.h
index ef808ce67..1437941b7 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/config/RTE_Device.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/config/RTE_Device.h
@@ -47,6 +47,11 @@
 #define   RTE_QSPI_MPC                   1
 // </e> MPC (Memory Protection Controller) [Driver_QSPI_MPC]
 
+// <e> MPC (Memory Protection Controller) [Driver_DDR4_MPC]
+// <i> Configuration settings for Driver_DDR4_MPC in component ::Drivers:MPC
+#define   RTE_DDR4_MPC                   1
+// </e> MPC (Memory Protection Controller) [Driver_DDR4_MPC]
+
 // <e> PPC (Peripheral Protection Controller) [PPC_SSE300_MAIN0]
 // <i> Configuration settings for Driver_PPC_SSE300_MAIN0 in component ::Drivers:PPC
 #define   RTE_PPC_SSE300_MAIN0             1
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/config/device_cfg.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/config/device_cfg.h
index 33a2b90a7..f8e5307e7 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/config/device_cfg.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/config/device_cfg.h
@@ -29,6 +29,9 @@
 #define MPC_ISRAM1_S
 #define MPC_SRAM_S
 #define MPC_QSPI_S
+#define MPC_DDR4_S
+
+#define MPC_DDR4_DEV MPC_DDR4_DEV_S
 
 /* ARM Peripheral Protection Controllers (PPC) */
 #define PPC_SSE300_MAIN0_S
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/device_definition.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/device_definition.h
index 58d38b959..754f8dd15 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/device_definition.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/device_definition.h
@@ -94,111 +94,56 @@ extern struct uart_cmsdk_dev_t UART5_CMSDK_DEV_NS;
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN0_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_MAIN0_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_MAIN0_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP0_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP0_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP0_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP0_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP1_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP1_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP1_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP1_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP2_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP2_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP2_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP2_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP3_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP3_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP3_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP3_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_PERIPH0_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH0_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_PERIPH0_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH0_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_PERIPH1_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH1_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_PERIPH1_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH1_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP0_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP0_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP0_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP0_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP1_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP1_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP1_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP1_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP2_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP2_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP2_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP2_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP3_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP3_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP3_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP3_DEV_NS;
-#endif
-
 /* System counters */
 #ifdef SYSCOUNTER_CNTRL_ARMV8_M_S
 #include "syscounter_armv8-m_cntrl_drv.h"
@@ -297,92 +242,6 @@ extern struct arm_mps3_io_dev_t MPS3_IO_DEV_S;
 extern struct arm_mps3_io_dev_t MPS3_IO_DEV_NS;
 #endif
 
-#ifdef SMSC9220_ETH_S
-#include "smsc9220_eth_drv.h"
-extern struct smsc9220_eth_dev_t SMSC9220_ETH_DEV_S;
-#endif
-
-#ifdef SMSC9220_ETH_NS
-#include "smsc9220_eth_drv.h"
-extern struct smsc9220_eth_dev_t SMSC9220_ETH_DEV_NS;
-#endif
-
-/* CMSDK GPIO driver structures */
-#ifdef GPIO0_CMSDK_S
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO0_CMSDK_DEV_S;
-#endif
-
-#ifdef GPIO0_CMSDK_NS
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO0_CMSDK_DEV_NS;
-#endif
-
-#ifdef GPIO1_CMSDK_S
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO1_CMSDK_DEV_S;
-#endif
-
-#ifdef GPIO1_CMSDK_NS
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO1_CMSDK_DEV_NS;
-#endif
-
-#ifdef GPIO2_CMSDK_S
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO2_CMSDK_DEV_S;
-#endif
-
-#ifdef GPIO2_CMSDK_NS
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO2_CMSDK_DEV_NS;
-#endif
-
-#ifdef GPIO3_CMSDK_S
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO3_CMSDK_DEV_S;
-#endif
-
-#ifdef GPIO3_CMSDK_NS
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO3_CMSDK_DEV_NS;
-#endif
-
-/* I2C_SBCon driver structures */
-#ifdef I2C0_SBCON_S
-#include "timeout.h"
-#include "i2c_sbcon_drv.h"
-extern struct i2c_sbcon_dev_t I2C0_SBCON_DEV_S;
-#endif
-
-#ifdef I2C0_SBCON_NS
-#include "timeout.h"
-#include "i2c_sbcon_drv.h"
-extern struct i2c_sbcon_dev_t I2C0_SBCON_DEV_NS;
-#endif
-
-/* I2S driver structures */
-#ifdef MPS3_I2S_S
-#include "audio_i2s_mps3_drv.h"
-extern struct audio_i2s_mps3_dev_t MPS3_I2S_DEV_S;
-#endif
-
-#ifdef MPS3_I2S_NS
-#include "audio_i2s_mps3_drv.h"
-extern struct audio_i2s_mps3_dev_t MPS3_I2S_DEV_NS;
-#endif
-
-/* TGU driver structure */
-#ifdef TGU_ARMV8_M_ITCM_S
-#include "tgu_armv8_m_drv.h"
-extern struct tgu_armv8_m_dev_t TGU_ARMV8_M_ITCM_DEV_S;
-#endif
-
-#ifdef TGU_ARMV8_M_DTCM_S
-#include "tgu_armv8_m_drv.h"
-extern struct tgu_armv8_m_dev_t TGU_ARMV8_M_DTCM_DEV_S;
-#endif
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/platform_regs.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/platform_regs.h
index cc24ec6f7..b7a609eb5 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/platform_regs.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/platform_regs.h
@@ -254,10 +254,10 @@ struct sse300_nsacfg_t {
 #define GPIO1_MAIN_PPCEXP0_POS_MASK             (1UL << 1)
 #define GPIO2_MAIN_PPCEXP0_POS_MASK             (1UL << 2)
 #define GPIO3_MAIN_PPCEXP0_POS_MASK             (1UL << 3)
+#define USB_AND_ETHERNET_MAIN_PPCEXP0_POS_MASK  (1UL << 4)
 #define USER_AHB0_MAIN_PPCEXP0_POS_MASK         (1UL << 5)
 #define USER_AHB1_MAIN_PPCEXP0_POS_MASK         (1UL << 6)
 #define USER_AHB2_MAIN_PPCEXP0_POS_MASK         (1UL << 7)
-#define USB_AND_ETHERNET_MAIN_PPCEXP0_POS_MASK  (1UL << 8)
 /* End MAIN PPCEXP0 peripherals definition */
 
 /* MAIN PPCEXP1 peripherals definition */
@@ -316,6 +316,7 @@ struct sse300_nsacfg_t {
 #define UART5_PERIPH_PPCEXP2_POS_MASK              (1UL << 8)
 #define CLCD_PERIPH_PPCEXP2_POS_MASK               (1UL << 10)
 #define RTC_PERIPH_PPCEXP2_POS_MASK                (1UL << 11)
+#define VSI_PERIPH_PPCEXP2_POS_MASK                (1UL << 12)
 /* End PERIPH PPCEXP2 peripherals definition */
 
 /* PERIPH PPCEXP3 peripherals definition */
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/device_definition.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/device_definition.c
index 431868751..4a18c1c82 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/device_definition.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/device_definition.c
@@ -230,18 +230,6 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN0_DEV_S = {
     &PPC_SSE300_MAIN0_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_MAIN0_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN0_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_MAIN0};
-static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN0_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_MAIN0_DEV_NS = {
-    &PPC_SSE300_MAIN0_CFG_NS,
-    &PPC_SSE300_MAIN0_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP0_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP0_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -258,18 +246,6 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP0_DEV_S = {
     &PPC_SSE300_MAIN_EXP0_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP0_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP0_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_MAIN_EXP0};
-static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN_EXP0_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP0_DEV_NS = {
-    &PPC_SSE300_MAIN_EXP0_CFG_NS,
-    &PPC_SSE300_MAIN_EXP0_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP1_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP1_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -286,18 +262,6 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP1_DEV_S = {
     &PPC_SSE300_MAIN_EXP1_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP1_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP1_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_MAIN_EXP1};
-static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN_EXP1_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP1_DEV_NS = {
-    &PPC_SSE300_MAIN_EXP1_CFG_NS,
-    &PPC_SSE300_MAIN_EXP1_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP2_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP2_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -314,18 +278,6 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP2_DEV_S = {
     &PPC_SSE300_MAIN_EXP2_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP2_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP2_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_MAIN_EXP2};
-static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN_EXP2_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP2_DEV_NS = {
-    &PPC_SSE300_MAIN_EXP2_CFG_NS,
-    &PPC_SSE300_MAIN_EXP2_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP3_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP3_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -342,18 +294,6 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP3_DEV_S = {
     &PPC_SSE300_MAIN_EXP3_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP3_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP3_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_MAIN_EXP3};
-static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN_EXP3_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP3_DEV_NS = {
-    &PPC_SSE300_MAIN_EXP3_CFG_NS,
-    &PPC_SSE300_MAIN_EXP3_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_PERIPH0_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH0_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -370,18 +310,6 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH0_DEV_S = {
     &PPC_SSE300_PERIPH0_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_PERIPH0_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH0_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_PERIPH0};
-static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH0_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_PERIPH0_DEV_NS = {
-    &PPC_SSE300_PERIPH0_CFG_NS,
-    &PPC_SSE300_PERIPH0_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_PERIPH1_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH1_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -398,18 +326,6 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH1_DEV_S = {
     &PPC_SSE300_PERIPH1_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_PERIPH1_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH1_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_PERIPH1};
-static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH1_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_PERIPH1_DEV_NS = {
-    &PPC_SSE300_PERIPH1_CFG_NS,
-    &PPC_SSE300_PERIPH1_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP0_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP0_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -426,18 +342,6 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP0_DEV_S = {
     &PPC_SSE300_PERIPH_EXP0_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP0_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP0_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_PERIPH_EXP0};
-static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH_EXP0_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP0_DEV_NS = {
-    &PPC_SSE300_PERIPH_EXP0_CFG_NS,
-    &PPC_SSE300_PERIPH_EXP0_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP1_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP1_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -454,18 +358,6 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP1_DEV_S = {
     &PPC_SSE300_PERIPH_EXP1_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP1_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP1_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_PERIPH_EXP1};
-static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH_EXP1_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP1_DEV_NS = {
-    &PPC_SSE300_PERIPH_EXP1_CFG_NS,
-    &PPC_SSE300_PERIPH_EXP1_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP2_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP2_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -482,18 +374,6 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP2_DEV_S = {
     &PPC_SSE300_PERIPH_EXP2_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP2_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP2_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_PERIPH_EXP2};
-static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH_EXP2_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP2_DEV_NS = {
-    &PPC_SSE300_PERIPH_EXP2_CFG_NS,
-    &PPC_SSE300_PERIPH_EXP2_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP3_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP3_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -510,18 +390,6 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP3_DEV_S = {
     &PPC_SSE300_PERIPH_EXP3_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP3_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP3_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_PERIPH_EXP3};
-static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH_EXP3_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP3_DEV_NS = {
-    &PPC_SSE300_PERIPH_EXP3_CFG_NS,
-    &PPC_SSE300_PERIPH_EXP3_DATA_NS };
-#endif
-
 /* System counters */
 #ifdef SYSCOUNTER_CNTRL_ARMV8_M_S
 
@@ -575,7 +443,7 @@ SYSCOUNTER_READ_ARMV8_M_DEV_CFG_NS = {
     .base = SYSCNTR_READ_BASE_NS,
 };
 struct syscounter_armv8_m_read_dev_t SYSCOUNTER_READ_ARMV8_M_DEV_NS = {
-    &(SYSCOUNTER_READ_ARMV8_M_DEV_CFG_NS),
+    &(SYSCOUNTER_CNTRL_ARMV8_M_DEV_CFG_NS),
 };
 #endif
 
@@ -807,171 +675,3 @@ struct arm_mps3_io_dev_t MPS3_IO_DEV_NS = {
     .cfg = &(MPS3_IO_DEV_CFG_NS)
 };
 #endif
-
-#ifdef SMSC9220_ETH_S
-static struct smsc9220_eth_dev_cfg_t SMSC9220_ETH_DEV_CFG_S = {
-    .base = ETHERNET_BASE_S
-};
-static struct smsc9220_eth_dev_data_t SMSC9220_ETH_DEV_DATA_S = {
-    .state = 0,
-    .wait_ms = 0,
-    .ongoing_packet_length = 0,
-    .ongoing_packet_length_sent = 0,
-    .current_rx_size_words = 0,
-};
-struct smsc9220_eth_dev_t SMSC9220_ETH_DEV_S = {
-    .cfg = &(SMSC9220_ETH_DEV_CFG_S),
-    .data = &(SMSC9220_ETH_DEV_DATA_S),
-};
-#endif
-
-#ifdef SMSC9220_ETH_NS
-static struct smsc9220_eth_dev_cfg_t SMSC9220_ETH_DEV_CFG_NS = {
-    .base = ETHERNET_BASE_NS
-};
-static struct smsc9220_eth_dev_data_t SMSC9220_ETH_DEV_DATA_NS = {
-    .state = 0,
-    .wait_ms = 0,
-    .ongoing_packet_length = 0,
-    .ongoing_packet_length_sent = 0,
-    .current_rx_size_words = 0,
-};
-struct smsc9220_eth_dev_t SMSC9220_ETH_DEV_NS = {
-    .cfg = &(SMSC9220_ETH_DEV_CFG_NS),
-    .data = &(SMSC9220_ETH_DEV_DATA_NS),
-};
-#endif
-
-/* CMSDK GPIO driver structures */
-#ifdef GPIO0_CMSDK_S
-static const struct gpio_cmsdk_dev_cfg_t GPIO0_CMSDK_DEV_CFG_S = {
-    .base = GPIO0_CMSDK_BASE_S};
-struct gpio_cmsdk_dev_t GPIO0_CMSDK_DEV_S = {&(GPIO0_CMSDK_DEV_CFG_S)};
-#endif
-
-#ifdef GPIO0_CMSDK_NS
-static const struct gpio_cmsdk_dev_cfg_t GPIO0_CMSDK_DEV_CFG_NS = {
-    .base = GPIO0_CMSDK_BASE_NS};
-struct gpio_cmsdk_dev_t GPIO0_CMSDK_DEV_NS = {&(GPIO0_CMSDK_DEV_CFG_NS)};
-#endif
-
-#ifdef GPIO1_CMSDK_S
-static const struct gpio_cmsdk_dev_cfg_t GPIO1_CMSDK_DEV_CFG_S = {
-    .base = GPIO1_CMSDK_BASE_S};
-struct gpio_cmsdk_dev_t GPIO1_CMSDK_DEV_S = {&(GPIO1_CMSDK_DEV_CFG_S)};
-#endif
-
-#ifdef GPIO1_CMSDK_NS
-static const struct gpio_cmsdk_dev_cfg_t GPIO1_CMSDK_DEV_CFG_NS = {
-    .base = GPIO1_CMSDK_BASE_NS};
-struct gpio_cmsdk_dev_t GPIO1_CMSDK_DEV_NS = {&(GPIO1_CMSDK_DEV_CFG_NS)};
-#endif
-
-#ifdef GPIO2_CMSDK_S
-static const struct gpio_cmsdk_dev_cfg_t GPIO2_CMSDK_DEV_CFG_S = {
-    .base = GPIO2_CMSDK_BASE_S};
-struct gpio_cmsdk_dev_t GPIO2_CMSDK_DEV_S = {&(GPIO2_CMSDK_DEV_CFG_S)};
-#endif
-
-#ifdef GPIO2_CMSDK_NS
-static const struct gpio_cmsdk_dev_cfg_t GPIO2_CMSDK_DEV_CFG_NS = {
-    .base = GPIO2_CMSDK_BASE_NS};
-struct gpio_cmsdk_dev_t GPIO2_CMSDK_DEV_NS = {&(GPIO2_CMSDK_DEV_CFG_NS)};
-#endif
-
-#ifdef GPIO3_CMSDK_S
-static const struct gpio_cmsdk_dev_cfg_t GPIO3_CMSDK_DEV_CFG_S = {
-    .base = GPIO3_CMSDK_BASE_S};
-struct gpio_cmsdk_dev_t GPIO3_CMSDK_DEV_S = {&(GPIO3_CMSDK_DEV_CFG_S)};
-#endif
-
-#ifdef GPIO3_CMSDK_NS
-static const struct gpio_cmsdk_dev_cfg_t GPIO3_CMSDK_DEV_CFG_NS = {
-    .base = GPIO3_CMSDK_BASE_NS};
-struct gpio_cmsdk_dev_t GPIO3_CMSDK_DEV_NS = {&(GPIO3_CMSDK_DEV_CFG_NS)};
-#endif
-
-/* I2C_SBCon driver structures */
-#ifdef I2C0_SBCON_S
-static struct i2c_sbcon_dev_cfg_t I2C0_SBCON_DEV_CFG_S = {
-    .base = FPGA_SBCon_I2C_AUDIO_BASE_S,
-    .default_freq_hz = 100000,
-    .sleep_us = &wait_us
-};
-static struct i2c_sbcon_dev_data_t I2C0_SBCON_DEV_DATA_S ={
-    .freq_us = 0,
-    .sys_clk = 0,
-    .state = 0
-};
-struct i2c_sbcon_dev_t I2C0_SBCON_DEV_S = {
-    .cfg = &(I2C0_SBCON_DEV_CFG_S),
-    .data = &(I2C0_SBCON_DEV_DATA_S)
-};
-#endif
-
-#ifdef I2C0_SBCON_NS
-static struct i2c_sbcon_dev_cfg_t I2C0_SBCON_DEV_CFG_NS = {
-    .base = FPGA_SBCon_I2C_AUDIO_BASE_NS,
-    .default_freq_hz = 100000,
-    .sleep_us = &wait_us
-};
-static struct i2c_sbcon_dev_data_t I2C0_SBCON_DEV_DATA_NS ={
-    .freq_us = 0,
-    .sys_clk = 0,
-    .state = 0
-};
-struct i2c_sbcon_dev_t I2C0_SBCON_DEV_NS = {
-    .cfg = &(I2C0_SBCON_DEV_CFG_NS),
-    .data = &(I2C0_SBCON_DEV_DATA_NS)
-};
-#endif
-
-/* I2S driver structures */
-#ifdef MPS3_I2S_S
-static const struct audio_i2s_mps3_dev_cfg_t MPS3_I2S_DEV_CFG_S = {
-    .base = FPGA_I2S_BASE_S
-};
-struct audio_i2s_mps3_dev_t MPS3_I2S_DEV_S = {
-    &(MPS3_I2S_DEV_CFG_S),
-};
-#endif
-
-#ifdef MPS3_I2S_NS
-static const struct audio_i2s_mps3_dev_cfg_t MPS3_I2S_DEV_CFG_NS = {
-    .base = FPGA_I2S_BASE_NS
-};
-struct audio_i2s_mps3_dev_t MPS3_I2S_DEV_NS = {
-    &(MPS3_I2S_DEV_CFG_NS),
-};
-#endif
-
-/* TGU driver structures */
-#ifdef TGU_ARMV8_M_ITCM_S
-static const struct tgu_armv8_m_dev_cfg_t TGU_ARMV8_M_ITCM_DEV_CFG_S = {
-    .base = ITGU_CTRL_BASE
-};
-static struct tgu_armv8_m_dev_data_t TGU_ARMV8_M_ITCM_DEV_DATA_S = {
-    .range_list = 0,
-    .nbr_of_ranges = 0,
-    .is_initialized = false
-};
-struct tgu_armv8_m_dev_t TGU_ARMV8_M_ITCM_DEV_S = {
-&(TGU_ARMV8_M_ITCM_DEV_CFG_S),
-&(TGU_ARMV8_M_ITCM_DEV_DATA_S),
-};
-#endif
-
-#ifdef TGU_ARMV8_M_DTCM_S
-static const struct tgu_armv8_m_dev_cfg_t TGU_ARMV8_M_DTCM_DEV_CFG_S = {
-    .base = DTGU_CTRL_BASE
-};
-static struct tgu_armv8_m_dev_data_t TGU_ARMV8_M_DTCM_DEV_DATA_S = {
-    .range_list = 0,
-    .nbr_of_ranges = 0,
-    .is_initialized = false,
-};
-struct tgu_armv8_m_dev_t TGU_ARMV8_M_DTCM_DEV_S = {
-&(TGU_ARMV8_M_DTCM_DEV_CFG_S),
-&(TGU_ARMV8_M_DTCM_DEV_DATA_S),
-};
-#endif
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/startup_an547_ns.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/startup_an547_ns.c
index 66d6ce144..290210578 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/startup_an547_ns.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/startup_an547_ns.c
@@ -172,6 +172,7 @@ DEFAULT_IRQ_HANDLER(GPIO3_3_Handler)
 DEFAULT_IRQ_HANDLER(UARTRX5_Handler)
 DEFAULT_IRQ_HANDLER(UARTTX5_Handler)
 DEFAULT_IRQ_HANDLER(UART5_Handler)
+DEFAULT_IRQ_HANDLER(ARM_VSI0_Handler)
 
 /*----------------------------------------------------------------------------
   Exception / Interrupt Vector table
@@ -182,6 +183,8 @@ DEFAULT_IRQ_HANDLER(UART5_Handler)
 #pragma GCC diagnostic ignored "-Wpedantic"
 #endif
 
+extern void arm_npu_irq_handler(void);
+
 extern const pFunc __VECTOR_TABLE[496];
        const pFunc __VECTOR_TABLE[496] __VECTOR_TABLE_ATTRIBUTE = {
   (pFunc)(&__MSP_INITIAL_SP),        /*      Initial Stack Pointer */
@@ -259,7 +262,7 @@ extern const pFunc __VECTOR_TABLE[496];
   SPI_ADC_Handler,                   /*  53: SPI ADC Handler */
   SPI_SHIELD0_Handler,               /*  54: SPI (Shield 0) Handler */
   SPI_SHIELD1_Handler,               /*  55: SPI (Shield 0) Handler */
-  ETHOS_U55_Handler,                 /*  56: Ethos-U55 Handler */
+  arm_npu_irq_handler,               /*  56: Ethos-U55 Handler */
   0,                                 /*  57: Reserved */
   0,                                 /*  58: Reserved */
   0,                                 /*  59: Reserved */
@@ -334,6 +337,100 @@ extern const pFunc __VECTOR_TABLE[496];
   0,                                 /*  128: Reserved */
   0,                                 /*  129: Reserved */
   0,                                 /*  130: Reserved */
+  0,                                /*  131: Reserved */
+  0,                                /*  132: Reserved */
+  0,                                /*  133: Reserved */
+  0,                                /*  134: Reserved */
+  0,                                /*  135: Reserved */
+  0,                                /*  136: Reserved */
+  0,                                /*  137: Reserved */
+  0,                                /*  138: Reserved */
+  0,                                /*  139: Reserved */
+  0,                                /*  140: Reserved */
+  0,                                /*  141: Reserved */
+  0,                                /*  142: Reserved */
+  0,                                /*  143: Reserved */
+  0,                                /*  144: Reserved */
+  0,                                /*  145: Reserved */
+  0,                                /*  146: Reserved */
+  0,                                /*  147: Reserved */
+  0,                                /*  148: Reserved */
+  0,                                /*  149: Reserved */
+  0,                                /*  150: Reserved */
+  0,                                /*  151: Reserved */
+  0,                                /*  152: Reserved */
+  0,                                /*  153: Reserved */
+  0,                                /*  154: Reserved */
+  0,                                /*  155: Reserved */
+  0,                                /*  156: Reserved */
+  0,                                /*  157: Reserved */
+  0,                                /*  158: Reserved */
+  0,                                /*  159: Reserved */
+  0,                                /*  160: Reserved */
+  0,                                /*  161: Reserved */
+  0,                                /*  162: Reserved */
+  0,                                /*  163: Reserved */
+  0,                                /*  164: Reserved */
+  0,                                /*  165: Reserved */
+  0,                                /*  166: Reserved */
+  0,                                /*  167: Reserved */
+  0,                                /*  168: Reserved */
+  0,                                /*  169: Reserved */
+  0,                                /*  170: Reserved */
+  0,                                /*  171: Reserved */
+  0,                                /*  172: Reserved */
+  0,                                /*  173: Reserved */
+  0,                                /*  174: Reserved */
+  0,                                /*  175: Reserved */
+  0,                                /*  176: Reserved */
+  0,                                /*  177: Reserved */
+  0,                                /*  178: Reserved */
+  0,                                /*  179: Reserved */
+  0,                                /*  180: Reserved */
+  0,                                /*  181: Reserved */
+  0,                                /*  182: Reserved */
+  0,                                /*  183: Reserved */
+  0,                                /*  184: Reserved */
+  0,                                /*  185: Reserved */
+  0,                                /*  186: Reserved */
+  0,                                /*  187: Reserved */
+  0,                                /*  188: Reserved */
+  0,                                /*  189: Reserved */
+  0,                                /*  190: Reserved */
+  0,                                /*  191: Reserved */
+  0,                                /*  192: Reserved */
+  0,                                /*  193: Reserved */
+  0,                                /*  194: Reserved */
+  0,                                /*  195: Reserved */
+  0,                                /*  196: Reserved */
+  0,                                /*  197: Reserved */
+  0,                                /*  198: Reserved */
+  0,                                /*  199: Reserved */
+  0,                                /*  200: Reserved */
+  0,                                /*  201: Reserved */
+  0,                                /*  202: Reserved */
+  0,                                /*  203: Reserved */
+  0,                                /*  204: Reserved */
+  0,                                /*  205: Reserved */
+  0,                                /*  206: Reserved */
+  0,                                /*  207: Reserved */
+  0,                                /*  208: Reserved */
+  0,                                /*  209: Reserved */
+  0,                                /*  210: Reserved */
+  0,                                /*  211: Reserved */
+  0,                                /*  212: Reserved */
+  0,                                /*  213: Reserved */
+  0,                                /*  214: Reserved */
+  0,                                /*  215: Reserved */
+  0,                                /*  216: Reserved */
+  0,                                /*  217: Reserved */
+  0,                                /*  218: Reserved */
+  0,                                /*  219: Reserved */
+  0,                                /*  220: Reserved */
+  0,                                /*  221: Reserved */
+  0,                                /*  222: Reserved */
+  0,                                /*  223: Reserved */
+  ARM_VSI0_Handler,                 /*  224: VSI 0 */
 };
 
 #if defined ( __GNUC__ )
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/startup_an547_s.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/startup_an547_s.c
index 5d914030b..66d6ce144 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/startup_an547_s.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/startup_an547_s.c
@@ -33,12 +33,15 @@ typedef void( *pFunc )( void );
   External References
  *----------------------------------------------------------------------------*/
 
-#define __MSP_INITIAL_SP              REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit)
-#define __MSP_STACK_LIMIT             REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base)
+#define __MSP_INITIAL_SP              REGION_NAME(Image$$, ARM_LIB_STACK_MSP, $$ZI$$Limit)
+#define __MSP_STACK_LIMIT             REGION_NAME(Image$$, ARM_LIB_STACK_MSP, $$ZI$$Base)
 
 extern uint32_t __MSP_INITIAL_SP;
 extern uint32_t __MSP_STACK_LIMIT;
 
+extern uint32_t __INITIAL_SP;
+extern uint32_t __STACK_LIMIT;
+
 extern void __PROGRAM_START(void) __NO_RETURN;
 
 /*----------------------------------------------------------------------------
@@ -345,6 +348,11 @@ void Reset_Handler(void)
   __set_MSPLIM((uint32_t)(&__MSP_STACK_LIMIT));
 
   SystemInit();                             /* CMSIS System Initialization */
-
+  __ASM volatile("MRS     R0, control\n"    /* Get control value */
+                 "ORR     R0, R0, #2\n"     /* Select switch to PSP */
+                 "MSR     control, R0\n"    /* Load control register */
+                 :
+                 :
+                 : "r0");
   __PROGRAM_START();                        /* Enter PreMain (C library entry point) */
 }
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/system_core_init.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/system_core_init.c
index 6fe49b325..4e576ed26 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/system_core_init.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/system_core_init.c
@@ -64,8 +64,19 @@ void SystemInit (void)
 
 #if (defined (__FPU_USED) && (__FPU_USED == 1U)) || \
     (defined (__ARM_FEATURE_MVE) && (__ARM_FEATURE_MVE == 1U))
+#if (TFM_SYSTEM_FP >= 1) || (TFM_SYSTEM_FP_NS >= 1)   
     SCB->CPACR |= ((3U << 10U*2U) |           /* enable CP10 Full Access */
                    (3U << 11U*2U)  );         /* enable CP11 Full Access */
+
+#if defined(TFM_LAZY_FP_NS) || defined(TFM_LAZY_FP)
+  /* Enable Lazy FP */
+  FPU->FPCCR |= FPU_FPCCR_LSPEN_Msk;
+#else
+  /* Disable Lazy FP */
+  FPU->FPCCR &= ~FPU_FPCCR_LSPEN_Msk;
+#endif /* TFM_LAZY_FP_NS */
+
+#endif /* TFM_SYSTEM_FP >= 1 || (TFM_SYSTEM_FP_NS >= 1) */                   
 #endif
 
 #ifdef UNALIGNED_SUPPORT_DISABLE
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/mpu_armv8m_drv.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/mpu_armv8m_drv.h
index 6bfb0b293..de51999c3 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/mpu_armv8m_drv.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/mpu_armv8m_drv.h
@@ -101,7 +101,7 @@ enum mpu_armv8m_error_t mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -112,7 +112,7 @@ enum mpu_armv8m_error_t mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev);
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -124,7 +124,7 @@ enum mpu_armv8m_error_t mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev);
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_cfg     MPU region config \ref mpu_armv8m_region_cfg_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -138,7 +138,7 @@ enum mpu_armv8m_error_t mpu_armv8m_region_enable(
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_nr            Region number
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/flash_layout.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/flash_layout.h
index 9b1413c9f..21f49bb24 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/flash_layout.h
@@ -19,17 +19,18 @@
 
 #include "platform_base_address.h"
 
+/* WARNING: Layout below has been moved to QSPI_SRAM and addresses so different now */
 /* Flash layout on AN547 with BL2 (multiple image boot):
  *
  * 0x0000_0000 Secure image     primary slot (384 KB)
- * 0x0006_0000 Non-secure image primary slot (384 KB)
+ * 0x0006_0000 Non-secure image primary slot (2 MB)
  * 0x000C_0000 Secure image     secondary slot (384 KB)
- * 0x0012_0000 Non-secure image secondary slot (384 KB)
- * 0x0018_0000 Scratch area (384 KB)
+ * 0x0012_0000 Non-secure image secondary slot (2 MB)
+ * 0x0018_0000 Scratch area (2 MB)
  * 0x001E_0000 Protected Storage Area (20 KB)
  * 0x001E_5000 Internal Trusted Storage Area (16 KB)
- * 0x001E_9000 OTP / NV counters  area (8 KB)
- * 0x001E_B000 Unused
+ * 0x001E_9000 NV counters area (4 KB)
+ * 0x001E_E800 Unused
  *
  * Flash layout on AN547 with BL2 (single image boot):
  *
@@ -43,8 +44,7 @@
  * 0x001C_0000 Protected Storage Area (20 KB)
  * 0x001C_5000 Internal Trusted Storage Area (16 KB)
  * 0x001C_9000 NV counters area (4 KB)
- * 0x001E_9000 OTP / NV counters  area (8 KB)
- * 0x001E_B000 Unused
+ * 0x001C_A000 Unused
  */
 
 
@@ -58,7 +58,7 @@
 
 /* Size of a Secure and of a Non-secure image */
 #define FLASH_S_PARTITION_SIZE          (0x60000) /* S  partition: 384 KB */
-#define FLASH_NS_PARTITION_SIZE         (0x60000) /* NS partition: 384 KB */
+#define FLASH_NS_PARTITION_SIZE         (0x200000) /* NS partition: 1MB */
 #define FLASH_MAX_PARTITION_SIZE        ((FLASH_S_PARTITION_SIZE >   \
                                           FLASH_NS_PARTITION_SIZE) ? \
                                          FLASH_S_PARTITION_SIZE :    \
@@ -67,11 +67,11 @@
 /* Sector size of the flash hardware; same as FLASH0_SECTOR_SIZE */
 #define FLASH_AREA_IMAGE_SECTOR_SIZE    (0x1000)     /* 4 KB */
 /* Same as FLASH0_SIZE */
-#define FLASH_TOTAL_SIZE                (SRAM_SIZE)  /* 2 MB */
+#define FLASH_TOTAL_SIZE                (QSPI_SRAM_SIZE)  /* 2 MB */
 
 /* Flash layout info for BL2 bootloader */
 /* Same as FLASH0_BASE_S */
-#define FLASH_BASE_ADDRESS              (SRAM_BASE_S)
+#define FLASH_BASE_ADDRESS              (QSPI_SRAM_BASE_S)
 
 /* Offset and size definitions of the flash partitions that are handled by the
  * bootloader. The image swapping is done between IMAGE_PRIMARY and
@@ -84,7 +84,7 @@
 #if !defined(MCUBOOT_IMAGE_NUMBER) || (MCUBOOT_IMAGE_NUMBER == 1)
 /* Secure + Non-secure image primary slot */
 #define FLASH_AREA_0_ID            (1)
-#define FLASH_AREA_0_OFFSET        (0)
+#define FLASH_AREA_0_OFFSET        (0)//(FLASH_AREA_BL2_OFFSET + FLASH_AREA_BL2_SIZE)//
 #define FLASH_AREA_0_SIZE          (FLASH_S_PARTITION_SIZE + \
                                     FLASH_NS_PARTITION_SIZE)
 /* Secure + Non-secure secondary slot */
@@ -107,7 +107,7 @@
 #elif (MCUBOOT_IMAGE_NUMBER == 2)
 /* Secure image primary slot */
 #define FLASH_AREA_0_ID            (1)
-#define FLASH_AREA_0_OFFSET        (0)
+#define FLASH_AREA_0_OFFSET        (0)//(FLASH_AREA_BL2_OFFSET + FLASH_AREA_BL2_SIZE)//
 #define FLASH_AREA_0_SIZE          (FLASH_S_PARTITION_SIZE)
 /* Non-secure image primary slot */
 #define FLASH_AREA_1_ID            (FLASH_AREA_0_ID + 1)
@@ -137,7 +137,7 @@
 
 /* mpc_init_cfg function in target_cfg.c expects that all the images can fit
  * in SRAM area. */
-#if ( FLASH_AREA_SCRATCH_OFFSET + FLASH_AREA_SCRATCH_SIZE > SRAM_SIZE)
+#if ( FLASH_AREA_SCRATCH_OFFSET + FLASH_AREA_SCRATCH_SIZE > QSPI_SRAM_SIZE)
 #error "Out of SRAM memory!"
 #endif
 
@@ -151,11 +151,10 @@
                                          FLASH_PS_AREA_SIZE)
 #define FLASH_ITS_AREA_SIZE             (0x4000)   /* 16 KB */
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* Offset and size definition in flash area used by assemble.py */
 #define SECURE_IMAGE_OFFSET             (0x0)
@@ -169,8 +168,6 @@
  * Name is defined in flash driver file: Driver_Flash.c
  */
 #define FLASH_DEV_NAME Driver_FLASH0
-/* Smallest flash programmable unit in bytes */
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x1)
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -212,11 +209,10 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x1)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18) /* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
 
 #endif /* __FLASH_LAYOUT_H__ */
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/region_defs.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/region_defs.h
index adda5e13d..568d227c3 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/region_defs.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/region_defs.h
@@ -28,9 +28,9 @@
 #define S_MSP_STACK_SIZE        (0x0000800)
 #define S_PSP_STACK_SIZE        (0x0000800)
 
-#define NS_HEAP_SIZE            (0x0001000)
-#define NS_MSP_STACK_SIZE       (0x0000400)
-#define NS_PSP_STACK_SIZE       (0x0000C00)
+#define NS_HEAP_SIZE            (0x0008000)
+#define NS_MSP_STACK_SIZE       (0x0000800)
+#define NS_PSP_STACK_SIZE       (0x0002000)
 
 /* This size of buffer is big enough to store an attestation
  * token produced by initial attestation service
@@ -76,19 +76,8 @@
 #define BL2_TRAILER_SIZE     (0xC00)
 #endif /* BL2 */
 
-#if (MCUBOOT_IMAGE_NUMBER == 1) && \
-    (NS_IMAGE_PRIMARY_PARTITION_OFFSET > S_IMAGE_PRIMARY_PARTITION_OFFSET)
-/* If secure image and nonsecure image are concatenated, and nonsecure image
- * locates at the higher memory range, then the secure image does not need
- * the trailer area.
- */
-#define IMAGE_S_CODE_SIZE \
-            (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE)
-#else
 #define IMAGE_S_CODE_SIZE \
             (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
-#endif
-
 #define IMAGE_NS_CODE_SIZE \
             (FLASH_NS_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
 
@@ -98,7 +87,7 @@
 #define S_IMAGE_PRIMARY_AREA_OFFSET \
              (S_IMAGE_PRIMARY_PARTITION_OFFSET + BL2_HEADER_SIZE)
 /* Secure Code stored in Code SRAM */
-#define S_CODE_START    ((SRAM_BASE_S) +  (S_IMAGE_PRIMARY_AREA_OFFSET))
+#define S_CODE_START    ((QSPI_SRAM_BASE_S) +  (S_IMAGE_PRIMARY_AREA_OFFSET))
 #define S_CODE_SIZE     (IMAGE_S_CODE_SIZE - CMSE_VENEER_REGION_SIZE)
 #define S_CODE_LIMIT    (S_CODE_START + S_CODE_SIZE - 1)
 
@@ -114,23 +103,23 @@
 #define NS_IMAGE_PRIMARY_AREA_OFFSET \
                         (NS_IMAGE_PRIMARY_PARTITION_OFFSET + BL2_HEADER_SIZE)
 /* Non-Secure Code stored in Code SRAM memory */
-#define NS_CODE_START   (SRAM_BASE_NS + (NS_IMAGE_PRIMARY_AREA_OFFSET))
+#define NS_CODE_START   (QSPI_SRAM_BASE_NS + (NS_IMAGE_PRIMARY_AREA_OFFSET))
 #define NS_CODE_SIZE    (IMAGE_NS_CODE_SIZE)
 #define NS_CODE_LIMIT   (NS_CODE_START + NS_CODE_SIZE - 1)
 
 /* Non-Secure Data stored in ISRAM0 */
 #define NS_DATA_START   (ISRAM0_BASE_NS)
-#define NS_DATA_SIZE    (ISRAM0_SIZE)
+#define NS_DATA_SIZE    (ISRAM0_SIZE + ISRAM1_SIZE)
 #define NS_DATA_LIMIT   (NS_DATA_START + NS_DATA_SIZE - 1)
 
 /* NS partition information is used for MPC and SAU configuration */
 #define NS_PARTITION_START \
-            ((SRAM_BASE_NS) + (NS_IMAGE_PRIMARY_PARTITION_OFFSET))
+            ((QSPI_SRAM_BASE_NS) + (NS_IMAGE_PRIMARY_PARTITION_OFFSET))
 #define NS_PARTITION_SIZE (FLASH_NS_PARTITION_SIZE)
 
 /* Secondary partition for new images in case of firmware upgrade */
 #define SECONDARY_PARTITION_START \
-            ((SRAM_BASE_NS) + (S_IMAGE_SECONDARY_PARTITION_OFFSET))
+            ((QSPI_SRAM_BASE_NS) + (S_IMAGE_SECONDARY_PARTITION_OFFSET))
 #define SECONDARY_PARTITION_SIZE (FLASH_S_PARTITION_SIZE + \
                                   FLASH_NS_PARTITION_SIZE)
 
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/plat_test.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/plat_test.c
index 46b792131..12bd4372e 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/plat_test.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/plat_test.c
@@ -11,8 +11,58 @@
 #include "tfm_plat_test.h"
 #include "device_definition.h"
 
+#define USERLED_MASK                (0x3)
+#define BTN_WAIT_INIT_COUNTER_VALUE (10000u)
 #define TIMER_RELOAD_VALUE          (SystemCoreClock)
 
+/**
+ * \brief Store the state of the mocked LED
+ *
+ * This variable have to be linked to the data section of the partition
+ * TFM_SP_CORE_TEST so that in case of in case of isolation within the secure
+ * domain the Core Test service can access it.
+ */
+uint32_t led_status
+    TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_CORE_TEST", "PSA-ROT")
+    = 0x02u;
+
+/**
+ * \brief Simulate user reaction time
+ */
+static void busy_wait_to_simulate_user(void)
+{
+    volatile uint32_t counter = BTN_WAIT_INIT_COUNTER_VALUE;
+
+    while (counter) {
+        --counter;
+    }
+}
+
+void tfm_plat_test_wait_user_button_pressed(void)
+{
+    busy_wait_to_simulate_user();
+}
+
+void tfm_plat_test_wait_user_button_released(void)
+{
+    busy_wait_to_simulate_user();
+}
+
+uint32_t tfm_plat_test_get_led_status(void)
+{
+    return led_status;
+}
+
+void tfm_plat_test_set_led_status(uint32_t status)
+{
+    led_status = status & USERLED_MASK;
+}
+
+uint32_t tfm_plat_test_get_userled_mask(void)
+{
+    return USERLED_MASK;
+}
+
 void tfm_plat_test_secure_timer_start(void)
 {
     syscounter_armv8_m_cntrl_init(&SYSCOUNTER_CNTRL_ARMV8_M_DEV_S);
diff --git a/tf-m.old/platform/ext/target/arm/mps3/an547/services/include/tfm_ioctl_api.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/services/include/tfm_ioctl_api.h
new file mode 100644
index 000000000..754e55490
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/services/include/tfm_ioctl_api.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2019, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#ifndef __TFM_IOCTL_API__
+#define __TFM_IOCTL_API__
+
+#include <limits.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include "tfm_api.h"
+#include "tfm_platform_api.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum tfm_platform_ioctl_reqest_types_t {
+    TFM_PLATFORM_IOCTL_MEMCPY_SERVICE,
+} tfm_platform_ioctl_reqest_types_t;
+
+typedef struct tfm_pin_service_args_t {
+    void* dest;
+    void* source;
+    uint32_t size;
+} tfm_pin_service_args_t;
+
+tfm_platform_gpio_port_read(uint32_t pin_mask, uint32_t *data,
+                            uint32_t *result);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __TFM_IOCTL_API__ */
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/services/src/tfm_platform_system.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/services/src/tfm_platform_system.c
index b9031a8b1..15bfc0055 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/services/src/tfm_platform_system.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/services/src/tfm_platform_system.c
@@ -8,6 +8,8 @@
 #include "tfm_platform_system.h"
 #include "target_cfg.h"
 #include "cmsis.h"
+#include "tfm_ioctl_api.h"
+#include "string.h"
 
 void tfm_platform_hal_system_reset(void)
 {
@@ -22,10 +24,14 @@ enum tfm_platform_err_t tfm_platform_hal_ioctl(tfm_platform_ioctl_req_t request,
                                                psa_invec  *in_vec,
                                                psa_outvec *out_vec)
 {
-    (void)request;
-    (void)in_vec;
     (void)out_vec;
 
+    if (request == TFM_PLATFORM_IOCTL_MEMCPY_SERVICE) {
+        tfm_pin_service_args_t* args = (tfm_pin_service_args_t*)in_vec;
+        memcpy(args->dest, args->source, args->size);
+        return TFM_PLATFORM_ERR_SUCCESS;
+    }
+
     /* Not needed for this platform */
     return TFM_PLATFORM_ERR_NOT_SUPPORTED;
 }
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/target_cfg.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/target_cfg.c
index 0f3507ba4..08c866e42 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/target_cfg.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/target_cfg.c
@@ -23,11 +23,7 @@
 #include "region_defs.h"
 #include "tfm_plat_defs.h"
 #include "region.h"
-
-// FIXME: needed for syscounter init hack
-#include "syscounter_armv8-m_cntrl_drv.h"
-#include "device_cfg.h"
-#include "device_definition.h"
+#include "platform_base_address.h"
 
 /* Throw out bus error when an access causes security violation */
 #define CMSDK_SECRESPCFG_BUS_ERR_MASK   (1UL << 0)
@@ -75,6 +71,7 @@ extern ARM_DRIVER_MPC Driver_ISRAM0_MPC;
 extern ARM_DRIVER_MPC Driver_ISRAM1_MPC;
 extern ARM_DRIVER_MPC Driver_SRAM_MPC;
 extern ARM_DRIVER_MPC Driver_QSPI_MPC;
+extern ARM_DRIVER_MPC Driver_DDR4_MPC;
 
 /* Import PPC drivers */
 extern DRIVER_PPC_SSE300 Driver_PPC_SSE300_MAIN0;
@@ -121,6 +118,13 @@ struct platform_data_t tfm_peripheral_std_uart = {
         -1
 };
 
+struct platform_data_t tfm_peripheral_fpga_io = {
+        FPGA_IO_BASE_S,
+        FPGA_IO_BASE_S + 0xFFF,
+        PPC_SP_PERIPH_EXP2,
+        FPGA_IO_PERIPH_PPCEXP2_POS_MASK
+};
+
 struct platform_data_t tfm_peripheral_timer0 = {
         SYSTIMER0_ARMV8_M_BASE_S,
         SYSTIMER0_ARMV8_M_BASE_S + 0xFFF,
@@ -215,6 +219,17 @@ enum tfm_plat_err_t nvic_interrupt_enable(void)
         ERROR_MSG("Failed to Enable MPC interrupt for ISRAM0!");
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
+    ret = Driver_ISRAM1_MPC.EnableInterrupt();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Enable MPC interrupt for ISRAM1!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    ret = Driver_DDR4_MPC.EnableInterrupt();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Enable MPC interrupt for DDR4!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
 
     ret = Driver_SRAM_MPC.EnableInterrupt();
     if (ret != ARM_DRIVER_OK) {
@@ -222,6 +237,12 @@ enum tfm_plat_err_t nvic_interrupt_enable(void)
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
+    ret = Driver_QSPI_MPC.EnableInterrupt();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Enable MPC interrupt for QSPI!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
     NVIC_ClearPendingIRQ(MPC_IRQn);
     NVIC_EnableIRQ(MPC_IRQn);
 
@@ -292,17 +313,17 @@ void sau_and_idau_cfg(void)
     /* Enables SAU */
     TZ_SAU_Enable();
 
-    /* Configures SAU regions to be non-secure */
     SAU->RNR  = 0;
+    SAU->RBAR = (ISRAM0_BASE_NS & SAU_RBAR_BADDR_Msk);
+    SAU->RLAR = ((ISRAM0_BASE_NS + ISRAM0_SIZE + ISRAM1_SIZE - 1) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
+
+    /* Configures SAU regions to be non-secure */
+    SAU->RNR  = 1;
     SAU->RBAR = (memory_regions.non_secure_partition_base
                  & SAU_RBAR_BADDR_Msk);
     SAU->RLAR = (memory_regions.non_secure_partition_limit
                   & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 
-    SAU->RNR  = 1;
-    SAU->RBAR = (NS_DATA_START & SAU_RBAR_BADDR_Msk);
-    SAU->RLAR = (NS_DATA_LIMIT & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
-
     /* Configures veneers region to be non-secure callable */
     SAU->RNR  = 2;
     SAU->RBAR = (memory_regions.veneer_base & SAU_RBAR_BADDR_Msk);
@@ -322,8 +343,26 @@ void sau_and_idau_cfg(void)
     SAU->RLAR = (memory_regions.secondary_partition_limit
                  & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 
+    /* steal data memory from QSPI end */
+    SAU->RNR = 5;
+    SAU->RBAR = (0x28700000 & SAU_RBAR_BADDR_Msk);
+    SAU->RLAR = ((0x28800000 - 1)
+        & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
+
+    SAU->RNR = 6;
+    SAU->RBAR = (DDR4_BLK0_BASE_NS & SAU_RBAR_BADDR_Msk);
+    SAU->RLAR = ((DDR4_BLK0_BASE_NS + DDR4_BLK_SIZE - 1)
+        & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
+
+    SAU->RNR = 7;
+    SAU->RBAR = (DDR4_BLK2_BASE_NS & SAU_RBAR_BADDR_Msk);
+    SAU->RLAR = ((DDR4_BLK2_BASE_NS + DDR4_BLK_SIZE - 1)
+        & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
+
+
+
     /* Allows SAU to define the CODE region as a NSC */
-    sacfg->nsccfg |= CODENSC;
+    sacfg->nsccfg |= RAMNSC;
 }
 
 /*------------------- Memory configuration functions -------------------------*/
@@ -338,43 +377,94 @@ enum tfm_plat_err_t mpc_init_cfg(void)
         ERROR_MSG("Failed to Initialize MPC for ISRAM0!");
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
-    ret = Driver_ISRAM0_MPC.ConfigRegion(MPC_ISRAM0_RANGE_BASE_NS,
-                                      MPC_ISRAM0_RANGE_LIMIT_NS,
-                                      ARM_MPC_ATTR_NONSECURE);
+    ret = Driver_ISRAM0_MPC.ConfigRegion(ISRAM0_BASE_NS,
+                                         ISRAM0_BASE_NS + ISRAM0_SIZE - 1,
+                                         ARM_MPC_ATTR_NONSECURE);
     if (ret != ARM_DRIVER_OK) {
         ERROR_MSG("Failed to Configure MPC for ISRAM0!");
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
+    ret = Driver_ISRAM1_MPC.Initialize();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Initialize MPC for ISRAM1!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+    ret = Driver_ISRAM1_MPC.ConfigRegion(ISRAM1_BASE_NS,
+                                         ISRAM1_BASE_NS + ISRAM1_SIZE - 1,
+                                         ARM_MPC_ATTR_NONSECURE);
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Configure MPC for ISRAM1!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    ret = Driver_SRAM_MPC.Initialize();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Initialize MPC for SRAM!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+    ret = Driver_SRAM_MPC.ConfigRegion(MPC_SRAM_RANGE_BASE_NS,
+                                         MPC_SRAM_RANGE_LIMIT_NS,
+                                         ARM_MPC_ATTR_NONSECURE);
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Configure MPC for SRAM!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
     /* Configuring primary and secondary non-secure partition.
      * It is ensured in flash_layout.h that these memory regions are located in
      * SRAM SRAM device. */
-    ret = Driver_SRAM_MPC.Initialize();
+    ret = Driver_QSPI_MPC.Initialize();
     if (ret != ARM_DRIVER_OK) {
-        ERROR_MSG("Failed to Initialize MPC for SRAM!");
+        ERROR_MSG("Failed to Initialize MPC for QSPI!");
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
-    ret = Driver_SRAM_MPC.ConfigRegion(
+    ret = Driver_QSPI_MPC.ConfigRegion(
                                       memory_regions.non_secure_partition_base,
                                       memory_regions.non_secure_partition_limit,
                                       ARM_MPC_ATTR_NONSECURE);
     if (ret != ARM_DRIVER_OK) {
-        ERROR_MSG("Failed to Configure MPC for SRAM!");
+        ERROR_MSG("Failed to Configure MPC for QSPI!");
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
-    ret = Driver_SRAM_MPC.ConfigRegion(
-                                      memory_regions.secondary_partition_base,
-                                      memory_regions.secondary_partition_limit,
-                                      ARM_MPC_ATTR_NONSECURE);
+    ret = Driver_QSPI_MPC.ConfigRegion(
+        0x28700000, /* steal data memory from QSPI end */
+        0x28800000-1,
+        ARM_MPC_ATTR_NONSECURE);
     if (ret != ARM_DRIVER_OK) {
-        ERROR_MSG("Failed to Configure MPC for SRAM!");
+        ERROR_MSG("Failed to Configure MPC for QSPI!");
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
+    ret = Driver_DDR4_MPC.Initialize();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Initialize MPC for DDR4!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+    ret = Driver_DDR4_MPC.ConfigRegion(DDR4_BLK0_BASE_NS,
+                                       DDR4_BLK0_BASE_NS + DDR4_BLK_SIZE - 1,
+                                       ARM_MPC_ATTR_NONSECURE);
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Configure MPC for DDR4!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+    /* second init just like memtest */
+    ret = Driver_DDR4_MPC.Initialize();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Initialize MPC for DDR4!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+    ret = Driver_DDR4_MPC.ConfigRegion(DDR4_BLK2_BASE_NS,
+                                       DDR4_BLK2_BASE_NS + DDR4_BLK_SIZE - 1,
+                                       ARM_MPC_ATTR_NONSECURE);
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Configure MPC for DDR4!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
 
     /* Lock down not used MPC's */
-    Driver_QSPI_MPC.LockDown();
-    Driver_ISRAM1_MPC.LockDown();
+    //Driver_QSPI_MPC.LockDown();
+    //Driver_ISRAM1_MPC.LockDown();
 
     /* SRAM and ISRAM0 MPCs left unlocked as they are not reset if NVIC system
      * reset asserted.
@@ -391,12 +481,20 @@ enum tfm_plat_err_t mpc_init_cfg(void)
 
 void mpc_revert_non_secure_to_secure_cfg(void)
 {
-    Driver_ISRAM0_MPC.ConfigRegion(MPC_ISRAM0_RANGE_BASE_S,
-                                   MPC_ISRAM0_RANGE_LIMIT_S,
+    Driver_ISRAM0_MPC.ConfigRegion(ISRAM0_BASE_NS,
+                                   ISRAM1_SIZE,
+                                   ARM_MPC_ATTR_SECURE);
+
+    Driver_ISRAM1_MPC.ConfigRegion(ISRAM1_BASE_NS,
+                                   ISRAM1_SIZE,
                                    ARM_MPC_ATTR_SECURE);
 
-    Driver_SRAM_MPC.ConfigRegion(MPC_SRAM_RANGE_BASE_S,
-                                 MPC_SRAM_RANGE_LIMIT_S,
+    Driver_DDR4_MPC.ConfigRegion(DDR4_BLK0_BASE_NS,
+                                 DDR4_BLK0_BASE_NS + DDR4_BLK_SIZE - 1,
+                                 ARM_MPC_ATTR_SECURE);
+
+    Driver_QSPI_MPC.ConfigRegion(MPC_QSPI_RANGE_BASE_S,
+                                 MPC_QSPI_RANGE_LIMIT_S,
                                  ARM_MPC_ATTR_SECURE);
 
     /* Add barriers to assure the MPC configuration is done before continue
@@ -409,7 +507,10 @@ void mpc_revert_non_secure_to_secure_cfg(void)
 void mpc_clear_irq(void)
 {
     Driver_ISRAM0_MPC.ClearInterrupt();
+    Driver_ISRAM1_MPC.ClearInterrupt();
     Driver_SRAM_MPC.ClearInterrupt();
+    Driver_QSPI_MPC.ClearInterrupt();
+    Driver_DDR4_MPC.ClearInterrupt();
 }
 
 /*------------------- PPC configuration functions -------------------------*/
@@ -506,6 +607,9 @@ enum tfm_plat_err_t ppc_init_cfg(void)
     err |= Driver_PPC_SSE300_PERIPH_EXP2.ConfigSecurity(
                                         CLCD_PERIPH_PPCEXP2_POS_MASK,
                                         PPC_SSE300_NONSECURE_CONFIG);
+    err |= Driver_PPC_SSE300_PERIPH_EXP2.ConfigSecurity(
+                                        VSI_PERIPH_PPCEXP2_POS_MASK,
+                                        PPC_SSE300_NONSECURE_CONFIG);
 
     /* Grant un-privileged access for UART0 in NS domain */
     err |= Driver_PPC_SSE300_PERIPH_EXP2.ConfigPrivilege(
@@ -513,17 +617,6 @@ enum tfm_plat_err_t ppc_init_cfg(void)
                                         PPC_SSE300_NONSECURE_CONFIG,
                                         PPC_SSE300_PRIV_AND_NONPRIV_CONFIG);
 
-    err |= Driver_PPC_SSE300_MAIN_EXP0.ConfigPrivilege(
-                                        USB_AND_ETHERNET_MAIN_PPCEXP0_POS_MASK,
-                                        PPC_SSE300_NONSECURE_CONFIG,
-                                        PPC_SSE300_PRIV_AND_NONPRIV_CONFIG);
-    // err |= Driver_PPC_SSE300_MAIN_EXP0.ConfigPrivilege(
-    //                                     USB_AND_ETHERNET_MAIN_PPCEXP0_POS_MASK,
-    //                                     PPC_SSE300_NONSECURE_CONFIG,
-    //                                     PPC_SSE300_PRIV_AND_NONPRIV_CONFIG);
-
-    syscounter_armv8_m_cntrl_init(&SYSCOUNTER_CNTRL_ARMV8_M_DEV);
-
     /* Initialize not used PPC drivers */
     err |= Driver_PPC_SSE300_MAIN0.Initialize();
     err |= Driver_PPC_SSE300_MAIN_EXP2.Initialize();
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/tfm_hal_isolation.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/tfm_hal_isolation.c
index 20c1c0510..419ad0fe0 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/tfm_hal_isolation.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/tfm_hal_isolation.c
@@ -33,8 +33,8 @@ REGION_DECLARE(Image$$, TFM_APP_CODE_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_CODE_END, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_END, $$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Base);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
 #ifdef TFM_SP_META_PTR_ENABLE
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Base);
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
@@ -70,8 +70,8 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     /* NSPM PSP */
     {
         MPU_REGION_NS_STACK,
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Base),
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Limit),
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base),
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit),
         MPU_ARMV8M_MAIR_ATTR_DATA_IDX,
         MPU_ARMV8M_XN_EXEC_NEVER,
         MPU_ARMV8M_AP_RW_PRIV_UNPRIV,
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/tfm_peripherals_def.h
index 4a25910ea..1c00be592 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/tfm_peripherals_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  * Copyright (c) 2020, Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -21,9 +21,11 @@ extern "C" {
 struct platform_data_t;
 
 extern struct platform_data_t tfm_peripheral_std_uart;
+extern struct platform_data_t tfm_peripheral_fpga_io;
 extern struct platform_data_t tfm_peripheral_timer0;
 
 #define TFM_PERIPHERAL_STD_UART  (&tfm_peripheral_std_uart)
+#define TFM_PERIPHERAL_FPGA_IO   (&tfm_peripheral_fpga_io)
 #define TFM_PERIPHERAL_TIMER0    (&tfm_peripheral_timer0)
 
 #ifdef PSA_API_TEST_IPC
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/Device/Source/armclang/startup_musca_b1_secure_enclave_s.s b/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/Device/Source/armclang/startup_musca_b1_secure_enclave_s.s
index 6739a30e9..27f1b1778 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/Device/Source/armclang/startup_musca_b1_secure_enclave_s.s
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/Device/Source/armclang/startup_musca_b1_secure_enclave_s.s
@@ -26,6 +26,7 @@
 ;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
 ; </h>
 
+                IMPORT |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|
                 IMPORT |Image$$ARM_LIB_STACK$$ZI$$Limit|
 
 ; Vector Table Mapped to Address 0 at Reset
@@ -37,7 +38,7 @@
                 EXPORT  __Vectors_Size
 
 __Vectors       ;Core Interrupts
-                DCD     |Image$$ARM_LIB_STACK$$ZI$$Limit|    ; Top of Stack
+                DCD     |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|    ; Top of Stack
                 DCD      Reset_Handler                       ;     Reset Handler
                 DCD      NMI_Handler                         ; -14 NMI Handler
                 DCD      HardFault_Handler                   ; -13 Hard Fault Handler
@@ -102,6 +103,14 @@ Reset_Handler   PROC
                 LDR     R0, =SystemInit
                 BLX     R0
 
+                MRS     R0, control    ; Get control value
+                MOVS    R1, #2
+                ORRS    R0, R0, R1     ; Select switch to PSP
+                MSR     control, R0
+
+                LDR     R0, =|Image$$ARM_LIB_STACK$$ZI$$Limit|
+                MSR     PSP, R0
+
                 LDR     R0, =__main
                 BX      R0
                 ENDP
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/Device/Source/gcc/startup_musca_b1_secure_enclave_s.S b/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/Device/Source/gcc/startup_musca_b1_secure_enclave_s.S
index a62adbf7a..bd4c1d956 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/Device/Source/gcc/startup_musca_b1_secure_enclave_s.S
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/Device/Source/gcc/startup_musca_b1_secure_enclave_s.S
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2009-2021 Arm Limited. All rights reserved.
+; * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -26,7 +26,7 @@
     .align 2
     .globl    __Vectors
 __Vectors:
-    .long    Image$$ARM_LIB_STACK$$ZI$$Limit   /* Top of Stack */
+    .long    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit   /* Top of Stack */
     .long    Reset_Handler                     /*     Reset Handler */
     .long    NMI_Handler                       /* -14 NMI Handler */
     .long    HardFault_Handler                 /* -13 Hard Fault Handler */
@@ -216,6 +216,13 @@ Reset_Handler:
 
     bl    SystemInit
 
+    mrs     r0, control    /* Get control value */
+    movs    r1, #2
+    orrs    r0, r0, r1     /* Select switch to PSP */
+    msr     control, r0
+    ldr     r0, =Image$$ARM_LIB_STACK$$ZI$$Limit
+    msr     psp, r0
+
 #ifndef __START
 #define __START _start
 #endif
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/boot_hal.c b/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/boot_hal.c
index 600cd5590..5673bd014 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/boot_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/boot_hal.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -14,7 +14,8 @@
 #include "flash_layout.h"
 #include "bootutil/fault_injection_hardening.h"
 
-#ifdef CRYPTO_HW_ACCELERATOR
+#if defined(CRYPTO_HW_ACCELERATOR) || \
+    defined(CRYPTO_HW_ACCELERATOR_OTP_PROVISIONING)
 #include "crypto_hw.h"
 #endif
 
@@ -62,6 +63,24 @@ int32_t boot_platform_init(void)
     }
 #endif /* CRYPTO_HW_ACCELERATOR */
 
+/* This is a workaround to program the TF-M related cryptographic keys
+ * to CC312 OTP memory. This functionality is independent from secure boot,
+ * this is usually done on the factory floor during chip manufacturing.
+ */
+#ifdef CRYPTO_HW_ACCELERATOR_OTP_PROVISIONING
+    printf("OTP provisioning started.");
+    result = crypto_hw_accelerator_otp_provisioning();
+    if (result) {
+        printf("OTP provisioning FAILED: 0x%X", result);
+        return 1;
+    } else {
+        printf("OTP provisioning succeeded. TF-M won't be loaded.");
+
+        /* We don't need to boot - the only aim is provisioning. */
+        while (1);
+    }
+#endif /* CRYPTO_HW_ACCELERATOR_OTP_PROVISIONING */
+
     return 0;
 }
 
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/partition/flash_layout.h b/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/partition/flash_layout.h
index 34de373f9..10c131b28 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/partition/flash_layout.h
@@ -37,8 +37,8 @@
  * SSE-200 BL0 (128 KiB)                           0x1A000000       N/A
  * SE MCUBoot (128 KiB)                            0x1A020000       0x00000000
  * Internal Trusted Storage Area (32 KiB)          0x1A040000       N/A
- * OTP / NV counter area (8  KiB)                  0x1A048000       N/A
- * Unused (208 KiB)                                0x1A04A000       N/A
+ * NV counters area (16 KiB)                       0x1A048000       N/A
+ * Unused (196 KiB)                                0x1A04C000       N/A
  *
  * eFlash 1:
  * SE TF-M image          primary slot (384 KiB)   0x1A200000       0x38000000
@@ -132,8 +132,6 @@
  * Name is defined in flash driver file: Driver_Flash.c
  */
 #define FLASH_DEV_NAME Driver_EFLASH1
-/* Smallest flash programmable unit in bytes */
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x4)
 
 
 /* Assets in eFlash0 */
@@ -152,11 +150,11 @@
                                          FLASH_AREA_BL2_SIZE)
 #define FLASH_ITS_AREA_SIZE             (2 * FLASH_AREA_IMAGE_SECTOR_SIZE)
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
+
 
 /* Internal Trusted Storage (ITS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -177,12 +175,13 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x4)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define NV_COUNTERS_FLASH_DEV_NAME Driver_EFLASH0
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18) /* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_NV_COUNTERS_AREA_SIZE
+
 
 /* Protected Storage (PS) Service definitions. PS is placed in QSPI flash */
 #define FLASH_PS_AREA_OFFSET            (0x0)
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Device/Source/armclang/startup_cmsdk_musca_s.s b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Device/Source/armclang/startup_cmsdk_musca_s.s
index c904dfc05..fe00a7f57 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Device/Source/armclang/startup_cmsdk_musca_s.s
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Device/Source/armclang/startup_cmsdk_musca_s.s
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2009-2021 Arm Limited
+; * Copyright (c) 2009-2019 Arm Limited
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -26,7 +26,7 @@
 ;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
 ; </h>
 
-                IMPORT |Image$$ARM_LIB_STACK$$ZI$$Limit|
+                IMPORT |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|
 
 ; Vector Table Mapped to Address 0 at Reset
 
@@ -36,7 +36,7 @@
                 EXPORT  __Vectors_Size
 
 __Vectors       ;Core Interrupts
-                DCD     |Image$$ARM_LIB_STACK$$ZI$$Limit|  ; Top of Stack
+                DCD     |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|  ; Top of Stack
                 DCD     Reset_Handler                  ; Reset Handler
                 DCD     NMI_Handler                    ; NMI Handler
                 DCD     HardFault_Handler              ; Hard Fault Handler
@@ -145,6 +145,9 @@ Reset_Handler   PROC
                 CPSID   i              ; Disable IRQs
                 LDR     R0, =SystemInit
                 BLX     R0
+                MRS     R0, control    ; Get control value
+                ORR     R0, R0, #2     ; Select switch to PSP
+                MSR     control, R0
                 LDR     R0, =__main
                 BX      R0
                 ENDP
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Device/Source/device_definition.c b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Device/Source/device_definition.c
index e0e1968df..ec30705dc 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Device/Source/device_definition.c
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Device/Source/device_definition.c
@@ -365,17 +365,17 @@ struct uart_pl011_dev_t UART1_PL011_DEV_NS = {&(UART1_PL011_DEV_CFG_NS),
 /** CMSDK Timers driver structures */
 #ifdef CMSDK_TIMER0_S
 static const struct timer_cmsdk_dev_cfg_t CMSDK_TIMER0_DEV_CFG_S
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
 #endif
     = {.base = MUSCA_B1_CMSDK_TIMER0_S_BASE};
 static struct timer_cmsdk_dev_data_t CMSDK_TIMER0_DEV_DATA_S
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
 #endif
     = {.is_initialized = 0};
 struct timer_cmsdk_dev_t CMSDK_TIMER0_DEV_S
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
 #endif
     = {&(CMSDK_TIMER0_DEV_CFG_S), &(CMSDK_TIMER0_DEV_DATA_S)};
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Device/Source/gcc/startup_cmsdk_musca_s.S b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Device/Source/gcc/startup_cmsdk_musca_s.S
index 226f7ed2c..639ce0b74 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Device/Source/gcc/startup_cmsdk_musca_s.S
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Device/Source/gcc/startup_cmsdk_musca_s.S
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2009-2021 Arm Limited
+; * Copyright (c) 2009-2020 Arm Limited
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -26,7 +26,7 @@
     .align 2
     .globl    __Vectors
 __Vectors:
-    .long    Image$$ARM_LIB_STACK$$ZI$$Limit   /* Top of Stack */
+    .long    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit   /* Top of Stack */
     .long    Reset_Handler         /* Reset Handler */
     .long    NMI_Handler           /* NMI Handler */
     .long    HardFault_Handler     /* Hard Fault Handler */
@@ -253,6 +253,12 @@ Reset_Handler:
     cpsid   i              /* Disable IRQs */
     bl    SystemInit
 
+    mrs     r0, control    /* Get control value */
+    orr     r0, r0, #2     /* Select switch to PSP */
+    msr     control, r0
+    ldr     r0, =Image$$ARM_LIB_STACK$$ZI$$Limit
+    msr     psp, r0
+
 #ifndef __START
 #define __START _start
 #endif
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Native_Driver/mpu_armv8m_drv.h b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Native_Driver/mpu_armv8m_drv.h
index 9244cdf2b..d427604f3 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Native_Driver/mpu_armv8m_drv.h
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/Native_Driver/mpu_armv8m_drv.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2019, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -91,7 +91,7 @@ enum mpu_armv8m_error_t mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -102,7 +102,7 @@ enum mpu_armv8m_error_t mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev);
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -114,7 +114,7 @@ enum mpu_armv8m_error_t mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev);
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_cfg     MPU region config \ref mpu_armv8m_region_cfg_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -128,7 +128,7 @@ enum mpu_armv8m_error_t mpu_armv8m_region_enable(
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_nr            Region number
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
diff --git a/tf-m.old/platform/ext/target/arm/musca_b1/sse_200/attest_hal.c b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/attest_hal.c
new file mode 100644
index 000000000..8f746446a
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/attest_hal.c
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#include <stddef.h>
+#include <stdint.h>
+#include "tfm_attest_hal.h"
+#include "tfm_plat_boot_seed.h"
+#include "tfm_plat_device_id.h"
+
+#ifdef CRYPTO_HW_ACCELERATOR
+#include "crypto_hw.h"
+#include "mbedtls_cc_mng_int.h"
+#endif /* CRYPTO_HW_ACCELERATOR */
+
+/*!
+ * \def BOOT_SEED
+ *
+ * \brief Fixed value for boot seed used for test.
+ */
+#define BOOT_SEED   0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, \
+                    0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, \
+                    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, \
+                    0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF
+
+static const uint8_t boot_seed[BOOT_SEED_SIZE] = {BOOT_SEED};
+
+/* Example verification service URL for initial attestation token */
+static const char verification_service_url[] = "www.trustedfirmware.org";
+
+/* Example profile definition document for initial attestation token */
+static const char attestation_profile_definition[] = "PSA_IOT_PROFILE_1";
+
+static const uint8_t implementation_id[] = {
+    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
+    0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
+    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
+    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
+};
+
+static const uint8_t example_ean_13[] = "060456527282910010";
+
+#ifdef CRYPTO_HW_ACCELERATOR
+static enum tfm_security_lifecycle_t
+map_cc312_to_tfm_lifecycle(uint32_t cc312_lcs)
+{
+    enum tfm_security_lifecycle_t tfm_lcs;
+
+    if (cc312_lcs == CC_MNG_LCS_CM) {
+        tfm_lcs = TFM_SLC_ASSEMBLY_AND_TEST;
+    } else if (cc312_lcs == CC_MNG_LCS_DM) {
+        tfm_lcs = TFM_SLC_PSA_ROT_PROVISIONING;
+    } else if (cc312_lcs == CC_MNG_LCS_SEC_ENABLED) {
+        tfm_lcs = TFM_SLC_SECURED;
+    } else if (cc312_lcs == CC_MNG_LCS_RMA) {
+        tfm_lcs = TFM_SLC_DECOMMISSIONED;
+    } else {
+        tfm_lcs = TFM_SLC_UNKNOWN;
+    }
+
+    return tfm_lcs;
+}
+#endif
+
+enum tfm_security_lifecycle_t tfm_attest_hal_get_security_lifecycle(void)
+{
+#ifdef CRYPTO_HW_ACCELERATOR
+    int rc;
+    uint32_t cc312_lcs;
+    enum tfm_security_lifecycle_t tfm_lcs;
+
+    rc = crypto_hw_accelerator_get_lcs(&cc312_lcs);
+    if (rc) {
+        return TFM_SLC_UNKNOWN;
+    }
+
+    tfm_lcs = map_cc312_to_tfm_lifecycle(cc312_lcs);
+
+    return tfm_lcs;
+#else
+    return TFM_SLC_SECURED;
+#endif
+}
+
+const char *
+tfm_attest_hal_get_verification_service(uint32_t *size)
+{
+    *size = sizeof(verification_service_url) - 1;
+
+    return verification_service_url;
+}
+
+const char *
+tfm_attest_hal_get_profile_definition(uint32_t *size)
+{
+    *size = sizeof(attestation_profile_definition) - 1;
+
+    return attestation_profile_definition;
+}
+
+enum tfm_plat_err_t tfm_plat_get_boot_seed(uint32_t size, uint8_t *buf)
+{
+    /* FixMe: - This getter function must be ported per target platform.
+     *        - Platform service shall provide an API to further interact this
+     *          getter function to retrieve the boot seed.
+     */
+
+    uint32_t i;
+    uint8_t *p_dst = buf;
+    const uint8_t *p_src = boot_seed;
+
+    if (size != BOOT_SEED_SIZE) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    for (i = size; i > 0; i--) {
+        *p_dst = *p_src;
+        p_src++;
+        p_dst++;
+    }
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
+/**
+ * \brief Copy the device specific ID to the destination buffer
+ *
+ * \param[out]  p_dst  Pointer to buffer where to store ID
+ * \param[in]   p_src  Pointer to the ID
+ * \param[in]   size   Length of the ID
+ */
+static inline void copy_id(uint8_t *p_dst, const uint8_t *p_src, size_t size)
+{
+    uint32_t i;
+
+    for (i = size; i > 0; i--) {
+        *p_dst = *p_src;
+        p_src++;
+        p_dst++;
+    }
+}
+
+enum tfm_plat_err_t tfm_plat_get_implementation_id(uint32_t *size,
+                                                   uint8_t  *buf)
+{
+    const uint8_t *p_impl_id = implementation_id;
+    uint32_t impl_id_size = sizeof(implementation_id);
+
+    if (*size < impl_id_size) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    copy_id(buf, p_impl_id, impl_id_size);
+    *size = impl_id_size;
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
+enum tfm_plat_err_t tfm_plat_get_hw_version(uint32_t *size, uint8_t *buf)
+{
+    const uint8_t *p_hw_version = example_ean_13;
+    uint32_t hw_version_size = sizeof(example_ean_13) - 1;
+
+    if (*size < hw_version_size) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    copy_id(buf, p_hw_version, hw_version_size);
+    *size = hw_version_size;
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/boot_hal.c b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/boot_hal.c
index fa9993aa8..ad9da135f 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/boot_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/boot_hal.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -14,7 +14,8 @@
 #include "flash_layout.h"
 #include "bootutil/fault_injection_hardening.h"
 
-#ifdef CRYPTO_HW_ACCELERATOR
+#if defined(CRYPTO_HW_ACCELERATOR) || \
+    defined(CRYPTO_HW_ACCELERATOR_OTP_PROVISIONING)
 #include "crypto_hw.h"
 #endif
 
@@ -67,6 +68,24 @@ int32_t boot_platform_init(void)
    (void)fih_delay_init();
 #endif /* CRYPTO_HW_ACCELERATOR */
 
+/* This is a workaround to program the TF-M related cryptographic keys
+ * to CC312 OTP memory. This functionality is independent from secure boot,
+ * this is usually done on the factory floor during chip manufacturing.
+ */
+#ifdef CRYPTO_HW_ACCELERATOR_OTP_PROVISIONING
+    printf("OTP provisioning started.\r\n");
+    result = crypto_hw_accelerator_otp_provisioning();
+    if (result) {
+        printf("OTP provisioning FAILED: 0x%X\r\n", result);
+        return 1;
+    } else {
+        printf("OTP provisioning succeeded. TF-M won't be loaded.\r\n");
+
+        /* We don't need to boot - the only aim is provisioning. */
+        while (1);
+    }
+#endif /* CRYPTO_HW_ACCELERATOR_OTP_PROVISIONING */
+
     return 0;
 }
 
diff --git a/tf-m.old/platform/ext/target/arm/musca_b1/sse_200/crypto_keys.c b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/crypto_keys.c
new file mode 100644
index 000000000..c78619007
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/crypto_keys.c
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2017-2020 ARM Limited
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "tfm_plat_crypto_keys.h"
+#include "tfm_attest_hal.h"
+#include <stddef.h>
+#include "psa/crypto_types.h"
+#include "crypto_hw.h"
+#include "mbedtls_cc_mng_int.h"
+
+/* FIXME: Functions in this file should be implemented by platform vendor. For
+ * the security of the storage system, it is critical to use a hardware unique
+ * key. For the security of the attestation, it is critical to use a unique key
+ * pair and keep the private key is secret.
+ */
+
+#define TFM_KEY_LEN_BYTES  16
+
+extern const psa_ecc_family_t initial_attestation_curve_type;
+extern const uint8_t  initial_attestation_private_key[];
+extern const uint32_t initial_attestation_private_key_size;
+
+extern const struct tfm_plat_rotpk_t device_rotpk[];
+extern const uint32_t rotpk_key_cnt;
+
+enum tfm_plat_err_t tfm_plat_get_huk_derived_key(const uint8_t *label,
+                                                 size_t label_size,
+                                                 const uint8_t *context,
+                                                 size_t context_size,
+                                                 uint8_t *key,
+                                                 size_t key_size)
+{
+    (void)label;
+    (void)label_size;
+    (void)context;
+    (void)context_size;
+
+    int rc;
+    uint32_t lcs;
+
+    rc = crypto_hw_accelerator_get_lcs(&lcs);
+    if (rc) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    if (lcs != CC_MNG_LCS_SEC_ENABLED) {
+        return TFM_PLAT_ERR_UNSUPPORTED;
+    }
+
+    rc = crypto_hw_accelerator_huk_derive_key(label, label_size, context,
+                                              context_size, key, key_size);
+    if (rc) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
+enum tfm_plat_err_t
+tfm_plat_get_initial_attest_key(uint8_t          *key_buf,
+                                uint32_t          size,
+                                struct ecc_key_t *ecc_key,
+                                psa_ecc_family_t *curve_type)
+{
+    uint32_t key_size = initial_attestation_private_key_size;
+    int rc;
+
+    if (size < key_size) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    /* Set the EC curve type which the key belongs to */
+    *curve_type = initial_attestation_curve_type;
+
+    /* Copy the private key to the buffer, it MUST be present */
+    rc = crypto_hw_accelerator_get_attestation_private_key(key_buf, &size);
+    key_size = size;
+
+    if (rc) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    ecc_key->priv_key = key_buf;
+    ecc_key->priv_key_size = key_size;
+
+    ecc_key->pubx_key = NULL;
+    ecc_key->pubx_key_size = 0;
+    ecc_key->puby_key = NULL;
+    ecc_key->puby_key_size = 0;
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
+#ifdef BL2
+enum tfm_plat_err_t
+tfm_plat_get_rotpk_hash(uint8_t image_id,
+                        uint8_t *rotpk_hash,
+                        uint32_t *rotpk_hash_size)
+{
+    int rc = 0;
+
+    rc = crypto_hw_accelerator_get_rotpk_hash(image_id, rotpk_hash,
+                                              rotpk_hash_size);
+    if (rc) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+#endif /* BL2 */
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/manifest_list_with_se.yaml b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/manifest_list_with_se.yaml
index 9a9001c71..b14a0f2c3 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/manifest_list_with_se.yaml
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/manifest_list_with_se.yaml
@@ -11,6 +11,111 @@
   "version_major": 0,
   "version_minor": 1,
   "manifest_list": [
+    {
+      "name": "TFM Core Test Service",
+      "short_name": "TFM_SP_CORE_TEST",
+      "manifest": "${TFM_TEST_PATH}/test_services/tfm_core_test/tfm_ss_core_test.yaml",
+      "source_path": "${TFM_TEST_PATH}",
+      "conditional": "TFM_PARTITION_TEST_CORE",
+      "version_major": 0,
+      "version_minor": 1,
+      "pid": 262,
+      "linker_pattern": {
+        "library_list": [
+           "*tfm_*partition_core_test.*"
+         ]
+      }
+    },
+    {
+      "name": "TFM Core Test Service 2",
+      "short_name": "TFM_SP_CORE_TEST_2",
+      "manifest": "${TFM_TEST_PATH}/test_services/tfm_core_test_2/tfm_ss_core_test_2.yaml",
+      "source_path": "${TFM_TEST_PATH}",
+      "conditional": "TFM_PARTITION_TEST_CORE",
+      "version_major": 0,
+      "version_minor": 1,
+      "pid": 263,
+      "linker_pattern": {
+        "library_list": [
+           "*tfm_*partition_core_test_2.*"
+         ]
+      }
+    },
+    {
+      "name": "TFM Secure Client Service",
+      "short_name": "TFM_SP_SECURE_TEST_PARTITION",
+      "manifest": "${TFM_TEST_PATH}/test_services/tfm_secure_client_service/tfm_secure_client_service.yaml",
+      "source_path": "${TFM_TEST_PATH}",
+      "conditional": "TFM_PARTITION_TEST_SECURE_SERVICES",
+      "version_major": 0,
+      "version_minor": 1,
+      "pid": 264,
+      "linker_pattern": {
+        "library_list": [
+           "*tfm_*partition_secure_client_service.*"
+         ]
+      }
+    },
+    {
+      "name": "TFM IPC Service Test",
+      "short_name": "TFM_SP_IPC_SERVICE_TEST",
+      "manifest": "${TFM_TEST_PATH}/test_services/tfm_ipc_service/tfm_ipc_service_test.yaml",
+      "source_path": "${TFM_TEST_PATH}",
+      "conditional": "TFM_PARTITION_TEST_CORE_IPC",
+      "version_major": 0,
+      "version_minor": 1,
+      "pid": 265,
+      "linker_pattern": {
+        "library_list": [
+           "*tfm_*partition_ipc_service.*"
+         ]
+      }
+    },
+    {
+      "name": "TFM IPC Client Service",
+      "short_name": "TFM_SP_IPC_CLIENT_TEST",
+      "manifest": "${TFM_TEST_PATH}/test_services/tfm_ipc_client/tfm_ipc_client_test.yaml",
+      "source_path": "${TFM_TEST_PATH}",
+      "conditional": "TFM_PARTITION_TEST_CORE_IPC",
+      "version_major": 0,
+      "version_minor": 1,
+      "pid": 266,
+      "linker_pattern": {
+        "library_list": [
+           "*tfm_*partition_ipc_client.*"
+         ]
+      }
+    },
+    {
+      "name": "TF-M PS Test Service",
+      "short_name": "TFM_SP_PS_TEST",
+      "manifest": "${TFM_TEST_PATH}/test_services/tfm_ps_test_service/tfm_ps_test_service.yaml",
+      "source_path": "${TFM_TEST_PATH}",
+      "conditional": "TFM_PARTITION_TEST_PS",
+      "version_major": 0,
+      "version_minor": 1,
+      "pid": 268,
+      "linker_pattern": {
+        "library_list": [
+           "*tfm_*partition_ps_test.*"
+         ]
+      }
+    },
+    {
+      "name": "TF-M Secure Client 2 Service",
+      "short_name": "TFM_SP_SECURE_CLIENT_2",
+      "manifest": "${TFM_TEST_PATH}/test_services/tfm_secure_client_2/tfm_secure_client_2.yaml",
+      "source_path": "${TFM_TEST_PATH}",
+      "conditional": "TFM_PARTITION_TEST_SECURE_SERVICES",
+      "version_major": 0,
+      "version_minor": 1,
+      "pid": 269,
+      "linker_pattern": {
+        "library_list": [
+           "*tfm_*partition_secure_client_2.*"
+         ]
+      }
+    },
     {
       "name": "TF-M PSA Proxy Service",
       "short_name": "TFM_SP_PSA_PROXY",
@@ -40,5 +145,62 @@
          ]
       }
     },
+    {
+      "name": "TFM FFM11 Partition Service",
+      "short_name": "TFM_SP_FFM11",
+      "manifest": "secure_fw/partitions/tfm_ffm11_partition/tfm_ffm11_partition.yaml",
+      "conditional": "TFM_PARTITION_FFM11",
+      "version_major": 0,
+      "version_minor": 1,
+      "pid": 272,
+      "linker_pattern": {
+        "library_list": [
+          "*tfm_*partition_ffm11.*"
+        ]
+      }
+    },
+    {
+      "name": "TFM Initial Attestation Test Service",
+      "short_name": "TFM_ATTEST_TEST_SERVICE",
+      "manifest": "${TFM_TEST_PATH}/test_services/tfm_attest_test_service/tfm_attest_test_service.yaml",
+      "source_path": "${TFM_TEST_PATH}",
+      "conditional": "ATTEST_TEST_GET_PUBLIC_KEY",
+      "version_major": 0,
+      "version_minor": 1,
+      "pid": 273,
+      "linker_pattern": {
+        "library_list": [
+           "*tfm_*partition_attest_test_service.*"
+         ]
+      }
+    },
+    {
+      "name": "TFM SLIH Test Service",
+      "short_name": "TFM_SP_SLIH_TEST",
+      "manifest": "${TFM_TEST_PATH}/test_services/tfm_slih_test_service/tfm_slih_test_service.yaml",
+      "source_path": "${TFM_TEST_PATH}",
+      "conditional": "TFM_ENABLE_SLIH_TEST",
+      "version_major": 0,
+      "version_minor": 1,
+      "linker_pattern": {
+        "library_list": [
+           "*tfm_*partition_slih_test.*"
+         ]
+      }
+    },
+    {
+      "name": "TFM FLIH Test Service",
+      "short_name": "TFM_SP_FLIH_TEST",
+      "manifest": "${TFM_TEST_PATH}/test_services/tfm_flih_test_service/tfm_flih_test_service.yaml",
+      "source_path": "${TFM_TEST_PATH}",
+      "conditional": "TFM_ENABLE_FLIH_TEST",
+      "version_major": 0,
+      "version_minor": 1,
+      "linker_pattern": {
+        "library_list": [
+           "*tfm_*partition_flih_test.*"
+         ]
+      }
+    }
   ]
 }
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/partition/flash_layout.h b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/partition/flash_layout.h
index 350117d59..16f91fecb 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/partition/flash_layout.h
@@ -31,8 +31,8 @@
  * 0x0A16_0000 Non-secure image secondary slot (512 KB)
  * 0x0A1E_0000 Scratch area (64 KB)
  * 0x0A1F_0000 Internal Trusted Storage Area (32 KB)
- * 0x0A1F_8000 OTP / NV counter area (8 KB)
- * 0x0A1F_A000 Unused (40 KB)
+ * 0x0A1F_8000 NV counters area (16 KB)
+ * 0x0A1F_C000 Unused (32 KB)
  *
  * Flash layout on Musca-B1 with BL2 (single image boot):
  *
@@ -45,8 +45,8 @@
  *    0x0A16_0000 Non-secure image secondary (512 KB)
  * 0x0A1E_0000 Scratch area (64 KB)
  * 0x0A1F_0000 Internal Trusted Storage Area (32 KB)
- * 0x0A1F_8000 OTP / NV counter area (8 KB)
- * 0x0A1F_A000 Unused (40 KB)
+ * 0x0A1F_8000 NV counters area (16 KB)
+ * 0x0A1F_C000 Unused (32 KB)
  *
  * Note: As eFlash is written at runtime, the eFlash driver code is placed
  * in code SRAM to avoid any interference.
@@ -152,11 +152,10 @@
                                          FLASH_AREA_SCRATCH_SIZE)
 #define FLASH_ITS_AREA_SIZE             (2 * FLASH_AREA_IMAGE_SECTOR_SIZE)
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* Offset and size definition in flash area used by assemble.py */
 #define SECURE_IMAGE_OFFSET             (0x0)
@@ -176,8 +175,6 @@
  * Name is defined in flash driver file: Driver_Flash.c
  */
 #define FLASH_DEV_NAME Driver_EFLASH0
-/* Smallest flash programmable unit in bytes */
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x4)
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -217,12 +214,11 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x4)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18) /* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_NV_COUNTERS_AREA_SIZE
 
 /* Use eFlash 0 memory to store Code data */
 #define S_ROM_ALIAS_BASE  (0x1A000000)
@@ -294,9 +290,6 @@
 #define FLASH_AREA_SCRATCH_SIZE         0
 
 #define FLASH_DEV_NAME                  Driver_EFLASH0
-/* Smallest flash programmable unit in bytes */
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x4)
-
 #define FLASH_AREA_BL2_OFFSET           0
 #define FLASH_AREA_BL2_SIZE             0x20000
 
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/partition/region_defs.h b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/partition/region_defs.h
index 7a7786fd3..0b7c74afb 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/partition/region_defs.h
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/partition/region_defs.h
@@ -78,19 +78,8 @@
 #define BL2_TRAILER_SIZE     (0xC00)
 #endif /* BL2 */
 
-#if (MCUBOOT_IMAGE_NUMBER == 1) && \
-    (NS_IMAGE_PRIMARY_PARTITION_OFFSET > S_IMAGE_PRIMARY_PARTITION_OFFSET)
-/* If secure image and nonsecure image are concatenated, and nonsecure image
- * locates at the higher memory range, then the secure image does not need
- * the trailer area.
- */
-#define IMAGE_S_CODE_SIZE \
-            (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE)
-#else
 #define IMAGE_S_CODE_SIZE \
             (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
-#endif
-
 #define IMAGE_NS_CODE_SIZE \
             (FLASH_NS_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
 
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/plat_test.c b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/plat_test.c
index edc29d1c4..cdfcfa209 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/plat_test.c
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/plat_test.c
@@ -10,8 +10,58 @@
 #include "tfm_plat_test.h"
 #include "device_definition.h"
 
+#define USERLED_MASK                (0x3)
+#define BTN_WAIT_INIT_COUNTER_VALUE (10000u)
 #define TIMER_RELOAD_VALUE          (16*1024*1024)
 
+/**
+ * \brief Store the state of the mocked LED
+ *
+ * This variable have to be linked to the data section of the partition
+ * TFM_SP_CORE_TEST so that in case of in case of isolation within the secure
+ * domain the Core Test service can access it.
+ */
+uint32_t led_status
+    TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_CORE_TEST", "PSA-ROT")
+    = 0x02u;
+
+/**
+ * \brief Simulate user reaction time
+ */
+static void busy_wait_to_simulate_user(void)
+{
+    volatile uint32_t counter = BTN_WAIT_INIT_COUNTER_VALUE;
+    while (counter)
+    {
+        --counter;
+    }
+}
+
+void tfm_plat_test_wait_user_button_pressed(void)
+{
+    busy_wait_to_simulate_user();
+}
+
+void tfm_plat_test_wait_user_button_released(void)
+{
+    busy_wait_to_simulate_user();
+}
+
+uint32_t tfm_plat_test_get_led_status(void)
+{
+    return led_status;
+}
+
+void tfm_plat_test_set_led_status(uint32_t status)
+{
+    led_status = status & USERLED_MASK;
+}
+
+uint32_t tfm_plat_test_get_userled_mask(void)
+{
+    return USERLED_MASK;
+}
+
 void tfm_plat_test_secure_timer_start(void)
 {
     if (!timer_cmsdk_is_initialized(&CMSDK_TIMER0_DEV_S)) {
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/spm_hal.c b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/spm_hal.c
index b7574023d..d96f23c0f 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/spm_hal.c
@@ -5,11 +5,14 @@
  *
  */
 
+#include <stdio.h>
 #include "cmsis.h"
 #include "tfm_spm_hal.h"
 #include "tfm_platform_core_api.h"
 #include "target_cfg.h"
 #include "Driver_MPC.h"
+#include "mpu_armv8m_drv.h"
+#include "region_defs.h"
 #include "utilities.h"
 #include "tfm_hal_platform.h"
 
@@ -20,6 +23,66 @@ extern ARM_DRIVER_MPC Driver_CODE_SRAM_MPC;
 /* Get address of memory regions to configure MPU */
 extern const struct memory_region_limits memory_regions;
 
+struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
+
+#ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
+#define PARTITION_REGION_PERIPH_START   5
+#define PARTITION_REGION_PERIPH_MAX_NUM 2
+
+uint32_t periph_num_count = 0;
+#endif /* CONFIG_TFM_ENABLE_MEMORY_PROTECT */
+
+enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
+                  bool privileged,
+                  const struct platform_data_t *platform_data)
+{
+#if defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1)
+    struct mpu_armv8m_region_cfg_t region_cfg;
+#endif
+
+    if (!platform_data) {
+        return TFM_PLAT_ERR_INVALID_INPUT;
+    }
+
+#if defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1)
+    if (!privileged) {
+        region_cfg.region_nr = PARTITION_REGION_PERIPH_START + periph_num_count;
+        periph_num_count++;
+        if (periph_num_count >= PARTITION_REGION_PERIPH_MAX_NUM) {
+            return TFM_PLAT_ERR_MAX_VALUE;
+        }
+        region_cfg.region_base = platform_data->periph_start;
+        region_cfg.region_limit = platform_data->periph_limit;
+        region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
+        region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
+        region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
+        region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
+
+        mpu_armv8m_disable(&dev_mpu_s);
+
+        if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg)
+            != MPU_ARMV8M_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+        mpu_armv8m_enable(&dev_mpu_s, PRIVILEGED_DEFAULT_ENABLE,
+                          HARDFAULT_NMI_ENABLE);
+    }
+#endif /* defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1) */
+
+    if (platform_data->periph_ppc_bank != PPC_SP_DO_NOT_CONFIGURE) {
+        ppc_configure_to_secure(platform_data->periph_ppc_bank,
+                                platform_data->periph_ppc_loc);
+        if (privileged) {
+            ppc_clr_secure_unpriv(platform_data->periph_ppc_bank,
+                                  platform_data->periph_ppc_loc);
+        } else {
+            ppc_en_secure_unpriv(platform_data->periph_ppc_bank,
+                                 platform_data->periph_ppc_loc);
+        }
+    }
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
 void MPC_Handler(void)
 {
     /* Clear MPC interrupt flags and pending MPC IRQ */
@@ -163,30 +226,3 @@ enum tfm_plat_err_t tfm_spm_hal_nvic_interrupt_enable(void)
 {
     return nvic_interrupt_enable();
 }
-
-#ifndef TFM_PSA_API
-
-enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
-                  bool privileged,
-                  const struct platform_data_t *platform_data)
-{
-
-    if (!platform_data) {
-        return TFM_PLAT_ERR_INVALID_INPUT;
-    }
-
-    if (platform_data->periph_ppc_bank != PPC_SP_DO_NOT_CONFIGURE) {
-        ppc_configure_to_secure(platform_data->periph_ppc_bank,
-                                platform_data->periph_ppc_loc);
-        if (privileged) {
-            ppc_clr_secure_unpriv(platform_data->periph_ppc_bank,
-                                  platform_data->periph_ppc_loc);
-        } else {
-            ppc_en_secure_unpriv(platform_data->periph_ppc_bank,
-                                 platform_data->periph_ppc_loc);
-        }
-    }
-    return TFM_PLAT_ERR_SUCCESS;
-}
-
-#endif /* TFM_PSA_API */
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/tfm_hal_isolation.c b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/tfm_hal_isolation.c
index 33cf20513..d4d2f5488 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/tfm_hal_isolation.c
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/tfm_hal_isolation.c
@@ -1,32 +1,19 @@
 /*
- * Copyright (c) 2020-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
  */
 
-#include "array.h"
 #include "cmsis.h"
 #include "Driver_Common.h"
-#include "mmio_defs.h"
 #include "mpu_armv8m_drv.h"
 #include "region.h"
 #include "target_cfg.h"
 #include "tfm_hal_isolation.h"
-#include "tfm_peripherals_def.h"
-#include "tfm_core_utils.h"
-#include "load/partition_defs.h"
-#include "load/asset_defs.h"
-#include "load/spm_load_api.h"
-
-/* It can be retrieved from the MPU_TYPE register. */
-#define MPU_REGION_NUM                  8
 
 #ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
-static uint32_t n_configured_regions = 0;
-struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 #if TFM_LVL == 3
-static uint32_t idx_boundary_handle = 0;
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Base);
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Limit);
 REGION_DECLARE(Image$$, PT_RO_START, $$Base);
@@ -34,6 +21,8 @@ REGION_DECLARE(Image$$, PT_RO_END, $$Base);
 REGION_DECLARE(Image$$, PT_PRIV_RWZI_START, $$Base);
 REGION_DECLARE(Image$$, PT_PRIV_RWZI_END, $$Base);
 
+static uint32_t g_static_region_cnt;
+
 static struct mpu_armv8m_region_cfg_t isolation_regions[] = {
     {
         0, /* will be updated before using */
@@ -54,7 +43,7 @@ static struct mpu_armv8m_region_cfg_t isolation_regions[] = {
         MPU_ARMV8M_SH_NONE,
     },
     /* For isolation Level 3, set up static isolation for privileged data.
-     * Unprivileged data is dynamically set during Partition scheduling.
+     * Unprivileged data is dynamically set during Partition sheduling.
      */
     {
         0, /* will be updated before using */
@@ -82,8 +71,8 @@ REGION_DECLARE(Image$$, TFM_APP_CODE_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_CODE_END, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_END, $$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Base);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
 #ifdef TFM_SP_META_PTR_ENABLE
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Base);
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
@@ -109,20 +98,17 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
 
     /* Set up static isolation boundaries inside SPE */
 #ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
+    int32_t i;
+    struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 
     mpu_armv8m_clean(&dev_mpu_s);
 #if TFM_LVL == 3
-    int32_t i;
+    uint32_t cnt;
 
-    /*
-     * Update MPU region numbers. The numbers start from 0 and are continuous.
-     * Under isolation level3, at lease one MPU region is reserved for private
-     * data asset.
-     */
-    if (ARRAY_SIZE(isolation_regions) >= MPU_REGION_NUM) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-    for (i = 0; i < ARRAY_SIZE(isolation_regions); i++) {
+    /* Update MPU region numbers. The numbers start from 0 and are continuous */
+    cnt = sizeof(isolation_regions) / sizeof(isolation_regions[0]);
+    g_static_region_cnt = cnt;
+    for (i = 0; i < cnt; i++) {
         /* Update region number */
         isolation_regions[i].region_nr = i;
         /* Enable regions */
@@ -131,7 +117,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
             return TFM_HAL_ERROR_GENERIC;
         }
     }
-    n_configured_regions = i;
 #else /* TFM_LVL == 3 */
     struct mpu_armv8m_region_cfg_t region_cfg;
 
@@ -146,7 +131,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
     /* TFM Core unprivileged code region */
     region_cfg.region_nr = MPU_REGION_TFM_UNPRIV_CODE;
@@ -161,14 +145,13 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
     /* NSPM PSP */
     region_cfg.region_nr = MPU_REGION_NS_STACK;
     region_cfg.region_base =
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base);
     region_cfg.region_limit =
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
     region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
     region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
     region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
@@ -176,7 +159,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
     /* RO region */
     region_cfg.region_nr = PARTITION_REGION_RO;
@@ -191,7 +173,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
     /* RW, ZI and stack as one region */
     region_cfg.region_nr = PARTITION_REGION_RW_STACK;
@@ -206,7 +187,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
 #ifdef TFM_SP_META_PTR_ENABLE
     /* TFM partition metadata pointer region */
@@ -222,7 +202,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 #endif /* TFM_SP_META_PTR_ENABLE */
 #endif /* TFM_LVL == 3 */
 
@@ -237,228 +216,26 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     return TFM_HAL_SUCCESS;
 }
 
-/*
- * Implementation of tfm_hal_bind_boundaries() on MUSCA_B1:
- *
- * The API encodes some attributes into a handle and returns it to SPM.
- * The attributes include isolation boundaries, privilege, and MMIO information.
- * When scheduler switches running partitions, SPM compares the handle between
- * partitions to know if boundary update is necessary. If update is required,
- * SPM passes the handle to platform to do platform settings and update
- * isolation boundaries.
- *
- * The handle should be unique under isolation level 3. The implementation
- * encodes an index at the highest 8 bits to assure handle uniqueness. While
- * under isolation level 1/2, handles may not be unique.
- *
- * The encoding format assignment:
- * - For isolation level 3
- *      BIT | 31        24 | 23         20 | ... | 7           4 | 3        0 |
- *          | Unique Index | Region Attr 5 | ... | Region Attr 1 | Privileged |
- *
- *      In which the "Region Attr i" is:
- *      BIT |       3      | 2        0 |
- *          | 1: RW, 0: RO | MMIO Index |
- *
- * - For isolation level 1/2
- *      BIT | 31                           0 |
- *          | 1: privileged, 0: unprivileged |
- *
- * This is a reference implementation on MUSCA_B1, and may have some
- * limitations.
- * 1. The maximum number of allowed MMIO regions is 5.
- * 2. Highest 8 bits are for index. It supports 256 unique handles at most.
- */
-enum tfm_hal_status_t tfm_hal_bind_boundaries(
-                                    const struct partition_load_info_t *p_ldinf,
-                                    void **pp_boundaries)
-{
-    uint32_t i, j;
-    bool privileged;
-    const struct asset_desc_t *p_asset;
-    struct platform_data_t *plat_data_ptr;
-#if TFM_LVL == 2
-    struct mpu_armv8m_region_cfg_t localcfg;
-#elif TFM_LVL == 3
-    uint32_t partition_attrs = 0;
-#endif
-
-    if (!p_ldinf || !pp_boundaries) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-
-#if TFM_LVL == 1
-    privileged = true;
-#else
-    privileged = !!(p_ldinf->flags & SPM_PART_FLAG_PSA_ROT);
-#endif
-
-    p_asset = (const struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
-
-    /*
-     * Validate if the named MMIO of partition is allowed by the platform.
-     * Otherwise, skip validation.
-     *
-     * NOTE: Need to add validation of numbered MMIO if platform requires.
-     */
-    for (i = 0; i < p_ldinf->nassets; i++) {
-        if (!(p_asset[i].attr & ASSET_ATTR_NAMED_MMIO)) {
-            continue;
-        }
-        for (j = 0; j < ARRAY_SIZE(partition_named_mmio_list); j++) {
-            if (p_asset[i].dev.dev_ref == partition_named_mmio_list[j]) {
-                break;
-            }
-        }
-
-        if (j == ARRAY_SIZE(partition_named_mmio_list)) {
-            /* The MMIO asset is not in the allowed list of platform. */
-            return TFM_HAL_ERROR_GENERIC;
-        }
-        /* Assume PPC & MPC settings are required even under level 1 */
-        plat_data_ptr = REFERENCE_TO_PTR(p_asset[i].dev.dev_ref,
-                                         struct platform_data_t *);
-
-        ppc_configure_to_secure(plat_data_ptr->periph_ppc_bank,
-                                plat_data_ptr->periph_ppc_loc);
-        if (privileged) {
-            ppc_clr_secure_unpriv(plat_data_ptr->periph_ppc_bank,
-                                  plat_data_ptr->periph_ppc_loc);
-        } else {
-            ppc_en_secure_unpriv(plat_data_ptr->periph_ppc_bank,
-                                 plat_data_ptr->periph_ppc_loc);
-        }
-#if TFM_LVL == 2
-        /*
-         * Static boundaries are set. Set up MPU region for MMIO.
-         * Setup regions for unprivileged assets only.
-         */
-        if (!privileged) {
-            localcfg.region_base = plat_data_ptr->periph_start;
-            localcfg.region_limit = plat_data_ptr->periph_limit;
-            localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
-            localcfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
-            localcfg.attr_sh = MPU_ARMV8M_SH_NONE;
-            localcfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
-            localcfg.region_nr = n_configured_regions++;
-
-            if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg)
-                != MPU_ARMV8M_OK) {
-                return TFM_HAL_ERROR_GENERIC;
-            }
-        }
-#elif TFM_LVL == 3
-        /* Encode MMIO attributes into the "partition_attrs". */
-        partition_attrs <<= HANDLE_PER_ATTR_BITS;
-        partition_attrs |= ((j + 1) & HANDLE_ATTR_INDEX_MASK);
-        if (p_asset[i].attr & ASSET_ATTR_READ_WRITE) {
-            partition_attrs |= HANDLE_ATTR_RW_POS;
-        }
-#endif
-    }
-
 #if TFM_LVL == 3
-    partition_attrs <<= HANDLE_PER_ATTR_BITS;
-    partition_attrs |= ((uint8_t)privileged) & HANDLE_ATTR_PRIV_MASK;
-    /*
-     * Highest 8 bits are reserved for index, if they are non-zero, MMIO numbers
-     * must have exceeded the limit of 5.
-     */
-    if (partition_attrs & HANDLE_INDEX_MASK) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-    HANDLE_ENCODE_INDEX(partition_attrs, idx_boundary_handle);
-    *pp_boundaries = (void *)partition_attrs;
-#else
-    *pp_boundaries = (void *)(((uint32_t)privileged) & HANDLE_ATTR_PRIV_MASK);
-#endif
-
-    return TFM_HAL_SUCCESS;
-}
-
-enum tfm_hal_status_t tfm_hal_update_boundaries(
-                             const struct partition_load_info_t *p_ldinf,
-                             void *p_boundaries)
+enum tfm_hal_status_t tfm_hal_mpu_update_partition_boundary(uintptr_t start,
+                                                            uintptr_t end)
 {
-    CONTROL_Type ctrl;
-    uint32_t local_handle = (uint32_t)p_boundaries;
-    bool privileged = !!(local_handle & HANDLE_ATTR_PRIV_MASK);
-#if TFM_LVL == 3
-    struct mpu_armv8m_region_cfg_t localcfg;
-    uint32_t i, mmio_index;
-    struct platform_data_t *plat_data_ptr;
-    struct asset_desc_t *rt_mem;
-#endif
-
-    /* Privileged level is required to be set always */
-    ctrl.w = __get_CONTROL();
-    ctrl.b.nPRIV = privileged ? 0 : 1;
-    __set_CONTROL(ctrl.w);
-
-#if TFM_LVL == 3
-    if (!p_ldinf) {
+    struct mpu_armv8m_region_cfg_t cfg;
+    enum mpu_armv8m_error_t mpu_err;
+    struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
+
+    /* Partition boundary regions is right after static regions */
+    cfg.region_nr = g_static_region_cnt;
+    cfg.region_base = start;
+    cfg.region_limit = end;
+    cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
+    cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
+    cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
+    cfg.attr_sh = MPU_ARMV8M_SH_NONE;
+    mpu_err = mpu_armv8m_region_enable(&dev_mpu_s, &cfg);
+    if (mpu_err != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-
-    /* Update regions, for unprivileged partitions only */
-    if (privileged) {
-        return TFM_HAL_SUCCESS;
-    }
-
-    /* Setup runtime memory first */
-    localcfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
-    localcfg.attr_sh = MPU_ARMV8M_SH_NONE;
-    localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
-    localcfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
-    rt_mem = (struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
-    /*
-     * MUSCA_B1 shortcut: The first item is the only runtime memory asset.
-     * Platforms with many memory assets please check this part.
-     */
-    for (i = 0;
-         i < p_ldinf->nassets && !(rt_mem[i].attr & ASSET_ATTR_MMIO);
-         i++) {
-        localcfg.region_nr = n_configured_regions + i;
-        localcfg.region_base = rt_mem[i].mem.start;
-        localcfg.region_limit = rt_mem[i].mem.limit;
-
-        if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg) != MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
-        }
-    }
-
-    /* Named MMIO part */
-    local_handle = local_handle & (~HANDLE_INDEX_MASK);
-    local_handle >>= HANDLE_PER_ATTR_BITS;
-    mmio_index = local_handle & HANDLE_ATTR_INDEX_MASK;
-
-    localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
-
-    i = n_configured_regions + i;
-    while (mmio_index && i < MPU_REGION_NUM) {
-        plat_data_ptr =
-          (struct platform_data_t *)partition_named_mmio_list[mmio_index - 1];
-        localcfg.region_nr = i++;
-        localcfg.attr_access = (local_handle & HANDLE_ATTR_RW_POS)?
-                            MPU_ARMV8M_AP_RW_PRIV_UNPRIV :
-                            MPU_ARMV8M_AP_RO_PRIV_UNPRIV;
-        localcfg.region_base = plat_data_ptr->periph_start;
-        localcfg.region_limit = plat_data_ptr->periph_limit;
-
-        if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg) != MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
-        }
-
-        local_handle >>= HANDLE_PER_ATTR_BITS;
-        mmio_index = local_handle & HANDLE_ATTR_INDEX_MASK;
-    }
-
-    /* Disable unused regions */
-    while (i < MPU_REGION_NUM) {
-        if (mpu_armv8m_region_disable(&dev_mpu_s, i++)!= MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
-        }
-    }
-#endif
     return TFM_HAL_SUCCESS;
 }
+#endif /* TFM_LVL == 3 */
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/tfm_peripherals_def.h
index 92a96fbae..a0887ac91 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/tfm_peripherals_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
  * Copyright (c) 2020, Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -15,12 +15,6 @@
 extern "C" {
 #endif
 
-/*
- * Quantized default IRQ priority, the value is:
- * (Number of configurable priority) / 4: (1UL << __NVIC_PRIO_BITS) / 4
- */
-#define DEFAULT_IRQ_PRIORITY    (1UL << (__NVIC_PRIO_BITS - 2))
-
 #define TFM_TIMER0_IRQ           (TIMER0_IRQn)
 #define TFM_TIMER1_IRQ           (TIMER1_IRQn)
 #define FF_TEST_UART_IRQ         (UART1_Tx_IRQn)
@@ -33,6 +27,7 @@ extern struct platform_data_t tfm_peripheral_timer0;
 
 #define TFM_PERIPHERAL_STD_UART     (&tfm_peripheral_std_uart)
 #define TFM_PERIPHERAL_TIMER0       (&tfm_peripheral_timer0)
+#define TFM_PERIPHERAL_FPGA_IO      (0)
 
 #ifdef PSA_API_TEST_IPC
 extern struct platform_data_t tfm_peripheral_FF_TEST_UART_REGION;
diff --git a/lib/tf-m/platform/ext/target/arm/musca_s1/Device/Source/armclang/startup_cmsdk_musca_s.s b/lib/tf-m/platform/ext/target/arm/musca_s1/Device/Source/armclang/startup_cmsdk_musca_s.s
index d3bb33734..6293c8d39 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_s1/Device/Source/armclang/startup_cmsdk_musca_s.s
+++ b/lib/tf-m/platform/ext/target/arm/musca_s1/Device/Source/armclang/startup_cmsdk_musca_s.s
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2017-2021 Arm Limited. All rights reserved.
+; * Copyright (c) 2017-2019 Arm Limited. All rights reserved.
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -26,7 +26,7 @@
 ;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
 ; </h>
 
-                IMPORT |Image$$ARM_LIB_STACK$$ZI$$Limit|
+                IMPORT |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|
 
 ; Vector Table Mapped to Address 0 at Reset
 
@@ -36,7 +36,7 @@
                 EXPORT  __Vectors_Size
 
 __Vectors       ;Core Interrupts
-                DCD     |Image$$ARM_LIB_STACK$$ZI$$Limit|  ; Top of Stack
+                DCD     |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|  ; Top of Stack
                 DCD     Reset_Handler                  ; Reset Handler
                 DCD     NMI_Handler                    ; NMI Handler
                 DCD     HardFault_Handler              ; Hard Fault Handler
@@ -145,6 +145,9 @@ Reset_Handler   PROC
                 CPSID   i              ; Disable IRQs
                 LDR     R0, =SystemInit
                 BLX     R0
+                MRS     R0, control    ; Get control value
+                ORR     R0, R0, #2     ; Select switch to PSP
+                MSR     control, R0
                 LDR     R0, =__main
                 BX      R0
                 ENDP
diff --git a/lib/tf-m/platform/ext/target/arm/musca_s1/Device/Source/gcc/startup_cmsdk_musca_s.S b/lib/tf-m/platform/ext/target/arm/musca_s1/Device/Source/gcc/startup_cmsdk_musca_s.S
index 6cd30d92f..bd4922d28 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_s1/Device/Source/gcc/startup_cmsdk_musca_s.S
+++ b/lib/tf-m/platform/ext/target/arm/musca_s1/Device/Source/gcc/startup_cmsdk_musca_s.S
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2009-2021 Arm Limited. All rights reserved.
+; * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -26,7 +26,7 @@
     .align 2
     .globl    __Vectors
 __Vectors:
-    .long    Image$$ARM_LIB_STACK$$ZI$$Limit   /* Top of Stack */
+    .long    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit   /* Top of Stack */
     .long    Reset_Handler         /* Reset Handler */
     .long    NMI_Handler           /* NMI Handler */
     .long    HardFault_Handler     /* Hard Fault Handler */
@@ -253,6 +253,12 @@ Reset_Handler:
     cpsid   i              /* Disable IRQs */
     bl    SystemInit
 
+    mrs     r0, control    /* Get control value */
+    orr     r0, r0, #2     /* Select switch to PSP */
+    msr     control, r0
+    ldr     r0, =Image$$ARM_LIB_STACK$$ZI$$Limit
+    msr     psp, r0
+
 #ifndef __START
 #define __START _start
 #endif
diff --git a/lib/tf-m/platform/ext/target/arm/musca_s1/Native_Driver/mpu_armv8m_drv.h b/lib/tf-m/platform/ext/target/arm/musca_s1/Native_Driver/mpu_armv8m_drv.h
index 9abe8182e..c2b62ac00 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_s1/Native_Driver/mpu_armv8m_drv.h
+++ b/lib/tf-m/platform/ext/target/arm/musca_s1/Native_Driver/mpu_armv8m_drv.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2019 Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -91,7 +91,7 @@ enum mpu_armv8m_error_t mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -102,7 +102,7 @@ enum mpu_armv8m_error_t mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev);
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -114,7 +114,7 @@ enum mpu_armv8m_error_t mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev);
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_cfg     MPU region config \ref mpu_armv8m_region_cfg_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -128,7 +128,7 @@ enum mpu_armv8m_error_t mpu_armv8m_region_enable(
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_nr            Region number
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
diff --git a/lib/tf-m/platform/ext/target/arm/musca_s1/boot_hal.c b/lib/tf-m/platform/ext/target/arm/musca_s1/boot_hal.c
index 1bdac8cc1..a8db47a65 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_s1/boot_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/musca_s1/boot_hal.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -14,7 +14,8 @@
 #include "flash_layout.h"
 #include "bootutil/fault_injection_hardening.h"
 
-#ifdef CRYPTO_HW_ACCELERATOR
+#if defined(CRYPTO_HW_ACCELERATOR) || \
+    defined(CRYPTO_HW_ACCELERATOR_OTP_PROVISIONING)
 #include "crypto_hw.h"
 #endif
 
@@ -67,6 +68,24 @@ int32_t boot_platform_init(void)
     (void)fih_delay_init();
 #endif /* CRYPTO_HW_ACCELERATOR */
 
+/* This is a workaround to program the TF-M related cryptographic keys
+ * to CC312 OTP memory. This functionality is independent from secure boot,
+ * this is usually done on the factory floor during chip manufacturing.
+ */
+#ifdef CRYPTO_HW_ACCELERATOR_OTP_PROVISIONING
+    printf("OTP provisioning started.\r\n");
+    result = crypto_hw_accelerator_otp_provisioning();
+    if (result) {
+        printf("OTP provisioning FAILED: 0x%X\r\n", result);
+        return 1;
+    } else {
+        printf("OTP provisioning succeeded. TF-M won't be loaded.\r\n");
+
+        /* We don't need to boot - the only aim is provisioning. */
+        while (1);
+    }
+#endif /* CRYPTO_HW_ACCELERATOR_OTP_PROVISIONING */
+
     return 0;
 }
 
diff --git a/tf-m.old/platform/ext/target/arm/musca_s1/crypto_keys.c b/lib/tf-m/platform/ext/target/arm/musca_s1/crypto_keys.c
new file mode 100644
index 000000000..d42916c61
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/arm/musca_s1/crypto_keys.c
@@ -0,0 +1,211 @@
+/*
+ * Copyright (c) 2017-2020 ARM Limited
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "tfm_plat_crypto_keys.h"
+#include "tfm_attest_hal.h"
+#include <stddef.h>
+#include "psa/crypto_types.h"
+#include "crypto_hw.h"
+#include "mbedtls_cc_mng_int.h"
+#include "mbedtls_cc_util_key_derivation.h"
+#include "cc_otp_defs.h"
+
+/* FIXME: Functions in this file should be implemented by platform vendor. For
+ * the security of the storage system, it is critical to use a hardware unique
+ * key. For the security of the attestation, it is critical to use a unique key
+ * pair and keep the private key is secret.
+ */
+
+#define TFM_KEY_LEN_BYTES  16
+
+#define CC312_NULL_CONTEXT "NO SALT!"
+#define CC_BITS_IN_32BIT_WORD 32
+
+extern const psa_ecc_family_t initial_attestation_curve_type;
+extern const uint8_t  initial_attestation_private_key[];
+extern const uint32_t initial_attestation_private_key_size;
+
+extern const struct tfm_plat_rotpk_t device_rotpk[];
+extern const uint32_t rotpk_key_cnt;
+
+enum tfm_plat_err_t tfm_plat_get_huk_derived_key(const uint8_t *label,
+                                                 size_t label_size,
+                                                 const uint8_t *context,
+                                                 size_t context_size,
+                                                 uint8_t *key,
+                                                 size_t key_size)
+{
+    (void)label;
+    (void)label_size;
+    (void)context;
+    (void)context_size;
+
+    int rc;
+    uint32_t lcs;
+    struct mbedtls_util_keydata mram_key = { 0 };
+    uint32_t huk[CC_OTP_HUK_SIZE_IN_WORDS] = { 0 };
+    int i = 0;
+
+    rc = crypto_hw_accelerator_get_lcs(&lcs);
+    if (rc) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    if (lcs != CC_MNG_LCS_SEC_ENABLED) {
+        return TFM_PLAT_ERR_UNSUPPORTED;
+    }
+
+    for (i = 0; i < CC_OTP_HUK_SIZE_IN_WORDS; i++) {
+        CC_READ_MRAM_WORD((CC_OTP_HUK_OFFSET + i) * sizeof(uint32_t), huk[i]);
+    }
+
+    mram_key.pKey = (uint8_t*)huk;
+
+    mram_key.keySize = CC_OTP_HUK_SIZE_IN_WORDS * sizeof(uint32_t);
+
+    if (context == NULL || context_size == 0) {
+        /* The CC312 requires the context to not be null, so a default
+         * is given.
+         */
+        context = (const uint8_t *)CC312_NULL_CONTEXT;
+        context_size = sizeof(CC312_NULL_CONTEXT);
+    }
+
+    rc = mbedtls_util_key_derivation_cmac(CC_UTIL_USER_KEY, &mram_key,
+                                          label, label_size,
+                                          context, context_size,
+                                          key, key_size);
+
+    if (rc) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
+/*
+ * Count number of zero bits in 32-bit word.
+ * Copied from:
+ * lib/ext/cryptocell-312-runtime/host/src/ \
+ * cc3x_productionlib/common/prod_util.c: CC_PROD_GetZeroCount(..)
+ */
+static int get_zero_bits_count(uint32_t *buf,
+                               uint32_t  buf_word_size,
+                               uint32_t *zero_count)
+{
+    uint32_t val;
+    uint32_t index = 0;
+
+    *zero_count = 0;
+    for (index = 0; index < buf_word_size; index++) {
+        val = buf[index];
+        val = val - ((val >> 1) & 0x55555555);
+        val = (val & 0x33333333) + ((val >> 2) & 0x33333333);
+        val = ((((val + (val >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24);
+        *zero_count += (32 - val);
+    }
+    /* All 0's and all 1's is forbidden */
+    if ((*zero_count == 0)
+        || (*zero_count == buf_word_size*CC_BITS_IN_32BIT_WORD)) {
+        *zero_count = 0;
+        return -1;
+    }
+
+    return 0;
+}
+
+enum tfm_plat_err_t
+tfm_plat_get_initial_attest_key(uint8_t          *key_buf,
+                                uint32_t          size,
+                                struct ecc_key_t *ecc_key,
+                                psa_ecc_family_t *curve_type)
+{
+    uint32_t key_size = initial_attestation_private_key_size;
+    int rc;
+    uint32_t *key = (uint32_t *)key_buf;
+    uint32_t zero_count;
+    uint32_t otp_zero_count;
+    int i;
+
+    if (size < key_size) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    /* Set the EC curve type which the key belongs to */
+    *curve_type = initial_attestation_curve_type;
+
+    /* Copy the private key to the buffer, it MUST be present */
+    if (key == NULL ||
+        size < CC_OTP_ATTESTATION_KEY_SIZE_IN_WORDS * sizeof(uint32_t)) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+    size = CC_OTP_ATTESTATION_KEY_SIZE_IN_WORDS * sizeof(uint32_t);
+
+    for (i = 0; i < CC_OTP_ATTESTATION_KEY_SIZE_IN_WORDS; i++) {
+        CC_READ_MRAM_WORD((CC_OTP_ATTESTATION_KEY_OFFSET + i) *
+                          sizeof(uint32_t), key[i]);
+    }
+
+    /* Verify the zero number of private key */
+    rc = get_zero_bits_count((uint32_t *)key_buf,
+                             CC_OTP_ATTESTATION_KEY_SIZE_IN_WORDS,
+                             &zero_count);
+    if (rc) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    CC_READ_MRAM_WORD(CC_OTP_ATTESTATION_KEY_ZERO_COUNT_OFFSET *
+                      sizeof(uint32_t), otp_zero_count);
+
+    if (otp_zero_count != zero_count) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    key_size = size;
+
+    if (rc) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    ecc_key->priv_key = key_buf;
+    ecc_key->priv_key_size = key_size;
+
+    ecc_key->pubx_key = NULL;
+    ecc_key->pubx_key_size = 0;
+    ecc_key->puby_key = NULL;
+    ecc_key->puby_key_size = 0;
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
+#ifdef BL2
+enum tfm_plat_err_t
+tfm_plat_get_rotpk_hash(uint8_t image_id,
+                        uint8_t *rotpk_hash,
+                        uint32_t *rotpk_hash_size)
+{
+    int rc = 0;
+
+    rc = crypto_hw_accelerator_get_rotpk_hash(image_id, rotpk_hash,
+                                              rotpk_hash_size);
+
+    if (rc) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+#endif /* BL2 */
diff --git a/lib/tf-m/platform/ext/target/arm/musca_s1/partition/flash_layout.h b/lib/tf-m/platform/ext/target/arm/musca_s1/partition/flash_layout.h
index b8a910286..ae18715c7 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_s1/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/arm/musca_s1/partition/flash_layout.h
@@ -26,11 +26,11 @@
  * 0x0A16_0000 Non-secure image secondary (512 KB)
  * 0x0A1E_0000 Scratch Area (16 KB)
  * 0x0A1E_4000 Internal Trusted Storage Area (16 KB)
- * 0x0A1E_8000 OTP / NV counter area (8 KB)
- * 0x0A1E_A000 TF-M key area (256 bytes) This area is referred to in
-               /lib/ext/cryptocell-312-runtime/shared/hw/include/arm/musca_s1/ \
+ * 0x0A1E_8000 NV counters area (4 KB)
+ * 0x0A1E_9000 TF-M key area (256 bytes) This area is referred to in
+ *             /lib/ext/cryptocell-312-runtime/shared/hw/include/arm/musca_s1/ \
  *             dx_reg_base_host.h Do not change one without changing the other.
- * 0x0A1E_A100 Unused
+ * 0x0A1E_9100 Unused
  * 0x0020_0000 Protected storage area (20 KB) This area is placed in the QSPI
  *             flash
  *
@@ -44,11 +44,11 @@
  *    0x0A16_0000 Non-secure image secondary (512 KB)
  * 0x0A1E_0000 Scratch Area (16 KB)
  * 0x0A1E_4000 Internal Trusted Storage Area (16 KB)
- * 0x0A1E_8000 OTP / NV counter area (8 KB)
- * 0x0A1E_A000 TF-M key area (256 bytes) This area is referred to in
-               /lib/ext/cryptocell-312-runtime/shared/hw/include/arm/musca_s1/ \
+ * 0x0A1E_8000 NV counters area (4 KB)
+ * 0x0A1E_9000 TF-M key area (256 bytes) This area is referred to in
+ *             /lib/ext/cryptocell-312-runtime/shared/hw/include/arm/musca_s1/ \
  *             dx_reg_base_host.h Do not change one without changing the other.
- * 0x0A1E_A100 Unused
+ * 0x0A1E_9100 Unused
  * 0x0020_0000 Protected storage area (20 KB) This area is placed in the QSPI
  *             flash
  *
@@ -147,15 +147,14 @@
                                          FLASH_AREA_SCRATCH_SIZE)
 #define FLASH_ITS_AREA_SIZE             (0x4000)   /* 16 KB */
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* TF-M crypto key area definitions */
-#define FLASH_TFM_CRYPTO_KEY_AREA_OFFSET   (FLASH_OTP_AREA_OFFSET + \
-                                            FLASH_OTP_AREA_SIZE)
+#define FLASH_TFM_CRYPTO_KEY_AREA_OFFSET   (FLASH_NV_COUNTERS_AREA_OFFSET + \
+                                            FLASH_NV_COUNTERS_AREA_SIZE)
 #define FLASH_TFM_CRYPTO_KEY_AREA_SIZE     (0x100)
 
 /* Offset and size definition in flash area used by assemble.py */
@@ -170,8 +169,6 @@
  * Name is defined in flash driver file: Driver_Flash_MRAM.c
  */
 #define FLASH_DEV_NAME Driver_FLASH0
-/* Smallest flash programmable unit in bytes */
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x1)
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -211,12 +208,11 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x1)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18) /* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
 
 /* Use MRAM to store Code data */
 #define S_ROM_ALIAS_BASE  (0x1A000000)
diff --git a/lib/tf-m/platform/ext/target/arm/musca_s1/partition/region_defs.h b/lib/tf-m/platform/ext/target/arm/musca_s1/partition/region_defs.h
index 4f7d246c4..ca8bb4b40 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_s1/partition/region_defs.h
+++ b/lib/tf-m/platform/ext/target/arm/musca_s1/partition/region_defs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -79,19 +79,8 @@
 #define BL2_TRAILER_SIZE     (0xC00)
 #endif /* BL2 */
 
-#if (MCUBOOT_IMAGE_NUMBER == 1) && \
-    (NS_IMAGE_PRIMARY_PARTITION_OFFSET > S_IMAGE_PRIMARY_PARTITION_OFFSET)
-/* If secure image and nonsecure image are concatenated, and nonsecure image
- * locates at the higher memory range, then the secure image does not need
- * the trailer area.
- */
-#define IMAGE_S_CODE_SIZE \
-            (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE)
-#else
 #define IMAGE_S_CODE_SIZE \
             (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
-#endif
-
 #define IMAGE_NS_CODE_SIZE \
             (FLASH_NS_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
 
diff --git a/lib/tf-m/platform/ext/target/arm/musca_s1/plat_test.c b/lib/tf-m/platform/ext/target/arm/musca_s1/plat_test.c
index edc29d1c4..cdfcfa209 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_s1/plat_test.c
+++ b/lib/tf-m/platform/ext/target/arm/musca_s1/plat_test.c
@@ -10,8 +10,58 @@
 #include "tfm_plat_test.h"
 #include "device_definition.h"
 
+#define USERLED_MASK                (0x3)
+#define BTN_WAIT_INIT_COUNTER_VALUE (10000u)
 #define TIMER_RELOAD_VALUE          (16*1024*1024)
 
+/**
+ * \brief Store the state of the mocked LED
+ *
+ * This variable have to be linked to the data section of the partition
+ * TFM_SP_CORE_TEST so that in case of in case of isolation within the secure
+ * domain the Core Test service can access it.
+ */
+uint32_t led_status
+    TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_CORE_TEST", "PSA-ROT")
+    = 0x02u;
+
+/**
+ * \brief Simulate user reaction time
+ */
+static void busy_wait_to_simulate_user(void)
+{
+    volatile uint32_t counter = BTN_WAIT_INIT_COUNTER_VALUE;
+    while (counter)
+    {
+        --counter;
+    }
+}
+
+void tfm_plat_test_wait_user_button_pressed(void)
+{
+    busy_wait_to_simulate_user();
+}
+
+void tfm_plat_test_wait_user_button_released(void)
+{
+    busy_wait_to_simulate_user();
+}
+
+uint32_t tfm_plat_test_get_led_status(void)
+{
+    return led_status;
+}
+
+void tfm_plat_test_set_led_status(uint32_t status)
+{
+    led_status = status & USERLED_MASK;
+}
+
+uint32_t tfm_plat_test_get_userled_mask(void)
+{
+    return USERLED_MASK;
+}
+
 void tfm_plat_test_secure_timer_start(void)
 {
     if (!timer_cmsdk_is_initialized(&CMSDK_TIMER0_DEV_S)) {
diff --git a/lib/tf-m/platform/ext/target/arm/musca_s1/spm_hal.c b/lib/tf-m/platform/ext/target/arm/musca_s1/spm_hal.c
index 39ec6f418..47898aeba 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_s1/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/musca_s1/spm_hal.c
@@ -5,12 +5,16 @@
  *
  */
 
+#include <stdio.h>
 #include "cmsis.h"
 #include "tfm_spm_hal.h"
 #include "tfm_platform_core_api.h"
 #include "target_cfg.h"
 #include "Driver_MPC.h"
+#include "mpu_armv8m_drv.h"
+#include "region_defs.h"
 #include "utilities.h"
+#include "region.h"
 
 /* Import MPC driver */
 extern ARM_DRIVER_MPC Driver_CODE_SRAM_MPC;
@@ -18,6 +22,28 @@ extern ARM_DRIVER_MPC Driver_CODE_SRAM_MPC;
 /* Get address of memory regions to configure MPU */
 extern const struct memory_region_limits memory_regions;
 
+struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
+
+enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
+                  bool privileged,
+                  const struct platform_data_t *platform_data)
+{
+    if (!platform_data) {
+        return TFM_PLAT_ERR_INVALID_INPUT;
+    }
+
+    if (platform_data->periph_ppc_bank != PPC_SP_DO_NOT_CONFIGURE) {
+        if (privileged) {
+            ppc_clr_secure_unpriv(platform_data->periph_ppc_bank,
+                                  platform_data->periph_ppc_loc);
+        } else {
+            ppc_en_secure_unpriv(platform_data->periph_ppc_bank,
+                                 platform_data->periph_ppc_loc);
+        }
+    }
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
 void MPC_Handler(void)
 {
     /* Clear MPC interrupt flag and pending MPC IRQ */
@@ -129,29 +155,3 @@ enum tfm_plat_err_t tfm_spm_hal_nvic_interrupt_enable(void)
 {
     return nvic_interrupt_enable();
 }
-
-#ifndef TFM_PSA_API
-
-enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
-                  bool privileged,
-                  const struct platform_data_t *platform_data)
-{
-    if (!platform_data) {
-        return TFM_PLAT_ERR_INVALID_INPUT;
-    }
-
-    if (platform_data->periph_ppc_bank != PPC_SP_DO_NOT_CONFIGURE) {
-        ppc_configure_to_secure(platform_data->periph_ppc_bank,
-                                platform_data->periph_ppc_loc);
-        if (privileged) {
-            ppc_clr_secure_unpriv(platform_data->periph_ppc_bank,
-                                  platform_data->periph_ppc_loc);
-        } else {
-            ppc_en_secure_unpriv(platform_data->periph_ppc_bank,
-                                 platform_data->periph_ppc_loc);
-        }
-    }
-    return TFM_PLAT_ERR_SUCCESS;
-}
-
-#endif /* TFM_PSA_API */
diff --git a/lib/tf-m/platform/ext/target/arm/musca_s1/tfm_hal_isolation.c b/lib/tf-m/platform/ext/target/arm/musca_s1/tfm_hal_isolation.c
index 6717ee280..5dd8cfc76 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_s1/tfm_hal_isolation.c
+++ b/lib/tf-m/platform/ext/target/arm/musca_s1/tfm_hal_isolation.c
@@ -1,30 +1,18 @@
 /*
- * Copyright (c) 2020-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
  */
 
-#include "array.h"
 #include "cmsis.h"
 #include "Driver_Common.h"
-#include "mmio_defs.h"
 #include "mpu_armv8m_drv.h"
 #include "region.h"
 #include "target_cfg.h"
 #include "tfm_hal_isolation.h"
-#include "tfm_peripherals_def.h"
-#include "tfm_core_utils.h"
-#include "load/partition_defs.h"
-#include "load/asset_defs.h"
-#include "load/spm_load_api.h"
-
-/* It can be retrieved from the MPU_TYPE register. */
-#define MPU_REGION_NUM                  8
 
 #ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
-static uint32_t n_configured_regions = 0;
-struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 
 #define MPU_REGION_VENEERS           0
 #define MPU_REGION_TFM_UNPRIV_CODE   1
@@ -42,8 +30,8 @@ REGION_DECLARE(Image$$, TFM_APP_CODE_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_CODE_END, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_END, $$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Base);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
 #ifdef TFM_SP_META_PTR_ENABLE
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Base);
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
@@ -68,6 +56,7 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     /* Set up static isolation boundaries inside SPE */
 #ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
     struct mpu_armv8m_region_cfg_t region_cfg;
+    struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 
     mpu_armv8m_clean(&dev_mpu_s);
 
@@ -82,7 +71,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
     /* TFM Core unprivileged code region */
     region_cfg.region_nr = MPU_REGION_TFM_UNPRIV_CODE;
@@ -97,14 +85,13 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
     /* NSPM PSP */
     region_cfg.region_nr = MPU_REGION_NS_STACK;
     region_cfg.region_base =
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base);
     region_cfg.region_limit =
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
     region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
     region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
     region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
@@ -112,7 +99,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
     /* RO region */
     region_cfg.region_nr = PARTITION_REGION_RO;
@@ -127,7 +113,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
     /* RW, ZI and stack as one region */
     region_cfg.region_nr = PARTITION_REGION_RW_STACK;
@@ -142,7 +127,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
 #ifdef TFM_SP_META_PTR_ENABLE
     /* TFM partition metadata pointer region */
@@ -158,7 +142,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 #endif
 
     mpu_armv8m_enable(&dev_mpu_s, PRIVILEGED_DEFAULT_ENABLE,
@@ -167,113 +150,3 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
 
     return TFM_HAL_SUCCESS;
 }
-
-/*
- * Implementation of tfm_hal_bind_boundaries() on MUSCA_S1:
- *
- * The API encodes some attributes into a handle and returns it to SPM.
- * The attributes include isolation boundaries, privilege, and MMIO information.
- * When scheduler switches running partitions, SPM compares the handle between
- * partitions to know if boundary update is necessary. If update is required,
- * SPM passes the handle to platform to do platform settings and update
- * isolation boundaries.
- */
-enum tfm_hal_status_t tfm_hal_bind_boundaries(
-                                    const struct partition_load_info_t *p_ldinf,
-                                    void **pp_boundaries)
-{
-    uint32_t i, j;
-    bool privileged;
-    const struct asset_desc_t *p_asset;
-    struct platform_data_t *plat_data_ptr;
-#if TFM_LVL == 2
-    struct mpu_armv8m_region_cfg_t localcfg;
-#endif
-    if (!p_ldinf || !pp_boundaries) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-
-#if TFM_LVL == 1
-    privileged = true;
-#else
-    privileged = !!(p_ldinf->flags & SPM_PART_FLAG_PSA_ROT);
-#endif
-
-    p_asset = (const struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
-
-    /*
-     * Validate if partition MMIO is allowed by the platform. Below cases are
-     * allowed:
-     * 1. A named mmio is matched.
-     * 2. It is a memory asset.
-     *
-     * NOTE: Add validation of numbered MMIO if platform requires.
-     */
-    for (i = 0; i < p_ldinf->nassets; i++) {
-        if (!(p_asset[i].attr & ASSET_ATTR_NAMED_MMIO)) {
-            continue;
-        }
-        for (j = 0; j < ARRAY_SIZE(partition_named_mmio_list); j++) {
-            if (p_asset[i].dev.dev_ref == partition_named_mmio_list[j]) {
-                break;
-            }
-        }
-
-        if (j == ARRAY_SIZE(partition_named_mmio_list)) {
-            /* The MMIO asset is not in the allowed list of platform. */
-            return TFM_HAL_ERROR_GENERIC;
-        }
-        /* Assume PPC & MPC settings are required even under level 1 */
-        plat_data_ptr = REFERENCE_TO_PTR(p_asset[i].dev.dev_ref,
-                                         struct platform_data_t *);
-
-        ppc_configure_to_secure(plat_data_ptr->periph_ppc_bank,
-                                plat_data_ptr->periph_ppc_loc);
-        if (privileged) {
-            ppc_clr_secure_unpriv(plat_data_ptr->periph_ppc_bank,
-                                  plat_data_ptr->periph_ppc_loc);
-        } else {
-            ppc_en_secure_unpriv(plat_data_ptr->periph_ppc_bank,
-                                 plat_data_ptr->periph_ppc_loc);
-        }
-#if TFM_LVL == 2
-        /*
-         * Static boundaries are set. Set up MPU region for MMIO.
-         * Setup regions for unprivileged assets only.
-         */
-        if (!privileged) {
-            localcfg.region_base = plat_data_ptr->periph_start;
-            localcfg.region_limit = plat_data_ptr->periph_limit;
-            localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
-            localcfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
-            localcfg.attr_sh = MPU_ARMV8M_SH_NONE;
-            localcfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
-            localcfg.region_nr = n_configured_regions++;
-
-            if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg)
-                != MPU_ARMV8M_OK) {
-                return TFM_HAL_ERROR_GENERIC;
-            }
-        }
-#endif
-    }
-
-    *pp_boundaries = (void *)(((uint32_t)privileged) & HANDLE_ATTR_PRIV_MASK);
-
-    return TFM_HAL_SUCCESS;
-}
-
-enum tfm_hal_status_t tfm_hal_update_boundaries(
-                             const struct partition_load_info_t *p_ldinf,
-                             void *p_boundaries)
-{
-    CONTROL_Type ctrl;
-    bool privileged = !!(((uint32_t)p_boundaries) & HANDLE_ATTR_PRIV_MASK);
-
-    /* Privileged level is required to be set always */
-    ctrl.w = __get_CONTROL();
-    ctrl.b.nPRIV = privileged ? 0 : 1;
-    __set_CONTROL(ctrl.w);
-
-    return TFM_HAL_SUCCESS;
-}
diff --git a/lib/tf-m/platform/ext/target/arm/musca_s1/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/arm/musca_s1/tfm_peripherals_def.h
index 92a96fbae..b4f8b0f8c 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_s1/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/arm/musca_s1/tfm_peripherals_def.h
@@ -15,12 +15,6 @@
 extern "C" {
 #endif
 
-/*
- * Quantized default IRQ priority, the value is:
- * (Number of configurable priority) / 4: (1UL << __NVIC_PRIO_BITS) / 4
- */
-#define DEFAULT_IRQ_PRIORITY    (1UL << (__NVIC_PRIO_BITS - 2))
-
 #define TFM_TIMER0_IRQ           (TIMER0_IRQn)
 #define TFM_TIMER1_IRQ           (TIMER1_IRQn)
 #define FF_TEST_UART_IRQ         (UART1_Tx_IRQn)
@@ -33,6 +27,7 @@ extern struct platform_data_t tfm_peripheral_timer0;
 
 #define TFM_PERIPHERAL_STD_UART     (&tfm_peripheral_std_uart)
 #define TFM_PERIPHERAL_TIMER0       (&tfm_peripheral_timer0)
+#define TFM_PERIPHERAL_FPGA_IO      (0)
 
 #ifdef PSA_API_TEST_IPC
 extern struct platform_data_t tfm_peripheral_FF_TEST_UART_REGION;
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/armclang/startup_psoc64_s.s b/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/armclang/startup_psoc64_s.s
index 1b3c8fb3e..4f35894e5 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/armclang/startup_psoc64_s.s
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/armclang/startup_psoc64_s.s
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2017-2021 ARM Limited
+; * Copyright (c) 2017-2018 ARM Limited
 ; * Copyright (c) 2019-2021, Cypress Semiconductor Corporation. All rights reserved.
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
@@ -35,7 +35,7 @@ CY_CPU_VTOR_ADDR       EQU    0xE000ED08
 
                 PRESERVE8
 
-                IMPORT |Image$$ARM_LIB_STACK$$ZI$$Limit|
+                IMPORT |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|
 
 ; Vector Table Mapped to Address 0 at Reset
 
@@ -52,7 +52,7 @@ CY_CPU_VTOR_ADDR       EQU    0xE000ED08
                 IMPORT  Cy_SysIpcPipeIsrCm0
 
 __Vectors       ;Core Interrupts
-                DCD     |Image$$ARM_LIB_STACK$$ZI$$Limit|  ; Top of Stack
+                DCD     |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|  ; Top of Stack
                 DCD     Reset_Handler             ; Reset Handler
                 DCD     CY_NMI_HANLDER_ADDR       ; NMI Handler
                 DCD     HardFault_Handler         ; Hard Fault Handler
@@ -134,8 +134,11 @@ Vectors_Copy
                 LDR     R0, =SystemInit
                 BLX     R0
                 MOV     R3, SP
+                MRS     R0, control    ; Get control value
                 MOVS    R1, #2
+                ORRS    R0, R0, R1     ; Select switch to PSP
 
+                MSR     control, R0
                 MOV     SP, R3
                 LDR     R0, =__main
                 BX      R0
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/device_definition.c b/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/device_definition.c
index 1ac1312b9..15d01bc75 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/device_definition.c
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/device_definition.c
@@ -63,9 +63,9 @@ const cy_stc_scb_uart_config_t KITPROG_UART_config =
 /* TCPWM Timer driver structures */
 #if defined(CY_TCPWM0_TIMER0_S)
 cy_stc_tcpwm_counter_config_t tcpwm_config_timer0
-#if defined(TEST_NS_SLIH_IRQ)
+#if defined(TFM_ENABLE_SLIH_TEST)
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
-#endif /* TEST_NS_SLIH_IRQ */
+#endif /* TFM_ENABLE_SLIH_TEST */
     = {
     .period             = TIMER0_MATCH, /* Upper limit (wrap around) */
     .clockPrescaler     = CY_TCPWM_COUNTER_PRESCALER_DIVBY_8, /* Clk_counter = Clk_input / 8 */
@@ -90,9 +90,9 @@ cy_stc_tcpwm_counter_config_t tcpwm_config_timer0
 
 #if (CY_CPU_CORTEX_M0P)
 cy_stc_sysint_t CY_TCPWM_NVIC_CFG_S
-#if defined(TEST_NS_SLIH_IRQ)
+#if defined(TFM_ENABLE_SLIH_TEST)
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
-#endif /* TEST_NS_SLIH_IRQ */
+#endif /* TFM_ENABLE_SLIH_TEST */
     = {
     .intrSrc = TFM_TIMER0_IRQ,             /* NVIC #3 */
     .cm0pSrc = tcpwm_0_interrupts_0_IRQn,  /* IRQ 123 */
@@ -100,9 +100,9 @@ cy_stc_sysint_t CY_TCPWM_NVIC_CFG_S
 };
 #endif
 tfm_timer_irq_test_dev_t CY_TCPWM0_TIMER0_DEV_S
-#if defined(TEST_NS_SLIH_IRQ)
+#if defined(TFM_ENABLE_SLIH_TEST)
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
-#endif /* TEST_NS_SLIH_IRQ */
+#endif /* TFM_ENABLE_SLIH_TEST */
     = {
     .is_initialized     = false,
     .tcpwm_base         = TCPWM0,
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/gcc/startup_psoc64_s.S b/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/gcc/startup_psoc64_s.S
index 79b5b0503..d66552478 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/gcc/startup_psoc64_s.S
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/gcc/startup_psoc64_s.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009-2021 ARM Limited. All rights reserved.
+ * Copyright (c) 2009-2020 ARM Limited. All rights reserved.
  * Copyright (c) 2019-2020, Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: Apache-2.0
@@ -35,7 +35,7 @@
     .align 2
     .globl    __Vectors
 __Vectors:
-    .long    Image$$ARM_LIB_STACK$$ZI$$Limit /* Top of Stack */
+    .long    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit /* Top of Stack */
     .long    Reset_Handler         /* Reset Handler */
     .long    CY_NMI_HANLDER_ADDR   /* NMI Handler */
     .long    HardFault_Handler     /* Hard Fault Handler */
@@ -272,6 +272,13 @@ Reset_Handler:
     bl    SystemInit
 #endif
 
+    mrs     r0, control    /* Get control value */
+    movs    r1, #2
+    orrs    r0, r0, r1     /* Select switch to PSP */
+    msr     control, r0
+    ldr r0, =Image$$ARM_LIB_STACK$$ZI$$Limit
+    msr     psp, r0
+
     bl    main
 
     /* Should never get here */
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/iar/startup_psoc64_s.s b/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/iar/startup_psoc64_s.s
index b2ec922f6..2f39f0fd7 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/iar/startup_psoc64_s.s
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/Device/Source/iar/startup_psoc64_s.s
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2017-2021 ARM Limited
+; * Copyright (c) 2017-2018 ARM Limited
 ; * Copyright (c) 2019-2020, Cypress Semiconductor Corporation. All rights reserved.
 ; * Copyright (c) 2020-2021 IAR Systems AB
 ; *
@@ -37,6 +37,7 @@ CY_CPU_VTOR_ADDR       EQU    0xE000ED08
 
 ; Vector Table Mapped to Address 0 at Reset
 
+                SECTION  ARM_LIB_STACK_MSP:DATA:NOROOT(3)
                 SECTION  ARM_LIB_STACK:DATA:NOROOT(3)
 
                 SECTION  .intvec:CODE:NOROOT(2)
@@ -58,7 +59,7 @@ CY_CPU_VTOR_ADDR       EQU    0xE000ED08
                 DATA
 
 __vector_table       ;Core Interrupts
-                DCD     sfe(ARM_LIB_STACK)        ; Top of Stack
+                DCD     sfe(ARM_LIB_STACK_MSP)    ; Top of Stack
                 DCD     Reset_Handler             ; Reset Handler
                 DCD     CY_NMI_HANLDER_ADDR       ; NMI Handler
                 DCD     HardFault_Handler         ; Hard Fault Handler
@@ -132,6 +133,12 @@ Vectors_Copy
 
                 LDR     R0, =SystemInit
                 BLX     R0
+                LDR     R0, =sfe(ARM_LIB_STACK)      ; End of PROC_STACK
+                MSR     PSP, R0
+                MRS     R0, control    ; Get control value
+                MOVS    R1, #2
+                ORRS    R0, R0, R1     ; Select switch to PSP
+                MSR     control, R0
                 LDR     R0, =__iar_program_start
                 BX      R0
 End_Of_Main
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/driver_smpu.c b/lib/tf-m/platform/ext/target/cypress/psoc64/driver_smpu.c
index 402322200..663d55dd1 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/driver_smpu.c
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/driver_smpu.c
@@ -24,7 +24,6 @@
 #include "tfm_hal_its.h"
 #include "tfm_hal_ps.h"
 #include "tfm_memory_utils.h"
-#include "flash_layout.h"
 
 #include "cy_prot.h"
 
@@ -239,9 +238,8 @@ static cy_en_prot_status_t get_region(const PROT_SMPU_SMPU_STRUCT_Type *smpu,
         *base = its_fs_info.flash_area_addr;
         *size = its_fs_info.flash_area_size;
     } else if (smpu == NVC_SMPU_STRUCT) {
-        /* Retrieve the OTP / NV area info */
-        *base = FLASH_OTP_NV_COUNTERS_AREA_OFFSET;
-        *size = FLASH_OTP_NV_COUNTERS_AREA_SIZE;
+        /* Retrieve the non-volatile counters region definition */
+        nvc_flash_block(base, size);
     } else if (smpu == PS_SMPU_STRUCT) {
         struct tfm_hal_ps_fs_info_t ps_fs_info;
         /* Retrieve the PS region definition */
diff --git a/tf-m.old/platform/ext/target/cypress/psoc64/nv_counters.c b/lib/tf-m/platform/ext/target/cypress/psoc64/nv_counters.c
new file mode 100644
index 000000000..79154d7ee
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/nv_counters.c
@@ -0,0 +1,265 @@
+/*
+ * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
+ * Copyright (c) 2020, Cypress Semiconductor Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#include "tfm_plat_nv_counters.h"
+
+#include <limits.h>
+#include <stddef.h>
+#include "Driver_Flash.h"
+#include "flash_layout.h"
+#include "nv_counters.h"
+
+/* Compilation time checks to be sure the defines are well defined */
+#ifndef TFM_NV_COUNTERS_AREA_SIZE
+#error "TFM_NV_COUNTERS_AREA_SIZE must be defined in flash_layout.h"
+#endif
+
+#ifndef TFM_NV_COUNTERS_SECTOR_ADDR
+#error "TFM_NV_COUNTERS_SECTOR_ADDR must be defined in flash_layout.h"
+#endif
+
+#ifndef TFM_NV_COUNTERS_SECTOR_SIZE
+#error "TFM_NV_COUNTERS_SECTOR_SIZE must be defined in flash_layout.h"
+#endif
+
+#ifndef TFM_NV_COUNTERS_FLASH_DEV
+#error "TFM_NV_COUNTERS_FLASH_DEV must be defined in flash_layout.h"
+#endif
+/* End of compilation time checks to be sure the defines are well defined */
+
+#define SECTOR_OFFSET    0
+#define NV_COUNTER_SIZE  sizeof(uint32_t)
+#define INIT_VALUE_SIZE  sizeof(uint32_t)
+#define CHECKSUM_SIZE    sizeof(uint32_t)
+#define NUM_NV_COUNTERS  ((TFM_NV_COUNTERS_SECTOR_SIZE - INIT_VALUE_SIZE \
+                            - CHECKSUM_SIZE) / NV_COUNTER_SIZE)
+
+#define NV_COUNTERS_INITIALIZED 0xC0DE0042
+
+static uint32_t nv_counters_offset;
+#define BACKUP_ADDRESS (nv_counters_offset + TFM_NV_COUNTERS_SECTOR_SIZE)
+
+/**
+ * \brief Struct representing the NV counter data in flash.
+ */
+struct nv_counters_t {
+    uint32_t checksum;
+    uint32_t init_value; /**< Watermark to indicate if the NV counters have been
+                          *   initialised
+                          */
+    uint32_t counters[NUM_NV_COUNTERS]; /**< Array of NV counters */
+};
+
+/* Import the CMSIS flash device driver */
+extern ARM_DRIVER_FLASH TFM_NV_COUNTERS_FLASH_DEV;
+
+static uint32_t calc_checksum(const uint32_t *data, size_t len)
+{
+    uint32_t sum = 0;
+
+    for (uint32_t i = 0; i < len/sizeof(uint32_t); i++) {
+        sum ^= data[i];
+    }
+    return sum;
+}
+
+static bool is_valid(const struct nv_counters_t *nv_counters)
+{
+    return ((nv_counters->init_value == NV_COUNTERS_INITIALIZED) &&
+            (!calc_checksum(&nv_counters->checksum, sizeof(*nv_counters))));
+}
+
+static void set_checksum(struct nv_counters_t *nv_counters)
+{
+    uint32_t sum = calc_checksum(&nv_counters->init_value,
+                                 sizeof(*nv_counters)
+                                  - sizeof(nv_counters->checksum));
+
+    nv_counters->checksum = sum;
+}
+
+void nvc_flash_block(uint32_t *base, size_t *size)
+{
+    *base = FLASH_NV_COUNTERS_AREA_OFFSET;
+    *size = FLASH_NV_COUNTERS_AREA_SIZE;
+}
+
+enum tfm_plat_err_t tfm_plat_init_nv_counter(void)
+{
+    int32_t  err;
+    uint32_t i;
+    struct nv_counters_t nv_counters;
+    size_t size;
+
+    /* Get the base address and size */
+    nvc_flash_block(&nv_counters_offset, &size);
+
+    /* Verify that the size is exactly two sectors */
+    if (size != 2 * TFM_NV_COUNTERS_SECTOR_SIZE) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    err = TFM_NV_COUNTERS_FLASH_DEV.Initialize(NULL);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    /* Read the whole sector so we can write it back to flash later */
+    err = TFM_NV_COUNTERS_FLASH_DEV.ReadData(nv_counters_offset,
+                                             &nv_counters,
+                                             TFM_NV_COUNTERS_SECTOR_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    if (is_valid(&nv_counters)) {
+        return TFM_PLAT_ERR_SUCCESS;
+    }
+
+    /* Check the backup watermark */
+    err = TFM_NV_COUNTERS_FLASH_DEV.ReadData(BACKUP_ADDRESS,
+                                             &nv_counters,
+                                             TFM_NV_COUNTERS_SECTOR_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    /* Erase sector before writing to it */
+    err = TFM_NV_COUNTERS_FLASH_DEV.EraseSector(nv_counters_offset);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    if (is_valid(&nv_counters)) {
+        /* Copy from the backup to the main */
+        err = TFM_NV_COUNTERS_FLASH_DEV.ProgramData(nv_counters_offset,
+                                                    &nv_counters,
+                                                    TFM_NV_COUNTERS_SECTOR_SIZE);
+        if (err != ARM_DRIVER_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+
+        return TFM_PLAT_ERR_SUCCESS;
+    }
+
+    /* Add watermark to indicate that NV counters have been initialized */
+    nv_counters.init_value = NV_COUNTERS_INITIALIZED;
+
+    /* Initialize all counters to 0 */
+    for (i = 0; i < NUM_NV_COUNTERS; i++) {
+        nv_counters.counters[i] = 0;
+    }
+
+    set_checksum(&nv_counters);
+
+    /* Write the in-memory block content after modification to flash */
+    err = TFM_NV_COUNTERS_FLASH_DEV.ProgramData(nv_counters_offset,
+                                                &nv_counters,
+                                                TFM_NV_COUNTERS_SECTOR_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
+enum tfm_plat_err_t tfm_plat_read_nv_counter(enum tfm_nv_counter_t counter_id,
+                                             uint32_t size, uint8_t *val)
+{
+    int32_t  err;
+    uint32_t flash_addr = nv_counters_offset
+                           + offsetof(struct nv_counters_t, counters)
+                           + (counter_id * NV_COUNTER_SIZE);
+
+    if (size != NV_COUNTER_SIZE) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    err = TFM_NV_COUNTERS_FLASH_DEV.ReadData(flash_addr, val, NV_COUNTER_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
+enum tfm_plat_err_t tfm_plat_set_nv_counter(enum tfm_nv_counter_t counter_id,
+                                            uint32_t value)
+{
+    int32_t  err;
+    struct nv_counters_t nv_counters;
+
+    /* Read the whole sector so we can write it back to flash later */
+    err = TFM_NV_COUNTERS_FLASH_DEV.ReadData(nv_counters_offset,
+                                             &nv_counters,
+                                             TFM_NV_COUNTERS_SECTOR_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    if (value != nv_counters.counters[counter_id]) {
+
+        if (value < nv_counters.counters[counter_id]) {
+            return TFM_PLAT_ERR_INVALID_INPUT;
+        }
+
+        /* Erase backup sector */
+        err = TFM_NV_COUNTERS_FLASH_DEV.EraseSector(BACKUP_ADDRESS);
+        if (err != ARM_DRIVER_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+
+        nv_counters.counters[counter_id] = value;
+
+        set_checksum(&nv_counters);
+
+        /* write sector data to backup sector */
+        err = TFM_NV_COUNTERS_FLASH_DEV.ProgramData(BACKUP_ADDRESS,
+                                                    &nv_counters,
+                                                    TFM_NV_COUNTERS_SECTOR_SIZE);
+        if (err != ARM_DRIVER_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+
+        /* Erase sector before writing to it */
+        err = TFM_NV_COUNTERS_FLASH_DEV.EraseSector(nv_counters_offset);
+        if (err != ARM_DRIVER_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+
+        /* Write the in-memory block content after modification to flash */
+        err = TFM_NV_COUNTERS_FLASH_DEV.ProgramData(nv_counters_offset,
+                                                    &nv_counters,
+                                                    TFM_NV_COUNTERS_SECTOR_SIZE);
+        if (err != ARM_DRIVER_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+    }
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
+enum tfm_plat_err_t tfm_plat_increment_nv_counter(
+                                           enum tfm_nv_counter_t counter_id)
+{
+    uint32_t security_cnt;
+    enum tfm_plat_err_t err;
+
+    err = tfm_plat_read_nv_counter(counter_id,
+                                   sizeof(security_cnt),
+                                   (uint8_t *)&security_cnt);
+    if (err != TFM_PLAT_ERR_SUCCESS) {
+        return err;
+    }
+
+    if (security_cnt == UINT32_MAX) {
+        return TFM_PLAT_ERR_MAX_VALUE;
+    }
+
+    return tfm_plat_set_nv_counter(counter_id, security_cnt + 1u);
+}
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/partition/flash_layout.h b/lib/tf-m/platform/ext/target/cypress/psoc64/partition/flash_layout.h
index 4dc9b7d17..71d893f8b 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/partition/flash_layout.h
@@ -30,8 +30,8 @@
  * 0x101c_0000 - 0x101f_ffff Reserved
  *  0x101c_0000 Internal Trusted Storage Area (16 KB)
  *  0x101c_4000 Protected Storage Area (24 KB)
- *  0x101c_a000 Unused area (22 KB)
- *  0x101c_f800 OTP / NV counters area (2 KB)
+ *  0x101c_a000 Unused area (23 KB)
+ *  0x101c_fc00 NV counters area (1 KB)
  *  0x101d_0000 Reserved (192 KB)
  * 0x101f_ffff End of Flash
  *
@@ -80,13 +80,12 @@
 /* Unused Area */
 #define FLASH_UNUSED_AREA_OFFSET        (FLASH_PS_AREA_OFFSET + \
                                          FLASH_PS_AREA_SIZE)
-#define FLASH_UNUSED_AREA_SIZE          (0x5800)   /* 22 KB */
+#define FLASH_UNUSED_AREA_SIZE          (0x5c00)   /* 23 KB */
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_UNUSED_AREA_OFFSET + \
-                                           FLASH_UNUSED_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 4)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
+/* Non-volatile Counters Area */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_UNUSED_AREA_OFFSET + \
+                                         FLASH_UNUSED_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (2 * FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 #define FLASH_AREA_SYSTEM_RESERVED_SIZE (0x30000) /* 192 KB */
 
@@ -107,15 +106,13 @@
 #define FLASH_DATA_AREA_SIZE            (FLASH_ITS_AREA_SIZE + \
                                          FLASH_PS_AREA_SIZE + \
                                          FLASH_UNUSED_AREA_SIZE + \
-                                         FLASH_OTP_NV_COUNTERS_AREA_SIZE + \
+                                         FLASH_NV_COUNTERS_AREA_SIZE + \
                                          FLASH_AREA_SYSTEM_RESERVED_SIZE)
 
 #if (FLASH_DATA_AREA_OFFSET + FLASH_DATA_AREA_SIZE) > (FLASH_TOTAL_SIZE)
 #error "Out of Flash memory"
 #endif
 
-#define TFM_HAL_FLASH_PROGRAM_UNIT      0x1
-
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
  * TF-M PS Integration Guide.
@@ -158,13 +155,11 @@
 /* Decrease flash wear slightly, at the cost of increased ITS service memory */
 #define ITS_MAX_BLOCK_DATA_COPY 512
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
-
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_FLASH_DEV    Driver_FLASH0
+#define TFM_NV_COUNTERS_AREA_SIZE    FLASH_NV_COUNTERS_AREA_SIZE
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
 
 /* Use Flash to store Code data */
 #define S_ROM_ALIAS_BASE  (0x10000000)
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/spm_hal.c b/lib/tf-m/platform/ext/target/cypress/psoc64/spm_hal.c
index fb912cc31..d7f9549bc 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/spm_hal.c
@@ -48,6 +48,19 @@ static enum tfm_plat_err_t handle_boot_wdt(void)
     return TFM_PLAT_ERR_SUCCESS;
 }
 
+enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
+        bool privileged,
+        const struct platform_data_t *platform_data)
+{
+    (void) privileged; /* Unused parameter */
+    if (!platform_data) {
+        return TFM_PLAT_ERR_INVALID_INPUT;
+    }
+    /* TBD */
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
 uint32_t tfm_spm_hal_get_ns_VTOR(void)
 {
     return memory_regions.non_secure_code_start;
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/target_cfg.c b/lib/tf-m/platform/ext/target/cypress/psoc64/target_cfg.c
index b0bcbe15c..f596b736c 100755
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/target_cfg.c
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/target_cfg.c
@@ -131,7 +131,7 @@ extern void Cy_Platform_Init(void);
 void platform_init(void)
 {
     cy_en_sysclk_status_t clk_rc;
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     cy_en_sysint_status_t int_rc;
 #endif
 
@@ -172,12 +172,12 @@ void platform_init(void)
 
     Cy_Platform_Init();
 
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     int_rc = Cy_SysInt_Init(&CY_TCPWM_NVIC_CFG_S, TFM_TIMER0_IRQ_Handler);
     if (int_rc != CY_SYSINT_SUCCESS) {
         SPMLOG_INFMSG("WARNING: Fail to initialize timer interrupt (IRQ TEST might fail)!\r\n");
     }
-#endif /* TEST_NS_SLIH_IRQ */
+#endif /* TFM_ENABLE_SLIH_TEST */
 
     /* make sure CM4 is disabled */
     if (CY_SYS_CM4_STATUS_ENABLED == Cy_SysGetCM4Status()) {
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/tfm_hal_isolation.c b/lib/tf-m/platform/ext/target/cypress/psoc64/tfm_hal_isolation.c
index 098e639a2..992ea3074 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/tfm_hal_isolation.c
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/tfm_hal_isolation.c
@@ -5,17 +5,12 @@
  *
  */
 
-#include "array.h"
 #include "cy_device.h"
-#include "mmio_defs.h"
 #include "target_cfg.h"
 #include "tfm_api.h"
 #include "tfm_hal_defs.h"
 #include "tfm_multi_core.h"
 #include "tfm_plat_defs.h"
-#include "tfm_peripherals_def.h"
-#include "load/asset_defs.h"
-#include "load/spm_load_api.h"
 
 enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
 {
@@ -49,73 +44,3 @@ enum tfm_hal_status_t tfm_hal_memory_has_access(uintptr_t base,
 
     return TFM_HAL_SUCCESS;
 }
-
-/*
- * Implementation of tfm_hal_bind_boundaries() on PSOC64:
- *
- * The API encodes some attributes into a handle and returns it to SPM.
- * The attributes include isolation boundaries, privilege, and MMIO information.
- * When scheduler switches running partitions, SPM compares the handle between
- * partitions to know if boundary update is necessary. If update is required,
- * SPM passes the handle to platform to do platform settings and update
- * isolation boundaries.
- */
-enum tfm_hal_status_t tfm_hal_bind_boundaries(
-                                    const struct partition_load_info_t *p_ldinf,
-                                    void **pp_boundaries)
-{
-    uint32_t i, j;
-    bool privileged;
-    const struct asset_desc_t *p_asset;
-
-    if (!p_ldinf || !pp_boundaries) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-
-#if TFM_LVL == 1
-    privileged = true;
-#else
-    privileged = !!(p_ldinf->flags & SPM_PART_FLAG_PSA_ROT);
-#endif
-
-    p_asset = (const struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
-
-    /*
-     * Validate if the named MMIO of partition is allowed by the platform.
-     * Otherwise, skip validation.
-     *
-     * NOTE: Need to add validation of numbered MMIO if platform requires.
-     */
-    for (i = 0; i < p_ldinf->nassets; i++) {
-        if (!(p_asset[i].attr & ASSET_ATTR_NAMED_MMIO)) {
-            continue;
-        }
-        for (j = 0; j < ARRAY_SIZE(partition_named_mmio_list); j++) {
-            if (p_asset[i].dev.dev_ref == partition_named_mmio_list[j]) {
-                break;
-            }
-        }
-
-        if (j == ARRAY_SIZE(partition_named_mmio_list)) {
-            return TFM_HAL_ERROR_GENERIC;
-        }
-    }
-    *pp_boundaries = (void *)(((uint32_t)privileged) & HANDLE_ATTR_PRIV_MASK);
-
-    return TFM_HAL_SUCCESS;
-}
-
-enum tfm_hal_status_t tfm_hal_update_boundaries(
-                             const struct partition_load_info_t *p_ldinf,
-                             void *p_boundaries)
-{
-    CONTROL_Type ctrl;
-    bool privileged = !!((uint32_t)p_boundaries & HANDLE_ATTR_PRIV_MASK);
-
-    /* Privileged level is required to be set always */
-    ctrl.w = __get_CONTROL();
-    ctrl.b.nPRIV = privileged ? 0 : 1;
-    __set_CONTROL(ctrl.w);
-
-    return TFM_HAL_SUCCESS;
-}
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/cypress/psoc64/tfm_peripherals_def.h
index 65c8ba0aa..7815ddac1 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/tfm_peripherals_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2019, Arm Limited. All rights reserved.
  * Copyright (c) 2020, Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -15,22 +15,19 @@
 extern "C" {
 #endif
 
-/*
- * Quantized default IRQ priority, the value is:
- * (Number of configurable priority) / 4: (1UL << __NVIC_PRIO_BITS) / 4
- */
-#define DEFAULT_IRQ_PRIORITY    (1UL << (__NVIC_PRIO_BITS - 2))
-
 #define TFM_TIMER0_IRQ              (NvicMux3_IRQn)
 #define TFM_TIMER1_IRQ              (tcpwm_0_interrupts_1_IRQn)
 
 struct platform_data_t;
 
 extern struct platform_data_t tfm_peripheral_std_uart;
+extern struct platform_data_t tfm_peripheral_uart1;
 extern struct platform_data_t tfm_peripheral_timer0;
 
 #define TFM_PERIPHERAL_STD_UART     (&tfm_peripheral_std_uart)
+#define TFM_PERIPHERAL_UART1        (&tfm_peripheral_uart1)
 #define TFM_PERIPHERAL_TIMER0       (&tfm_peripheral_timer0)
+#define TFM_PERIPHERAL_FPGA_IO      (0)
 
 #ifdef __cplusplus
 }
diff --git a/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/partition/flash_layout.h b/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/partition/flash_layout.h
index 3dc29f507..4b1cc922d 100644
--- a/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/partition/flash_layout.h
@@ -28,7 +28,8 @@
  *    0x000B_0000 Non-secure image primary (256 KB)
  * 0x000f_0000 Protected Storage area (16 KB)
  * 0x000f_4000 Internal Trusted Storage area (8 KB)
- * 0x000f_6000 OTP / NV counters area (8 KB)
+ * 0x000f_6000 NV counters main area (4 KB)
+ * 0x000f_7000 NV counters backup area (4 KB)
  * 0x000f_8000 Unused (optional NVS used in Zephyr) (32 KB)
  * QSPI:
  * 0x0000_0000 Secondary image area (896 KB):
@@ -46,7 +47,8 @@
  *    0x000A_0000 Non-secure image primary (320 KB)
  * 0x000f_0000 Protected Storage main area (16 KB)
  * 0x000f_4000 Internal Trusted Storage main area (8 KB)
- * 0x000f_6000 OTP / NV counters area (8 KB)
+ * 0x000f_6000 NV counters main area (4 KB)
+ * 0x000f_7000 NV counters backup area (4 KB)
  * 0x000f_8000 Unused (optional NVS used in Zephyr) (32 KB)
  * QSPI:
  * 0x0000_0000 Unused (1 MB)
@@ -172,12 +174,10 @@
                                          FLASH_PS_AREA_SIZE)
 #define FLASH_ITS_AREA_SIZE             (0x2000)   /* 8 KB */
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
-
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* Offset and size definition in flash area used by assemble.py */
 #define SECURE_IMAGE_OFFSET             (0x0)
@@ -191,7 +191,6 @@
  * Name is defined in flash driver file: Driver_Flash.c
  */
 #define FLASH_DEV_NAME Driver_FLASH0
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x4)
 
 /* Flash device name used by secondary slot and scratch area
  * Name is defined in flash driver file: Driver_QSPI.c
@@ -246,13 +245,15 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x4)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counter definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18) /* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
 
+/* Backup NV Counter definitions */
+#define TFM_NV_COUNTERS_BACKUP_AREA_ADDR    (FLASH_NV_COUNTERS_AREA_OFFSET + FLASH_AREA_IMAGE_SECTOR_SIZE)
+#define TFM_NV_COUNTERS_BACKUP_SECTOR_ADDR  (FLASH_NV_COUNTERS_AREA_OFFSET + FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* Use Flash memory to store Code data */
 #define FLASH_BASE_ADDRESS (0x00000000)
diff --git a/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/partition/region_defs.h b/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/partition/region_defs.h
index a95a515e5..281a29d9f 100644
--- a/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/partition/region_defs.h
+++ b/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/partition/region_defs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
  * Copyright (c) 2020 Nordic Semiconductor ASA. All rights reserved.
  * Copyright (c) 2021 Laird Connectivity. All rights reserved.
  *
@@ -85,19 +85,8 @@
 #define BL2_TRAILER_SIZE     (0x800)
 #endif /* BL2 */
 
-#if (MCUBOOT_IMAGE_NUMBER == 1) && \
-    (NS_IMAGE_PRIMARY_PARTITION_OFFSET > S_IMAGE_PRIMARY_PARTITION_OFFSET)
-/* If secure image and nonsecure image are concatenated, and nonsecure image
- * locates at the higher memory range, then the secure image does not need
- * the trailer area.
- */
-#define IMAGE_S_CODE_SIZE \
-            (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE)
-#else
 #define IMAGE_S_CODE_SIZE \
             (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
-#endif
-
 #define IMAGE_NS_CODE_SIZE \
             (FLASH_NS_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
 
diff --git a/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/target_cfg.c b/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/target_cfg.c
index f4b8ee63d..8077176af 100644
--- a/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/target_cfg.c
+++ b/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/target_cfg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2020 Arm Limited. All rights reserved.
  * Copyright (c) 2020 Nordic Semiconductor ASA.
  * Copyright (c) 2021 Laird Connectivity.
  *
@@ -38,6 +38,13 @@ struct platform_data_t tfm_peripheral_std_uart = {
         NRF_UARTE1_S_BASE + (sizeof(NRF_UARTE_Type) - 1),
 };
 
+#ifdef CORE_TEST_INTERACTIVE
+struct platform_data_t tfm_peripheral_std_i2c = {
+        NRF_TWIM2_S_BASE,
+        NRF_TWIM2_S_BASE + (sizeof(NRF_TWIM_Type) - 1),
+};
+#endif
+
 #ifdef SECURE_QSPI
 struct platform_data_t tfm_peripheral_std_qspi = {
         NRF_QSPI_S_BASE,
@@ -145,6 +152,13 @@ enum tfm_plat_err_t nvic_interrupt_target_state_cfg(void)
     NVIC_ClearTargetState(NRFX_IRQ_NUMBER_GET(NRF_UARTE1));
 #endif
 
+#ifdef CORE_TEST_INTERACTIVE
+    /* TWIM2 is a secure peripheral for the interactive test, so its IRQ has
+     * to target S state
+     */
+    NVIC_ClearTargetState(NRFX_IRQ_NUMBER_GET(NRF_TWIM2));
+#endif
+
     return TFM_PLAT_ERR_SUCCESS;
 }
 
@@ -210,6 +224,10 @@ enum tfm_plat_err_t spu_periph_init_cfg(void)
     spu_peripheral_config_non_secure((uint32_t)NRF_SPIM1, false);
 #endif
     spu_peripheral_config_non_secure((uint32_t)NRF_SPIM4, false);
+#ifndef CORE_TEST_INTERACTIVE
+    /* TWIM2 is a secure peripheral for the platform test, so we need to leave it as Secure */
+    spu_peripheral_config_non_secure((uint32_t)NRF_SPIM2, false);
+#endif
     spu_peripheral_config_non_secure((uint32_t)NRF_SPIM3, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_SAADC, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_TIMER0, false);
diff --git a/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/tfm_peripherals_def.h
index 31768fbc8..9c7658ae9 100644
--- a/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/lairdconnectivity/common/bl5340/tfm_peripherals_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2019, Arm Limited. All rights reserved.
  * Copyright (c) 2020, Cypress Semiconductor Corporation. All rights reserved.
  * Copyright (c) 2020, Nordic Semiconductor ASA. All rights reserved.
  * Copyright (c) 2021, Laird Connectivity. All rights reserved.
@@ -24,15 +24,22 @@ struct platform_data_t;
 
 extern struct platform_data_t tfm_peripheral_std_uart;
 extern struct platform_data_t tfm_peripheral_timer0;
+#ifdef CORE_TEST_INTERACTIVE
+extern struct platform_data_t tfm_peripheral_std_i2c;
+#endif
 #ifdef SECURE_QSPI
 extern struct platform_data_t tfm_peripheral_std_qspi;
 #endif
 
 #define TFM_PERIPHERAL_STD_UART     (&tfm_peripheral_std_uart)
 #define TFM_PERIPHERAL_TIMER0       (&tfm_peripheral_timer0)
+#ifdef CORE_TEST_INTERACTIVE
+#define TFM_PERIPHERAL_STD_I2C      (&tfm_peripheral_std_i2c)
+#endif
 #ifdef SECURE_QSPI
 #define TFM_PERIPHERAL_STD_QSPI     (&tfm_peripheral_std_qspi)
 #endif
+#define TFM_PERIPHERAL_FPGA_IO      (0)
 
 #ifdef __cplusplus
 }
diff --git a/tf-m.old/platform/ext/target/lairdconnectivity/common/core/nv_counters.c b/lib/tf-m/platform/ext/target/lairdconnectivity/common/core/nv_counters.c
new file mode 100644
index 000000000..6ae028f40
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/lairdconnectivity/common/core/nv_counters.c
@@ -0,0 +1,275 @@
+/*
+ * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
+ * Copyright (c) 2021, Laird Connectivity. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+/* NOTE: This API should be implemented by the end-user. For the security of
+ * the protected storage system's and the bootloader's rollback protection etc.
+ * it is CRITICAL to use a internal (in-die) persistent memory for multiple time
+ * programmable (MTP) non-volatile counters or use a One-time Programmable (OTP)
+ * non-volatile counters solution.
+ *
+ * This dummy implementation assumes that the NV counters are the only data in
+ * the flash sectors. To use it, two flash sectors should be allocated exclusively
+ * for the NV counters (one acts as a backup in case of power failure during write).
+ */
+
+#include "tfm_plat_nv_counters.h"
+
+#include <limits.h>
+#include "Driver_Flash.h"
+#include "flash_layout.h"
+
+/* Compilation time checks to be sure the defines are well defined */
+#ifndef TFM_NV_COUNTERS_AREA_ADDR
+#error "TFM_NV_COUNTERS_AREA_ADDR must be defined in flash_layout.h"
+#endif
+
+#ifndef TFM_NV_COUNTERS_AREA_SIZE
+#error "TFM_NV_COUNTERS_AREA_SIZE must be defined in flash_layout.h"
+#endif
+
+#ifndef TFM_NV_COUNTERS_SECTOR_ADDR
+#error "TFM_NV_COUNTERS_SECTOR_ADDR must be defined in flash_layout.h"
+#endif
+
+#ifndef TFM_NV_COUNTERS_SECTOR_SIZE
+#error "TFM_NV_COUNTERS_SECTOR_SIZE must be defined in flash_layout.h"
+#endif
+
+#if (TFM_NV_COUNTERS_BACKUP_AREA_ADDR || TFM_NV_COUNTERS_BACKUP_SECTOR_ADDR)
+#ifndef TFM_NV_COUNTERS_BACKUP_AREA_ADDR
+#error "TFM_NV_COUNTERS_BACKUP_AREA_ADDR must be defined in flash_layout.h as one or more backup NV counter defines are set"
+#endif
+#ifndef TFM_NV_COUNTERS_BACKUP_SECTOR_ADDR
+#error "TFM_NV_COUNTERS_BACKUP_SECTOR_ADDR must be defined in flash_layout.h as one or more backup NV counter defines are set"
+#endif
+#endif
+
+#ifndef NV_COUNTERS_FLASH_DEV_NAME
+    #ifndef FLASH_DEV_NAME
+    #error "NV_COUNTERS_FLASH_DEV_NAME or FLASH_DEV_NAME must be defined in flash_layout.h"
+    #else
+    #define NV_COUNTERS_FLASH_DEV_NAME FLASH_DEV_NAME
+    #endif
+#endif
+/* End of compilation time checks to be sure the defines are well defined */
+
+#define NV_COUNTER_SIZE  sizeof(uint32_t)
+#define INIT_VALUE_SIZE  NV_COUNTER_SIZE
+#define NUM_NV_COUNTERS  ((TFM_NV_COUNTERS_AREA_SIZE - INIT_VALUE_SIZE) \
+                          / NV_COUNTER_SIZE)
+
+#define NV_COUNTERS_INITIALIZED 0xC0DE0042U
+
+/**
+ * \brief Struct representing the NV counter data in flash.
+ */
+struct nv_counters_t {
+    uint32_t counters[NUM_NV_COUNTERS]; /**< Array of NV counters */
+    uint32_t init_value; /**< Watermark to indicate if the NV counters have been
+                          *   initialised
+                          */
+};
+
+/* Import the CMSIS flash device driver */
+extern ARM_DRIVER_FLASH NV_COUNTERS_FLASH_DEV_NAME;
+
+enum tfm_plat_err_t tfm_plat_init_nv_counter(void)
+{
+    int32_t err;
+    uint32_t i;
+    struct nv_counters_t nv_counters = {{0}};
+
+    err = NV_COUNTERS_FLASH_DEV_NAME.Initialize(NULL);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    /* Read the NV counter area to be able to erase the sector and write later
+     * in the flash.
+     */
+    err = NV_COUNTERS_FLASH_DEV_NAME.ReadData(TFM_NV_COUNTERS_AREA_ADDR,
+                                              &nv_counters,
+                                              TFM_NV_COUNTERS_AREA_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    if (nv_counters.init_value == NV_COUNTERS_INITIALIZED) {
+        return TFM_PLAT_ERR_SUCCESS;
+    }
+
+#ifdef TFM_NV_COUNTERS_BACKUP_AREA_ADDR
+    /* Read the NV counter backup area to be able to erase the sector and
+     * write later in the flash.
+     */
+    err = NV_COUNTERS_FLASH_DEV_NAME.ReadData(TFM_NV_COUNTERS_BACKUP_AREA_ADDR,
+                                              &nv_counters,
+                                              TFM_NV_COUNTERS_AREA_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    if (nv_counters.init_value == NV_COUNTERS_INITIALIZED) {
+        /* Erase main sector before write in it */
+        err = NV_COUNTERS_FLASH_DEV_NAME.EraseSector(TFM_NV_COUNTERS_SECTOR_ADDR);
+        if (err != ARM_DRIVER_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+
+        /* Write in flash the in-memory NV counter content from the backup sector */
+        err = NV_COUNTERS_FLASH_DEV_NAME.ProgramData(TFM_NV_COUNTERS_AREA_ADDR,
+                                                     &nv_counters,
+                                                     TFM_NV_COUNTERS_AREA_SIZE);
+        if (err != ARM_DRIVER_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+
+        return TFM_PLAT_ERR_SUCCESS;
+    }
+#endif
+
+    /* Add watermark, at the end of the NV counters area, to indicate that NV
+     * counters have been initialized.
+     */
+    nv_counters.init_value = NV_COUNTERS_INITIALIZED;
+
+    /* Initialize all counters to 0 */
+    for (i = 0; i < NUM_NV_COUNTERS; i++) {
+        nv_counters.counters[i] = 0;
+    }
+
+    /* Erase main sector before write in it */
+    err = NV_COUNTERS_FLASH_DEV_NAME.EraseSector(TFM_NV_COUNTERS_SECTOR_ADDR);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    /* Erase backup sector before write in it */
+    err = NV_COUNTERS_FLASH_DEV_NAME.EraseSector(TFM_NV_COUNTERS_BACKUP_SECTOR_ADDR);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    /* Write in flash the in-memory NV counter content after modification to the main sector */
+    err = NV_COUNTERS_FLASH_DEV_NAME.ProgramData(TFM_NV_COUNTERS_AREA_ADDR,
+                                                 &nv_counters,
+                                                 TFM_NV_COUNTERS_AREA_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    /* Write in flash the in-memory NV counter content after modification to the backup sector */
+    err = NV_COUNTERS_FLASH_DEV_NAME.ProgramData(TFM_NV_COUNTERS_BACKUP_AREA_ADDR,
+                                                 &nv_counters,
+                                                 TFM_NV_COUNTERS_AREA_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
+enum tfm_plat_err_t tfm_plat_read_nv_counter(enum tfm_nv_counter_t counter_id,
+                                             uint32_t size, uint8_t *val)
+{
+    int32_t  err;
+    uint32_t flash_addr;
+
+    if (size != NV_COUNTER_SIZE) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    flash_addr = TFM_NV_COUNTERS_AREA_ADDR + (counter_id * NV_COUNTER_SIZE);
+
+    err = NV_COUNTERS_FLASH_DEV_NAME.ReadData(flash_addr, val, NV_COUNTER_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
+enum tfm_plat_err_t tfm_plat_set_nv_counter(enum tfm_nv_counter_t counter_id,
+                                            uint32_t value)
+{
+    int32_t err;
+    struct nv_counters_t nv_counters = {{0}};
+
+    /* Read the NV counter area to be able to erase the sector and write later
+     * in the flash.
+     */
+    err = NV_COUNTERS_FLASH_DEV_NAME.ReadData(TFM_NV_COUNTERS_AREA_ADDR,
+                                              &nv_counters,
+                                              TFM_NV_COUNTERS_AREA_SIZE);
+    if (err != ARM_DRIVER_OK) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    if (value != nv_counters.counters[counter_id]) {
+
+        if (value > nv_counters.counters[counter_id]) {
+            nv_counters.counters[counter_id] = value;
+        } else {
+            return TFM_PLAT_ERR_INVALID_INPUT;
+        }
+
+#ifdef TFM_NV_COUNTERS_BACKUP_AREA_ADDR
+        /* Erase backup sector before write in it */
+        err = NV_COUNTERS_FLASH_DEV_NAME.EraseSector(
+                                                TFM_NV_COUNTERS_BACKUP_SECTOR_ADDR);
+        if (err != ARM_DRIVER_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+
+        /* Write in flash the in-memory NV counter content after modification to the backup sector */
+        err = NV_COUNTERS_FLASH_DEV_NAME.ProgramData(TFM_NV_COUNTERS_BACKUP_AREA_ADDR,
+                                                     &nv_counters,
+                                                     TFM_NV_COUNTERS_AREA_SIZE);
+        if (err != ARM_DRIVER_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+#endif
+
+        /* Erase main sector before write in it */
+        err = NV_COUNTERS_FLASH_DEV_NAME.EraseSector(
+                                                TFM_NV_COUNTERS_SECTOR_ADDR);
+        if (err != ARM_DRIVER_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+
+        /* Write in flash the in-memory NV counter content after modification to the main sector */
+        err = NV_COUNTERS_FLASH_DEV_NAME.ProgramData(TFM_NV_COUNTERS_AREA_ADDR,
+                                                     &nv_counters,
+                                                     TFM_NV_COUNTERS_AREA_SIZE);
+        if (err != ARM_DRIVER_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+    }
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
+enum tfm_plat_err_t tfm_plat_increment_nv_counter(
+                                           enum tfm_nv_counter_t counter_id)
+{
+    uint32_t security_cnt;
+    enum tfm_plat_err_t err;
+
+    err = tfm_plat_read_nv_counter(counter_id,
+                                   sizeof(security_cnt),
+                                   (uint8_t *)&security_cnt);
+    if (err != TFM_PLAT_ERR_SUCCESS) {
+        return err;
+    }
+
+    if (security_cnt == UINT32_MAX) {
+        return TFM_PLAT_ERR_MAX_VALUE;
+    }
+
+    return tfm_plat_set_nv_counter(counter_id, security_cnt + 1u);
+}
diff --git a/lib/tf-m/platform/ext/target/lairdconnectivity/common/core/plat_test.c b/lib/tf-m/platform/ext/target/lairdconnectivity/common/core/plat_test.c
index 002f58cc4..dbb3e171b 100644
--- a/lib/tf-m/platform/ext/target/lairdconnectivity/common/core/plat_test.c
+++ b/lib/tf-m/platform/ext/target/lairdconnectivity/common/core/plat_test.c
@@ -38,8 +38,244 @@
 /* Area used by psa-arch-tests to keep state. */
 #define PSA_TEST_SCRATCH_AREA_SIZE  (0x400)
 
+/* Port expander defines */
+#define TCA9538_REG_INPUT           (0x00)
+#define TCA9538_REG_OUTPUT          (0x01)
+#define TCA9538_REG_CONFIG          (0x03)
+#define TCA9538_DEFAULT_OUTPUT      (0xff)
+#define TWI_BUFFER_SIZE             (2)
+
 static bool initialized = false;
 
+static const nrfx_twim_t TWIM0 = NRFX_TWIM_INSTANCE(TWI_INSTANCE_NUMBER);
+static const nrfx_twim_config_t TWIMConfig = {
+    .scl = RTE_TWIM2_SCL_PIN,
+    .sda = RTE_TWIM2_SDA_PIN,
+    .frequency = TWI_FREQUENCY
+};
+
+static nrfx_twim_xfer_desc_t TWIData = {
+    .address = PORT_EXPANDER_I2C_ADDRESS,
+};
+
+static uint8_t TWIBuffer[TWI_BUFFER_SIZE];
+
+static void gpio_init(void)
+{
+    nrfx_err_t err;
+
+    /* Configure I2C (TWI) port */
+    err = nrfx_twim_init(&TWIM0, &TWIMConfig, NULL, NULL);
+
+    if (err != NRFX_SUCCESS)
+    {
+        LOG_MSG("I2C (TWIM) init failed %d", err);
+        return;
+    }
+
+    nrfx_twim_enable(&TWIM0);
+
+    /* Configure IO pins on port expander */
+    TWIData.type = NRFX_TWIM_XFER_TX;
+    TWIData.p_primary_buf = TWIBuffer;
+    TWIData.primary_length = 2;
+    TWIBuffer[0] = TCA9538_REG_CONFIG;
+    TWIBuffer[1] = PORT_EXPANDER_IO_CONFIG;
+    TWIData.p_secondary_buf = NULL;
+    TWIData.secondary_length = 0;
+
+    err = nrfx_twim_xfer(&TWIM0, &TWIData, 0);
+
+    if (err != NRFX_SUCCESS)
+    {
+        LOG_MSG("I2C (TWIM) transfer failed %d", err);
+        return;
+    }
+
+    /* Configure port expander interrupt pin */
+    nrf_gpio_cfg_input(PORT_EXPANDER_INTERRUPT_PIN, PORT_EXPANDER_INTERRUPT_PULL);
+
+    initialized = true;
+}
+
+void tfm_plat_test_wait_user_button_pressed(void)
+{
+    nrfx_err_t err;
+
+    if (!initialized) gpio_init();
+
+    /* Wait until button is pressed */
+    while (1)
+    {
+        /* Wait for port expander interrupt pint to be asserted */
+        while (nrf_gpio_pin_read(PORT_EXPANDER_INTERRUPT_PIN) != PORT_EXPANDER_INTERRUPT_ACTIVE_LEVEL) { ; }
+
+        /* Read the state of the IOs from the port expander */
+        TWIData.type = NRFX_TWIM_XFER_TX;
+        TWIData.p_primary_buf = TWIBuffer;
+        TWIData.primary_length = 1;
+        TWIBuffer[0] = TCA9538_REG_INPUT;
+        TWIData.p_secondary_buf = NULL;
+        TWIData.secondary_length = 0;
+
+        err = nrfx_twim_xfer(&TWIM0, &TWIData, NRFX_TWIM_FLAG_TX_NO_STOP);
+
+        if (err != NRFX_SUCCESS)
+        {
+            LOG_MSG("I2C (TWIM) transfer failed %d", err);
+            return;
+        }
+
+        TWIData.type = NRFX_TWIM_XFER_RX;
+        TWIData.p_primary_buf = TWIBuffer;
+        TWIData.primary_length = 1;
+        TWIBuffer[0] = 0;
+        TWIData.p_secondary_buf = NULL;
+        TWIData.secondary_length = 0;
+
+        err = nrfx_twim_xfer(&TWIM0, &TWIData, 0);
+
+        if (err != NRFX_SUCCESS)
+        {
+            LOG_MSG("I2C (TWIM) transfer failed %d", err);
+            return;
+        }
+
+        if ((TWIBuffer[0] & PORT_EXPANDER_BUTTON1_IO) == PORT_EXPANDER_BUTTON1_ACTIVE_LEVEL)
+        {
+            /* Button has been pressed, break from loop */
+            break;
+        }
+    }
+}
+
+void tfm_plat_test_wait_user_button_released(void)
+{
+    nrfx_err_t err;
+
+    if (!initialized) gpio_init();
+
+    /* Wait until button is released */
+    while (1)
+    {
+        while (nrf_gpio_pin_read(PORT_EXPANDER_INTERRUPT_PIN) != PORT_EXPANDER_INTERRUPT_ACTIVE_LEVEL) { ; }
+
+        /* Read the state of the IOs from the port expander */
+        TWIData.type = NRFX_TWIM_XFER_TX;
+        TWIData.p_primary_buf = TWIBuffer;
+        TWIData.primary_length = 1;
+        TWIBuffer[0] = TCA9538_REG_INPUT;
+        TWIData.p_secondary_buf = NULL;
+        TWIData.secondary_length = 0;
+
+        err = nrfx_twim_xfer(&TWIM0, &TWIData, NRFX_TWIM_FLAG_TX_NO_STOP);
+
+        if (err != NRFX_SUCCESS)
+        {
+            LOG_MSG("I2C (TWIM) transfer failed %d", err);
+            return;
+        }
+
+        TWIData.type = NRFX_TWIM_XFER_RX;
+        TWIData.p_primary_buf = TWIBuffer;
+        TWIData.primary_length = 1;
+        TWIBuffer[0] = 0;
+        TWIData.p_secondary_buf = NULL;
+        TWIData.secondary_length = 0;
+
+        err = nrfx_twim_xfer(&TWIM0, &TWIData, 0);
+
+        if (err != NRFX_SUCCESS)
+        {
+            LOG_MSG("I2C (TWIM) transfer failed %d", err);
+            return;
+        }
+
+        if ((TWIBuffer[0] & PORT_EXPANDER_BUTTON1_IO) != PORT_EXPANDER_BUTTON1_ACTIVE_LEVEL)
+        {
+            break;
+        }
+    }
+}
+
+uint32_t tfm_plat_test_get_led_status(void)
+{
+    nrfx_err_t err;
+
+    if (!initialized) gpio_init();
+
+    /* Read the state of the IOs from the port expander */
+    TWIData.type = NRFX_TWIM_XFER_TX;
+    TWIData.p_primary_buf = TWIBuffer;
+    TWIData.primary_length = 1;
+    TWIBuffer[0] = TCA9538_REG_INPUT;
+    TWIData.p_secondary_buf = NULL;
+    TWIData.secondary_length = 0;
+
+    err = nrfx_twim_xfer(&TWIM0, &TWIData, NRFX_TWIM_FLAG_TX_NO_STOP);
+
+    if (err != NRFX_SUCCESS)
+    {
+        LOG_MSG("I2C (TWIM) transfer failed %d", err);
+        return;
+    }
+
+    TWIData.type = NRFX_TWIM_XFER_RX;
+    TWIData.p_primary_buf = TWIBuffer;
+    TWIData.primary_length = 1;
+    TWIBuffer[0] = 0;
+    TWIData.p_secondary_buf = NULL;
+    TWIData.secondary_length = 0;
+
+    err = nrfx_twim_xfer(&TWIM0, &TWIData, 0);
+
+    if (err != NRFX_SUCCESS)
+    {
+        LOG_MSG("I2C (TWIM) transfer failed %d", err);
+        return;
+    }
+
+    return ((TWIBuffer[0] & PORT_EXPANDER_LED1_IO) == PORT_EXPANDER_LED1_ACTIVE_LEVEL);
+}
+
+void tfm_plat_test_set_led_status(uint32_t status)
+{
+    nrfx_err_t err;
+
+    if (!initialized) gpio_init();
+
+    /* Change output state on port expander */
+    TWIData.type = NRFX_TWIM_XFER_TX;
+    TWIData.p_primary_buf = TWIBuffer;
+    TWIData.primary_length = 2;
+    TWIBuffer[0] = TCA9538_REG_OUTPUT;
+    if (status == 0)
+    {
+        /* Turn LED off */
+        TWIBuffer[1] = TCA9538_DEFAULT_OUTPUT;
+    }
+    else
+    {
+        /* Turn LED on */
+        TWIBuffer[1] = (TCA9538_DEFAULT_OUTPUT & (~PORT_EXPANDER_LED1_IO));
+    }
+    TWIData.p_secondary_buf = NULL;
+    TWIData.secondary_length = 0;
+
+    err = nrfx_twim_xfer(&TWIM0, &TWIData, 0);
+
+    if (err != NRFX_SUCCESS)
+    {
+        LOG_MSG("I2C (TWIM) transfer failed %d", err);
+        return;
+    }
+}
+
+uint32_t tfm_plat_test_get_userled_mask(void)
+{
+    return PORT_EXPANDER_LED1_IO;
+}
+
 static void timer_init(NRF_TIMER_Type * TIMER, uint32_t ticks)
 {
     nrf_timer_mode_set(TIMER, NRF_TIMER_MODE_TIMER);
@@ -104,7 +340,7 @@ void pal_timer_stop_ns(void)
     timer_stop(NRF_TIMER1);
 }
 
-#if !defined(TEST_NS_SLIH_IRQ)
+#if !defined(TFM_ENABLE_SLIH_TEST)
 /* Watchdog timeout handler. */
 void TIMER1_Handler(void)
 {
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/core/gcc/nordic_nrf_s.ld b/lib/tf-m/platform/ext/target/nordic_nrf/common/core/gcc/nordic_nrf_s.ld
index 663b3dd80..c5d6fe89d 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/core/gcc/nordic_nrf_s.ld
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/core/gcc/nordic_nrf_s.ld
@@ -354,8 +354,8 @@ VENEERS()
     {
         . += __msp_init_stack_size__;
     } > RAM
-    Image$$ARM_LIB_STACK$$ZI$$Base = ADDR(.msp_stack);
-    Image$$ARM_LIB_STACK$$ZI$$Limit = ADDR(.msp_stack) + SIZEOF(.msp_stack);
+    Image$$ARM_LIB_STACK_MSP$$ZI$$Base = ADDR(.msp_stack);
+    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit = ADDR(.msp_stack) + SIZEOF(.msp_stack);
 
     /* PSP is unprivileged in single-core topology */
     .psp_stack : ALIGN(32)
@@ -366,16 +366,16 @@ VENEERS()
         . += (__psp_stack_size__);
 # endif
     } > RAM
-    Image$$ER_INITIAL_PSP$$ZI$$Base = ADDR(.psp_stack);
-    Image$$ER_INITIAL_PSP$$ZI$$Limit = ADDR(.psp_stack) + SIZEOF(.psp_stack);
+    Image$$ARM_LIB_STACK$$ZI$$Base = ADDR(.psp_stack);
+    Image$$ARM_LIB_STACK$$ZI$$Limit = ADDR(.psp_stack) + SIZEOF(.psp_stack);
 
 # if !defined(TFM_PSA_API)
     .psp_stack_seal_res :
     {
         . += 0x8;
     } > RAM
-    Image$$ER_INITIAL_PSP_SEAL$$ZI$$Base = ADDR(.psp_stack_seal_res);
-    Image$$ER_INITIAL_PSP_SEAL$$ZI$$Limit = ADDR(.psp_stack_seal_res) + SIZEOF(.psp_stack_seal_res);
+    Image$$ARM_LIB_STACK_SEAL$$ZI$$Base = ADDR(.psp_stack_seal_res);
+    Image$$ARM_LIB_STACK_SEAL$$ZI$$Limit = ADDR(.psp_stack_seal_res) + SIZEOF(.psp_stack_seal_res);
 # endif
 #endif
 
@@ -506,16 +506,16 @@ VENEERS()
     {
         . += __msp_init_stack_size__;
     } > RAM
-    Image$$ARM_LIB_STACK$$ZI$$Base = ADDR(.msp_stack);
-    Image$$ARM_LIB_STACK$$ZI$$Limit = ADDR(.msp_stack) + SIZEOF(.msp_stack);
+    Image$$ARM_LIB_STACK_MSP$$ZI$$Base = ADDR(.msp_stack);
+    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit = ADDR(.msp_stack) + SIZEOF(.msp_stack);
 
     /* PSP is privileged in multi-core topology */
     .psp_stack : ALIGN(32)
     {
         . += __psp_stack_size__;
     } > RAM
-    Image$$ER_INITIAL_PSP$$ZI$$Base = ADDR(.psp_stack);
-    Image$$ER_INITIAL_PSP$$ZI$$Limit = ADDR(.psp_stack) + SIZEOF(.psp_stack);
+    Image$$ARM_LIB_STACK$$ZI$$Base = ADDR(.psp_stack);
+    Image$$ARM_LIB_STACK$$ZI$$Limit = ADDR(.psp_stack) + SIZEOF(.psp_stack);
 #endif
 
     /**** PSA RoT DATA start here */
@@ -642,9 +642,5 @@ VENEERS()
     Load$$LR$$LR_SECONDARY_PARTITION$$Base = SECONDARY_PARTITION_START;
 #endif /* BL2 */
 
-#ifdef NRF_NS_STORAGE
-    Load$$LR$$LR_NRF_NS_STORAGE_PARTITION$$Base = NRF_NS_STORAGE_PARTITION_START;
-#endif /* NRF_NS_STORAGE */
-
-    PROVIDE(__stack = Image$$ER_INITIAL_PSP$$ZI$$Limit);
+    PROVIDE(__stack = Image$$ARM_LIB_STACK$$ZI$$Limit);
 }
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/core/native_drivers/mpu_armv8m_drv.h b/lib/tf-m/platform/ext/target/nordic_nrf/common/core/native_drivers/mpu_armv8m_drv.h
index 9244cdf2b..d427604f3 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/core/native_drivers/mpu_armv8m_drv.h
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/core/native_drivers/mpu_armv8m_drv.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2019, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -91,7 +91,7 @@ enum mpu_armv8m_error_t mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -102,7 +102,7 @@ enum mpu_armv8m_error_t mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev);
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -114,7 +114,7 @@ enum mpu_armv8m_error_t mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev);
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_cfg     MPU region config \ref mpu_armv8m_region_cfg_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -128,7 +128,7 @@ enum mpu_armv8m_error_t mpu_armv8m_region_enable(
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_nr            Region number
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/core/plat_test.c b/lib/tf-m/platform/ext/target/nordic_nrf/common/core/plat_test.c
index bf120719d..9f459f25b 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/core/plat_test.c
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/core/plat_test.c
@@ -16,7 +16,6 @@
 
 #include <string.h>
 #include "tfm_plat_test.h"
-#include "pal_plat_test.h"
 #include <stdint.h>
 #include <stdbool.h>
 #include <hal/nrf_gpio.h>
@@ -24,16 +23,60 @@
 #include <helpers/nrfx_reset_reason.h>
 #include <nrf_board.h>
 #include <region_defs.h>
-
-#if defined(PSA_API_TEST_NS) && !defined(PSA_API_TEST_IPC)
 #include <tfm_platform_api.h>
 #include <log/tfm_log.h>
-#endif
 
 #define TIMER_RELOAD_VALUE (1*1000*1000)
+#define USERLED_MASK       (1UL)
+
+/* Area used by psa-arch-tests to keep state. */
+#define PSA_TEST_SCRATCH_AREA_SIZE (0x400)
 
 static bool initialized = false;
 
+static void gpio_init(void)
+{
+    nrf_gpio_cfg_input(BUTTON1_PIN, BUTTON1_PULL);
+    nrf_gpio_cfg_output(LED1_PIN);
+    initialized = true;
+}
+
+void tfm_plat_test_wait_user_button_pressed(void)
+{
+    if (!initialized) gpio_init();
+
+    /* Wait until button is pressed */
+    while (nrf_gpio_pin_read(BUTTON1_PIN) != BUTTON1_ACTIVE_LEVEL) { ; }
+}
+
+void tfm_plat_test_wait_user_button_released(void)
+{
+    if (!initialized) gpio_init();
+
+    /* Wait until user button 0 is released */
+    while (nrf_gpio_pin_read(BUTTON1_PIN) == BUTTON1_ACTIVE_LEVEL) { ; }
+}
+
+uint32_t tfm_plat_test_get_led_status(void)
+{
+    if (!initialized) gpio_init();
+
+    return (nrf_gpio_pin_out_read(LED1_PIN) == LED1_ACTIVE_LEVEL);
+}
+
+void tfm_plat_test_set_led_status(uint32_t status)
+{
+    if (!initialized) gpio_init();
+
+    status &= USERLED_MASK;
+    nrf_gpio_pin_write(LED1_PIN, status == LED1_ACTIVE_LEVEL);
+}
+
+uint32_t tfm_plat_test_get_userled_mask(void)
+{
+    return USERLED_MASK;
+}
+
 static void timer_init(NRF_TIMER_Type * TIMER, uint32_t ticks)
 {
     nrf_timer_mode_set(TIMER, NRF_TIMER_MODE_TIMER);
@@ -98,7 +141,7 @@ void pal_timer_stop_ns(void)
     timer_stop(NRF_TIMER1);
 }
 
-#if defined(PSA_API_TEST_NS) && !defined(PSA_API_TEST_IPC)
+#if !defined(TFM_ENABLE_SLIH_TEST)
 /* Watchdog timeout handler. */
 void TIMER1_Handler(void)
 {
@@ -110,9 +153,9 @@ void TIMER1_Handler(void)
 }
 #endif
 
-#ifdef PSA_API_TEST_ENABLED
 uint32_t pal_nvmem_get_addr(void)
 {
+    static __ALIGN(4) uint8_t __psa_scratch[PSA_TEST_SCRATCH_AREA_SIZE];
 #ifdef NRF_TRUSTZONE_NONSECURE
     static bool psa_scratch_initialized = false;
 
@@ -123,13 +166,12 @@ uint32_t pal_nvmem_get_addr(void)
         int is_pinreset = reset_reason & NRFX_RESET_REASON_RESETPIN_MASK;
         if ((reset_reason == 0) || is_pinreset){
             /* PSA API tests expect this area to be initialized to all 0xFFs
-             * after a power-on or pin reset.
-             */
-            memset((void*)PSA_TEST_SCRATCH_AREA_BASE, 0xFF, PSA_TEST_SCRATCH_AREA_SIZE);
+            * after a power-on or pin reset.
+            */
+            memset(__psa_scratch, 0xFF, PSA_TEST_SCRATCH_AREA_SIZE);
         }
         psa_scratch_initialized = true;
     }
-#endif /* NRF_TRUSTZONE_NONSECURE */
-    return (uint32_t)PSA_TEST_SCRATCH_AREA_BASE;
+#endif
+    return (uint32_t)__psa_scratch;
 }
-#endif /* PSA_API_TEST_ENABLED */
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/core/tfm_hal_isolation.c b/lib/tf-m/platform/ext/target/nordic_nrf/common/core/tfm_hal_isolation.c
index a839c03fc..df0b05b7e 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/core/tfm_hal_isolation.c
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/core/tfm_hal_isolation.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -29,8 +29,8 @@ REGION_DECLARE(Image$$, TFM_APP_CODE_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_CODE_END, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_END, $$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Base);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
 #ifdef TFM_SP_META_PTR_ENABLE
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Base);
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
@@ -89,9 +89,9 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     /* NSPM PSP */
     region_cfg.region_nr = MPU_REGION_NS_STACK;
     region_cfg.region_base =
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base);
     region_cfg.region_limit =
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
     region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
     region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
     region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/gcc/startup_nrf5340_s.S b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/gcc/startup_nrf5340_s.S
index 9edc60391..346699cd4 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/gcc/startup_nrf5340_s.S
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/gcc/startup_nrf5340_s.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009-2021 ARM Limited. All rights reserved.
+ * Copyright (c) 2009-2020 ARM Limited. All rights reserved.
  *
  * SPDX-License-Identifier: Apache-2.0
  *
@@ -30,7 +30,7 @@
     .align  2
     .globl  __Vectors
 __Vectors:
-    .long   Image$$ARM_LIB_STACK$$ZI$$Limit /* Top of Stack */
+    .long   Image$$ARM_LIB_STACK_MSP$$ZI$$Limit /* Top of Stack */
 
     .long   Reset_Handler               /* Reset Handler */
     .long   NMI_Handler                 /* NMI Handler */
@@ -254,6 +254,12 @@ Reset_Handler:
 
     bl      SystemInit
 
+    mrs     r0, control    /* Get control value */
+    orr     r0, r0, #2     /* Select switch to PSP */
+    msr     control, r0
+    ldr     r0, =Image$$ARM_LIB_STACK$$ZI$$Limit
+    msr     psp, r0
+
 /* Call _start function provided by libraries.
  * If those libraries are not accessible, define __START as your entry point.
  */
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/partition/flash_layout.h b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/partition/flash_layout.h
index 6071f8909..4fec9f502 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/partition/flash_layout.h
@@ -29,9 +29,8 @@
  *    0x000c_0000 Non-secure image secondary (192 KB)
  * 0x000f_0000 Protected Storage Area (16 KB)
  * 0x000f_4000 Internal Trusted Storage Area (8 KB)
- * 0x000f_6000 OTP / NV counters area (8 KB)
- * 0x000f_8000 Non-secure storage, used when built with NRF_NS_STORAGE=ON,
- *             otherwise unused (32 KB)
+ * 0x000f_6000 NV counters area (4 KB)
+ * 0x000f_7000 Unused
  *
  * Flash layout on NRF5340 Application MCU without BL2:
  *
@@ -40,9 +39,8 @@
  *    0x0007_8000 Non-secure image primary (480 KB)
  * 0x000f_0000 Protected Storage Area (16 KB)
  * 0x000f_4000 Internal Trusted Storage Area (8 KB)
- * 0x000f_6000 OTP / NV counters area (8 KB)
- * 0x000f_8000 Non-secure storage, used when built with NRF_NS_STORAGE=ON,
- *             otherwise unused (32 KB)
+ * 0x000f_6000 NV counters area (4 KB)
+ * 0x000f_7000 Unused
  */
 
 /* This header file is included from linker scatter file as well, where only a
@@ -53,15 +51,8 @@
  */
 
 /* Size of a Secure and of a Non-secure image */
-#ifdef PSA_API_TEST_IPC
-/* Firmware Framework test suites */
-#define FLASH_S_PARTITION_SIZE                (0x48000)       /* S partition: 288 kB*/
-#define FLASH_NS_PARTITION_SIZE               (0x28000)       /* NS partition: 160 kB*/
-#else
 #define FLASH_S_PARTITION_SIZE                (0x40000)       /* S partition: 256 kB*/
 #define FLASH_NS_PARTITION_SIZE               (0x30000)       /* NS partition: 192 kB*/
-#endif
-
 #define FLASH_MAX_PARTITION_SIZE        ((FLASH_S_PARTITION_SIZE >   \
                                           FLASH_NS_PARTITION_SIZE) ? \
                                          FLASH_S_PARTITION_SIZE :    \
@@ -152,16 +143,10 @@
                                          FLASH_PS_AREA_SIZE)
 #define FLASH_ITS_AREA_SIZE             (0x2000)   /* 8 KB */
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
-
-/* Non-secure storage region */
-#define NRF_FLASH_NS_STORAGE_AREA_OFFSET    (FLASH_TOTAL_SIZE - \
-                                             NRF_FLASH_NS_STORAGE_AREA_SIZE)
-#define NRF_FLASH_NS_STORAGE_AREA_SIZE      (0x8000)   /* 32 KB */
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* Offset and size definition in flash area used by assemble.py */
 #define SECURE_IMAGE_OFFSET             (0x0)
@@ -175,7 +160,6 @@
  * Name is defined in flash driver file: Driver_Flash.c
  */
 #define FLASH_DEV_NAME Driver_FLASH0
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x4)
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -217,12 +201,11 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x4)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18) /* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
 
 /* Use Flash memory to store Code data */
 #define FLASH_BASE_ADDRESS (0x00000000)
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/partition/region_defs.h b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/partition/region_defs.h
index 4c5ded6df..df20890c2 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/partition/region_defs.h
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/partition/region_defs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
  * Copyright (c) 2020 Nordic Semiconductor ASA. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -79,23 +79,13 @@
 #define BL2_HEADER_SIZE      (0x400)       /* 1 KB */
 #define BL2_TRAILER_SIZE     (0x400)       /* 1 KB */
 #else
+/* No header if no bootloader, but keep IMAGE_CODE_SIZE the same */
 #define BL2_HEADER_SIZE      (0x0)
-#define BL2_TRAILER_SIZE     (0x0)
+#define BL2_TRAILER_SIZE     (0x800)
 #endif /* BL2 */
 
-#if (MCUBOOT_IMAGE_NUMBER == 1) && \
-    (NS_IMAGE_PRIMARY_PARTITION_OFFSET > S_IMAGE_PRIMARY_PARTITION_OFFSET)
-/* If secure image and nonsecure image are concatenated, and nonsecure image
- * locates at the higher memory range, then the secure image does not need
- * the trailer area.
- */
-#define IMAGE_S_CODE_SIZE \
-            (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE)
-#else
 #define IMAGE_S_CODE_SIZE \
             (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
-#endif
-
 #define IMAGE_NS_CODE_SIZE \
             (FLASH_NS_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
 
@@ -140,12 +130,7 @@
 #define NS_CODE_LIMIT   (NS_CODE_START + NS_CODE_SIZE - 1)
 
 #define NS_DATA_START   (NS_RAM_ALIAS(S_DATA_SIZE))
-#ifdef PSA_API_TEST_IPC
-/* Last SRAM region must be kept secure for PSA FF tests */
-#define NS_DATA_SIZE    (TOTAL_RAM_SIZE - S_DATA_SIZE - SPU_SRAM_REGION_SIZE)
-#else
 #define NS_DATA_SIZE    (TOTAL_RAM_SIZE - S_DATA_SIZE)
-#endif
 #define NS_DATA_LIMIT   (NS_DATA_START + NS_DATA_SIZE - 1)
 
 /* NS partition information is used for SPU configuration */
@@ -159,11 +144,6 @@
 #define SECONDARY_PARTITION_SIZE (FLASH_S_PARTITION_SIZE + \
                                   FLASH_NS_PARTITION_SIZE)
 
-/* Non-secure storage region */
-#define NRF_NS_STORAGE_PARTITION_START \
-            (NS_ROM_ALIAS(NRF_FLASH_NS_STORAGE_AREA_OFFSET))
-#define NRF_NS_STORAGE_PARTITION_SIZE (NRF_FLASH_NS_STORAGE_AREA_SIZE)
-
 #ifdef BL2
 /* Bootloader regions */
 #define BL2_CODE_START    (S_ROM_ALIAS(FLASH_AREA_BL2_OFFSET))
@@ -184,37 +164,4 @@
 #define BOOT_TFM_SHARED_DATA_LIMIT (BOOT_TFM_SHARED_DATA_BASE + \
                                     BOOT_TFM_SHARED_DATA_SIZE - 1)
 
-/* Regions used by psa-arch-tests to keep state */
-#define PSA_TEST_SCRATCH_AREA_SIZE (0x400)
-
-#ifdef PSA_API_TEST_IPC
-/* Firmware Framework test suites */
-#define FF_TEST_PARTITION_SIZE 0x100
-#define PSA_TEST_SCRATCH_AREA_BASE (NS_DATA_LIMIT + 1 - \
-                                    PSA_TEST_SCRATCH_AREA_SIZE - \
-                                    FF_TEST_PARTITION_SIZE)
-
-/* The psa-arch-tests implementation requires that the test partitions are
- * placed in this specific order:
- * TEST_NSPE_MMIO < TEST_SERVER < TEST_DRIVER
- *
- * TEST_NSPE_MMIO region must be in the NSPE, while TEST_SERVER and TEST_DRIVER
- * must be in SPE.
- *
- * The TEST_NSPE_MMIO region is defined in the psa-arch-tests implementation,
- * and it should be placed at the end of the NSPE area, after
- * PSA_TEST_SCRATCH_AREA.
- */
-#define FF_TEST_SERVER_PARTITION_MMIO_START  (NS_DATA_LIMIT + 1)
-#define FF_TEST_SERVER_PARTITION_MMIO_END    (FF_TEST_SERVER_PARTITION_MMIO_START + \
-                                              FF_TEST_PARTITION_SIZE - 1)
-#define FF_TEST_DRIVER_PARTITION_MMIO_START  (FF_TEST_SERVER_PARTITION_MMIO_END + 1)
-#define FF_TEST_DRIVER_PARTITION_MMIO_END    (FF_TEST_DRIVER_PARTITION_MMIO_START + \
-                                              FF_TEST_PARTITION_SIZE - 1)
-#else
-/* Development APIs test suites */
-#define PSA_TEST_SCRATCH_AREA_BASE (NS_DATA_LIMIT + 1 - \
-                                    PSA_TEST_SCRATCH_AREA_SIZE)
-#endif /* PSA_API_TEST_IPC */
-
 #endif /* __REGION_DEFS_H__ */
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/target_cfg.c b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/target_cfg.c
index 9cdba8fe1..69bbcaedc 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/target_cfg.c
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/target_cfg.c
@@ -37,31 +37,6 @@ struct platform_data_t tfm_peripheral_std_uart = {
         NRF_UARTE1_S_BASE + (sizeof(NRF_UARTE_Type) - 1),
 };
 
-#ifdef PSA_API_TEST_IPC
-struct platform_data_t
-    tfm_peripheral_FF_TEST_SERVER_PARTITION_MMIO = {
-        FF_TEST_SERVER_PARTITION_MMIO_START,
-        FF_TEST_SERVER_PARTITION_MMIO_END
-};
-
-struct platform_data_t
-    tfm_peripheral_FF_TEST_DRIVER_PARTITION_MMIO = {
-        FF_TEST_DRIVER_PARTITION_MMIO_START,
-        FF_TEST_DRIVER_PARTITION_MMIO_END
-};
-
-/* This platform implementation uses PSA_TEST_SCRATCH_AREA for
- * storing the state between resets, but the FF_TEST_NVMEM_REGIONS
- * definitons are still needed for tests to compile.
- */
-#define FF_TEST_NVMEM_REGION_START  0xFFFFFFFF
-#define FF_TEST_NVMEM_REGION_END    0xFFFFFFFF
-struct platform_data_t
-    tfm_peripheral_FF_TEST_NVMEM_REGION = {
-        FF_TEST_NVMEM_REGION_START,
-        FF_TEST_NVMEM_REGION_END
-};
-#endif /* PSA_API_TEST_IPC */
 
 /* The section names come from the scatter file */
 REGION_DECLARE(Load$$LR$$, LR_NS_PARTITION, $$Base);
@@ -70,9 +45,6 @@ REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Limit);
 #ifdef BL2
 REGION_DECLARE(Load$$LR$$, LR_SECONDARY_PARTITION, $$Base);
 #endif /* BL2 */
-#ifdef NRF_NS_STORAGE
-REGION_DECLARE(Load$$LR$$, LR_NRF_NS_STORAGE_PARTITION, $$Base);
-#endif /* NRF_NS_STORAGE */
 
 const struct memory_region_limits memory_regions = {
     .non_secure_code_start =
@@ -100,14 +72,6 @@ const struct memory_region_limits memory_regions = {
         (uint32_t)&REGION_NAME(Load$$LR$$, LR_SECONDARY_PARTITION, $$Base) +
         SECONDARY_PARTITION_SIZE - 1,
 #endif /* BL2 */
-
-#ifdef NRF_NS_STORAGE
-    .non_secure_storage_partition_base =
-        (uint32_t)&REGION_NAME(Load$$LR$$, LR_NRF_NS_STORAGE_PARTITION, $$Base),
-    .non_secure_storage_partition_limit =
-        (uint32_t)&REGION_NAME(Load$$LR$$, LR_NRF_NS_STORAGE_PARTITION, $$Base) +
-        NRF_NS_STORAGE_PARTITION_SIZE - 1,
-#endif /* NRF_NS_STORAGE */
 };
 
 /* To write into AIRCR register, 0x5FA value must be write to the VECTKEY field,
@@ -242,13 +206,6 @@ enum tfm_plat_err_t spu_init_cfg(void)
         memory_regions.secondary_partition_limit);
 #endif /* BL2 */
 
-#ifdef NRF_NS_STORAGE
-    /* Configures storage partition to be non-secure */
-    spu_regions_flash_config_non_secure(
-        memory_regions.non_secure_storage_partition_base,
-        memory_regions.non_secure_storage_partition_limit);
-#endif /* NRF_NS_STORAGE */
-
     return TFM_PLAT_ERR_SUCCESS;
 }
 
@@ -273,10 +230,7 @@ enum tfm_plat_err_t spu_periph_init_cfg(void)
     spu_peripheral_config_non_secure((uint32_t)NRF_RTC0, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_RTC1, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_DPPIC, false);
-#ifndef PSA_API_TEST_IPC
-    /* WDT0 is used as a secure peripheral in PSA FF tests */
     spu_peripheral_config_non_secure((uint32_t)NRF_WDT0, false);
-#endif
     spu_peripheral_config_non_secure((uint32_t)NRF_WDT1, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_COMP, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_EGU0, false);
@@ -284,10 +238,7 @@ enum tfm_plat_err_t spu_periph_init_cfg(void)
     spu_peripheral_config_non_secure((uint32_t)NRF_EGU2, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_EGU3, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_EGU4, false);
-#ifndef PSA_API_TEST_IPC
-    /* EGU5 is used as a secure peripheral in PSA FF tests */
     spu_peripheral_config_non_secure((uint32_t)NRF_EGU5, false);
-#endif
     spu_peripheral_config_non_secure((uint32_t)NRF_PWM0, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_PWM1, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_PWM2, false);
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/target_cfg.h b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/target_cfg.h
index f590bb4e6..ab0434aeb 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/target_cfg.h
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/target_cfg.h
@@ -50,10 +50,6 @@ struct memory_region_limits {
     uint32_t secondary_partition_base;
     uint32_t secondary_partition_limit;
 #endif /* BL2 */
-#ifdef NRF_NS_STORAGE
-    uint32_t non_secure_storage_partition_base;
-    uint32_t non_secure_storage_partition_limit;
-#endif /* NRF_NS_STORAGE */
 };
 
 /**
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/tfm_peripherals_def.h
index 57e47529b..bba6a811b 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf5340/tfm_peripherals_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2019, Arm Limited. All rights reserved.
  * Copyright (c) 2020, Cypress Semiconductor Corporation. All rights reserved.
  * Copyright (c) 2020, Nordic Semiconductor ASA. All rights reserved.
  *
@@ -26,21 +26,7 @@ extern struct platform_data_t tfm_peripheral_timer0;
 
 #define TFM_PERIPHERAL_STD_UART     (&tfm_peripheral_std_uart)
 #define TFM_PERIPHERAL_TIMER0       (&tfm_peripheral_timer0)
-
-#ifdef PSA_API_TEST_IPC
-#define FF_TEST_UART_IRQ         (EGU5_IRQn)
-#define FF_TEST_UART_IRQ_Handler (pal_interrupt_handler)
-
-extern struct platform_data_t tfm_peripheral_FF_TEST_NVMEM_REGION;
-extern struct platform_data_t tfm_peripheral_FF_TEST_SERVER_PARTITION_MMIO;
-extern struct platform_data_t tfm_peripheral_FF_TEST_DRIVER_PARTITION_MMIO;
-
-#define FF_TEST_UART_REGION           (&tfm_peripheral_std_uart)
-#define FF_TEST_WATCHDOG_REGION       (&tfm_peripheral_timer0)
-#define FF_TEST_NVMEM_REGION          (&tfm_peripheral_FF_TEST_NVMEM_REGION)
-#define FF_TEST_SERVER_PARTITION_MMIO (&tfm_peripheral_FF_TEST_SERVER_PARTITION_MMIO)
-#define FF_TEST_DRIVER_PARTITION_MMIO (&tfm_peripheral_FF_TEST_DRIVER_PARTITION_MMIO)
-#endif /* PSA_API_TEST_IPC */
+#define TFM_PERIPHERAL_FPGA_IO      (0)
 
 #ifdef __cplusplus
 }
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/gcc/startup_nrf9160_s.S b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/gcc/startup_nrf9160_s.S
index 6e27dc5e0..00a597c9f 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/gcc/startup_nrf9160_s.S
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/gcc/startup_nrf9160_s.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009-2021 ARM Limited. All rights reserved.
+ * Copyright (c) 2009-2020 ARM Limited. All rights reserved.
  *
  * SPDX-License-Identifier: Apache-2.0
  *
@@ -30,7 +30,7 @@
     .align  2
     .globl  __Vectors
 __Vectors:
-    .long   Image$$ARM_LIB_STACK$$ZI$$Limit /* Top of Stack */
+    .long   Image$$ARM_LIB_STACK_MSP$$ZI$$Limit /* Top of Stack */
 
     .long   Reset_Handler               /* Reset Handler */
     .long   NMI_Handler                 /* NMI Handler */
@@ -250,6 +250,12 @@ Reset_Handler:
 
     bl      SystemInit
 
+    mrs     r0, control    /* Get control value */
+    orr     r0, r0, #2     /* Select switch to PSP */
+    msr     control, r0
+    ldr     r0, =Image$$ARM_LIB_STACK$$ZI$$Limit
+    msr     psp, r0
+
 /* Call _start function provided by libraries.
  * If those libraries are not accessible, define __START as your entry point.
  */
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/partition/flash_layout.h b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/partition/flash_layout.h
index 1e5e39bd0..ad53de980 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/partition/flash_layout.h
@@ -29,9 +29,8 @@
  *    0x000c_0000 Non-secure image secondary (192 KB)
  * 0x000f_0000 Protected Storage Area (20 KB)
  * 0x000f_4000 Internal Trusted Storage Area (16 KB)
- * 0x000f_6000 OTP / NV counters  area (8 KB)
- * 0x000f_8000 Non-secure storage, used when built with NRF_NS_STORAGE=ON,
- *             otherwise unused (32 KB)
+ * 0x000f_6000 NV counters area (4 KB)
+ * 0x000f_7000 Unused
  *
  * Flash layout on NRF9160 without BL2:
  *
@@ -40,9 +39,8 @@
  *    0x0007_8000 Non-secure image primary (480 KB)
  * 0x000f_0000 Protected Storage Area (16 KB)
  * 0x000f_4000 Internal Trusted Storage Area (8 KB)
- * 0x000f_6000 OTP / NV counters  area (8 KB)
- * 0x000f_8000 Non-secure storage, used when built with NRF_NS_STORAGE=ON,
- *             otherwise unused (32 KB)
+ * 0x000f_6000 NV counters area (4 KB)
+ * 0x000f_7000 Unused
  */
 
 /* This header file is included from linker scatter file as well, where only a
@@ -53,15 +51,8 @@
  */
 
 /* Size of a Secure and of a Non-secure image */
-#ifdef PSA_API_TEST_IPC
-/* Firmware Framework test suites */
-#define FLASH_S_PARTITION_SIZE                (0x48000)       /* S partition: 288 kB*/
-#define FLASH_NS_PARTITION_SIZE               (0x28000)       /* NS partition: 160 kB*/
-#else
 #define FLASH_S_PARTITION_SIZE                (0x40000)       /* S partition: 256 kB*/
 #define FLASH_NS_PARTITION_SIZE               (0x30000)       /* NS partition: 192 kB*/
-#endif
-
 #define FLASH_MAX_PARTITION_SIZE        ((FLASH_S_PARTITION_SIZE >   \
                                           FLASH_NS_PARTITION_SIZE) ? \
                                          FLASH_S_PARTITION_SIZE :    \
@@ -153,16 +144,10 @@
                                          FLASH_PS_AREA_SIZE)
 #define FLASH_ITS_AREA_SIZE             (0x2000)   /* 8 KB */
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
-
-/* Non-secure storage region */
-#define NRF_FLASH_NS_STORAGE_AREA_OFFSET    (FLASH_TOTAL_SIZE - \
-                                             NRF_FLASH_NS_STORAGE_AREA_SIZE)
-#define NRF_FLASH_NS_STORAGE_AREA_SIZE      (0x8000)   /* 32 KB */
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* Offset and size definition in flash area used by assemble.py */
 #define SECURE_IMAGE_OFFSET             (0x0)
@@ -176,8 +161,6 @@
  * Name is defined in flash driver file: Driver_Flash.c
  */
 #define FLASH_DEV_NAME Driver_FLASH0
-/* Smallest flash programmable unit in bytes */
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x4)
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -219,12 +202,11 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x4)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18) /* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
 
 /* Use Flash memory to store Code data */
 #define FLASH_BASE_ADDRESS (0x00000000)
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/partition/region_defs.h b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/partition/region_defs.h
index 957a9bc3d..faddce1f5 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/partition/region_defs.h
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/partition/region_defs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
  * Copyright (c) 2020 Nordic Semiconductor ASA. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -79,23 +79,13 @@
 #define BL2_HEADER_SIZE      (0x400)       /* 1 KB */
 #define BL2_TRAILER_SIZE     (0x400)       /* 1 KB */
 #else
+/* No header if no bootloader, but keep IMAGE_CODE_SIZE the same */
 #define BL2_HEADER_SIZE      (0x0)
-#define BL2_TRAILER_SIZE     (0x0)
+#define BL2_TRAILER_SIZE     (0x800)
 #endif /* BL2 */
 
-#if (MCUBOOT_IMAGE_NUMBER == 1) && \
-    (NS_IMAGE_PRIMARY_PARTITION_OFFSET > S_IMAGE_PRIMARY_PARTITION_OFFSET)
-/* If secure image and nonsecure image are concatenated, and nonsecure image
- * locates at the higher memory range, then the secure image does not need
- * the trailer area.
- */
-#define IMAGE_S_CODE_SIZE \
-            (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE)
-#else
 #define IMAGE_S_CODE_SIZE \
             (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
-#endif
-
 #define IMAGE_NS_CODE_SIZE \
             (FLASH_NS_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
 
@@ -143,12 +133,7 @@
 #define NS_CODE_LIMIT   (NS_CODE_START + NS_CODE_SIZE - 1)
 
 #define NS_DATA_START   (NS_RAM_ALIAS(S_DATA_SIZE))
-#ifdef PSA_API_TEST_IPC
-/* Last SRAM region must be kept secure for PSA FF tests */
-#define NS_DATA_SIZE    (TOTAL_RAM_SIZE - S_DATA_SIZE - SPU_SRAM_REGION_SIZE)
-#else
 #define NS_DATA_SIZE    (TOTAL_RAM_SIZE - S_DATA_SIZE)
-#endif
 #define NS_DATA_LIMIT   (NS_DATA_START + NS_DATA_SIZE - 1)
 
 /* NS partition information is used for SPU configuration */
@@ -162,11 +147,6 @@
 #define SECONDARY_PARTITION_SIZE (FLASH_S_PARTITION_SIZE + \
                                   FLASH_NS_PARTITION_SIZE)
 
-/* Non-secure storage region */
-#define NRF_NS_STORAGE_PARTITION_START \
-            (NS_ROM_ALIAS(NRF_FLASH_NS_STORAGE_AREA_OFFSET))
-#define NRF_NS_STORAGE_PARTITION_SIZE (NRF_FLASH_NS_STORAGE_AREA_SIZE)
-
 #ifdef BL2
 /* Bootloader regions */
 #define BL2_CODE_START    (S_ROM_ALIAS(FLASH_AREA_BL2_OFFSET))
@@ -187,37 +167,4 @@
 #define BOOT_TFM_SHARED_DATA_LIMIT (BOOT_TFM_SHARED_DATA_BASE + \
                                     BOOT_TFM_SHARED_DATA_SIZE - 1)
 
-/* Regions used by psa-arch-tests to keep state */
-#define PSA_TEST_SCRATCH_AREA_SIZE (0x400)
-
-#ifdef PSA_API_TEST_IPC
-/* Firmware Framework test suites */
-#define FF_TEST_PARTITION_SIZE 0x100
-#define PSA_TEST_SCRATCH_AREA_BASE (NS_DATA_LIMIT + 1 - \
-                                    PSA_TEST_SCRATCH_AREA_SIZE - \
-                                    FF_TEST_PARTITION_SIZE)
-
-/* The psa-arch-tests implementation requires that the test partitions are
- * placed in this specific order:
- * TEST_NSPE_MMIO < TEST_SERVER < TEST_DRIVER
- *
- * TEST_NSPE_MMIO region must be in the NSPE, while TEST_SERVER and TEST_DRIVER
- * must be in SPE.
- *
- * The TEST_NSPE_MMIO region is defined in the psa-arch-tests implementation,
- * and it should be placed at the end of the NSPE area, after
- * PSA_TEST_SCRATCH_AREA.
- */
-#define FF_TEST_SERVER_PARTITION_MMIO_START  (NS_DATA_LIMIT + 1)
-#define FF_TEST_SERVER_PARTITION_MMIO_END    (FF_TEST_SERVER_PARTITION_MMIO_START + \
-                                              FF_TEST_PARTITION_SIZE - 1)
-#define FF_TEST_DRIVER_PARTITION_MMIO_START  (FF_TEST_SERVER_PARTITION_MMIO_END + 1)
-#define FF_TEST_DRIVER_PARTITION_MMIO_END    (FF_TEST_DRIVER_PARTITION_MMIO_START + \
-                                              FF_TEST_PARTITION_SIZE - 1)
-#else
-/* Development APIs test suites */
-#define PSA_TEST_SCRATCH_AREA_BASE (NS_DATA_LIMIT + 1 - \
-                                    PSA_TEST_SCRATCH_AREA_SIZE)
-#endif /* PSA_API_TEST_IPC */
-
 #endif /* __REGION_DEFS_H__ */
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/target_cfg.c b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/target_cfg.c
index ccd32edc0..17d786170 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/target_cfg.c
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/target_cfg.c
@@ -34,33 +34,6 @@ struct platform_data_t tfm_peripheral_std_uart = {
     NRF_UARTE1_S_BASE + (sizeof(NRF_UARTE_Type) - 1),
 };
 
-#ifdef PSA_API_TEST_IPC
-struct platform_data_t
-    tfm_peripheral_FF_TEST_SERVER_PARTITION_MMIO = {
-        FF_TEST_SERVER_PARTITION_MMIO_START,
-        FF_TEST_SERVER_PARTITION_MMIO_END
-};
-
-struct platform_data_t
-    tfm_peripheral_FF_TEST_DRIVER_PARTITION_MMIO = {
-        FF_TEST_DRIVER_PARTITION_MMIO_START,
-        FF_TEST_DRIVER_PARTITION_MMIO_END
-};
-
-/* This platform implementation uses PSA_TEST_SCRATCH_AREA for
- * storing the state between resets, but the FF_TEST_NVMEM_REGIONS
- * definitons are still needed for tests to compile.
- */
-#define FF_TEST_NVMEM_REGION_START  0xFFFFFFFF
-#define FF_TEST_NVMEM_REGION_END    0xFFFFFFFF
-struct platform_data_t
-    tfm_peripheral_FF_TEST_NVMEM_REGION = {
-        FF_TEST_NVMEM_REGION_START,
-        FF_TEST_NVMEM_REGION_END
-};
-#endif /* PSA_API_TEST_IPC */
-
-
 /* The section names come from the scatter file */
 REGION_DECLARE(Load$$LR$$, LR_NS_PARTITION, $$Base);
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Base);
@@ -68,9 +41,6 @@ REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Limit);
 #ifdef BL2
 REGION_DECLARE(Load$$LR$$, LR_SECONDARY_PARTITION, $$Base);
 #endif /* BL2 */
-#ifdef NRF_NS_STORAGE
-REGION_DECLARE(Load$$LR$$, LR_NRF_NS_STORAGE_PARTITION, $$Base);
-#endif /* NRF_NS_STORAGE */
 
 const struct memory_region_limits memory_regions = {
     .non_secure_code_start =
@@ -98,14 +68,6 @@ const struct memory_region_limits memory_regions = {
         (uint32_t)&REGION_NAME(Load$$LR$$, LR_SECONDARY_PARTITION, $$Base) +
         SECONDARY_PARTITION_SIZE - 1,
 #endif /* BL2 */
-
-#ifdef NRF_NS_STORAGE
-    .non_secure_storage_partition_base =
-        (uint32_t)&REGION_NAME(Load$$LR$$, LR_NRF_NS_STORAGE_PARTITION, $$Base),
-    .non_secure_storage_partition_limit =
-        (uint32_t)&REGION_NAME(Load$$LR$$, LR_NRF_NS_STORAGE_PARTITION, $$Base) +
-        NRF_NS_STORAGE_PARTITION_SIZE - 1,
-#endif /* NRF_NS_STORAGE */
 };
 
 /* To write into AIRCR register, 0x5FA value must be write to the VECTKEY field,
@@ -222,13 +184,6 @@ enum tfm_plat_err_t spu_init_cfg(void)
                                         memory_regions.secondary_partition_limit);
 #endif /* BL2 */
 
-#ifdef NRF_NS_STORAGE
-    /* Configures storage partition to be non-secure */
-    spu_regions_flash_config_non_secure(
-        memory_regions.non_secure_storage_partition_base,
-        memory_regions.non_secure_storage_partition_limit);
-#endif /* NRF_NS_STORAGE */
-
     return TFM_PLAT_ERR_SUCCESS;
 }
 
@@ -257,10 +212,7 @@ enum tfm_plat_err_t spu_periph_init_cfg(void)
     spu_peripheral_config_non_secure((uint32_t)NRF_EGU2, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_EGU3, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_EGU4, false);
-#ifndef PSA_API_TEST_IPC
-    /* EGU5 is used as a secure peripheral in PSA FF tests */
     spu_peripheral_config_non_secure((uint32_t)NRF_EGU5, false);
-#endif
     spu_peripheral_config_non_secure((uint32_t)NRF_PWM0, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_PWM1, false);
     spu_peripheral_config_non_secure((uint32_t)NRF_PWM2, false);
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/target_cfg.h b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/target_cfg.h
index c8a83359e..3261c7c3d 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/target_cfg.h
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/target_cfg.h
@@ -49,10 +49,6 @@ struct memory_region_limits {
     uint32_t secondary_partition_base;
     uint32_t secondary_partition_limit;
 #endif /* BL2 */
-#ifdef NRF_NS_STORAGE
-    uint32_t non_secure_storage_partition_base;
-    uint32_t non_secure_storage_partition_limit;
-#endif
 };
 
 /**
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/tfm_peripherals_def.h
index 276895b9f..bba6a811b 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/nrf9160/tfm_peripherals_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2019, Arm Limited. All rights reserved.
  * Copyright (c) 2020, Cypress Semiconductor Corporation. All rights reserved.
  * Copyright (c) 2020, Nordic Semiconductor ASA. All rights reserved.
  *
@@ -26,22 +26,7 @@ extern struct platform_data_t tfm_peripheral_timer0;
 
 #define TFM_PERIPHERAL_STD_UART     (&tfm_peripheral_std_uart)
 #define TFM_PERIPHERAL_TIMER0       (&tfm_peripheral_timer0)
-
-#ifdef PSA_API_TEST_IPC
-#define FF_TEST_UART_IRQ         (EGU5_IRQn)
-#define FF_TEST_UART_IRQ_Handler (pal_interrupt_handler)
-
-extern struct platform_data_t tfm_peripheral_FF_TEST_NVMEM_REGION;
-extern struct platform_data_t tfm_peripheral_FF_TEST_SERVER_PARTITION_MMIO;
-extern struct platform_data_t tfm_peripheral_FF_TEST_DRIVER_PARTITION_MMIO;
-
-#define FF_TEST_UART_REGION           (&tfm_peripheral_std_uart)
-#define FF_TEST_WATCHDOG_REGION       (&tfm_peripheral_timer0)
-#define FF_TEST_NVMEM_REGION          (&tfm_peripheral_FF_TEST_NVMEM_REGION)
-#define FF_TEST_SERVER_PARTITION_MMIO (&tfm_peripheral_FF_TEST_SERVER_PARTITION_MMIO)
-#define FF_TEST_DRIVER_PARTITION_MMIO (&tfm_peripheral_FF_TEST_DRIVER_PARTITION_MMIO)
-#endif /* PSA_API_TEST_IPC */
-
+#define TFM_PERIPHERAL_FPGA_IO      (0)
 
 #ifdef __cplusplus
 }
diff --git a/lib/tf-m/platform/ext/target/nuvoton/common/native_drivers/mpu_armv8m_drv.h b/lib/tf-m/platform/ext/target/nuvoton/common/native_drivers/mpu_armv8m_drv.h
index 9244cdf2b..d427604f3 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/common/native_drivers/mpu_armv8m_drv.h
+++ b/lib/tf-m/platform/ext/target/nuvoton/common/native_drivers/mpu_armv8m_drv.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2019, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -91,7 +91,7 @@ enum mpu_armv8m_error_t mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -102,7 +102,7 @@ enum mpu_armv8m_error_t mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev);
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -114,7 +114,7 @@ enum mpu_armv8m_error_t mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev);
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_cfg     MPU region config \ref mpu_armv8m_region_cfg_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -128,7 +128,7 @@ enum mpu_armv8m_error_t mpu_armv8m_region_enable(
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_nr            Region number
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
diff --git a/lib/tf-m/platform/ext/target/nuvoton/common/tfm_hal_isolation.c b/lib/tf-m/platform/ext/target/nuvoton/common/tfm_hal_isolation.c
index f5485daf4..a7c576294 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/common/tfm_hal_isolation.c
+++ b/lib/tf-m/platform/ext/target/nuvoton/common/tfm_hal_isolation.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -33,8 +33,8 @@ REGION_DECLARE(Image$$, TFM_APP_CODE_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_CODE_END, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_END, $$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Base);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
 #ifdef TFM_SP_META_PTR_ENABLE
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Base);
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
@@ -64,8 +64,8 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     /* NSPM PSP */
     {
         MPU_REGION_NS_STACK,
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Base),
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Limit),
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base),
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit),
         MPU_ARMV8M_MAIR_ATTR_DATA_IDX,
         MPU_ARMV8M_XN_EXEC_NEVER,
         MPU_ARMV8M_AP_RW_PRIV_UNPRIV,
diff --git a/lib/tf-m/platform/ext/target/nuvoton/common/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/nuvoton/common/tfm_peripherals_def.h
index d09a6bbfe..1879f560e 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/common/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/nuvoton/common/tfm_peripherals_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2019, Arm Limited. All rights reserved.
  * Copyright (c) 2020, Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -27,6 +27,7 @@ extern struct platform_data_t tfm_peripheral_timer0;
 #define TFM_PERIPHERAL_STD_UART  (&tfm_peripheral_std_uart)
 #define TFM_PERIPHERAL_UART1     (&tfm_peripheral_uart1)
 #define TFM_PERIPHERAL_TIMER0    (&tfm_peripheral_timer0)
+#define TFM_PERIPHERAL_FPGA_IO   (0)
 
 #ifdef __cplusplus
 }
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2351/README.rst b/lib/tf-m/platform/ext/target/nuvoton/m2351/README.rst
index 0901269c8..8b44dceaa 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2351/README.rst
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2351/README.rst
@@ -12,7 +12,6 @@ Build TF-M with M2351 by following commands:
     $ cd build
     $ cmake ../ \
             -G"Unix Makefiles" \
-            -DTFM_LIB_MODEL=ON \
             -DTFM_PLATFORM=nuvoton/m2351 \
             -DTFM_TOOLCHAIN_FILE=../toolchain_GNUARM.cmake \
             -DTEST_NS=ON \
@@ -21,7 +20,7 @@ Build TF-M with M2351 by following commands:
 
 Define TEST_NS=ON or TEST_S=ON for non-secure or secure regression test.
 CMAKE_BUILD_TYPE could be "Release", "RelWithDebInfo" or "Minsizerel"
-TFM_LIB_MODEL=OFF and TFM_ISOLATION_LEVEL=2 can also be set but them cannot be
+TFM_PSA_API=ON and TFM_ISOLATION_LEVEL=2 can also be set but them cannot be
 defined with TEST_S=ON or TEST_NS=ON at the same time due to limited RAM size
 of M2351. Other cmake parameters should not be changed.
 
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/armclang/m2351_s.sct b/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/armclang/m2351_s.sct
index 822d191e5..1567b8d40 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/armclang/m2351_s.sct
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/armclang/m2351_s.sct
@@ -149,13 +149,13 @@ LR_CODE S_CODE_START {
     }
 #endif /* TFM_PARTITION_TEST_CORE_IPC */
 
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_SLIH_TEST_LINKER +0 ALIGN 32 {
         *tfm_Slih_test_service.* (+RO)
         *timer_cmsdk* (+RO)
         *(TFM_SLIH_TEST_ATTR_FN)
     }
-#endif /* TEST_NS_SLIH_IRQ */
+#endif /* TFM_ENABLE_SLIH_TEST */
 
 #ifdef TFM_PARTITION_TEST_SECURE_SERVICES
     TFM_SP_SECURE_CLIENT_2_LINKER +0 ALIGN 32 {
@@ -208,19 +208,19 @@ LR_CODE S_CODE_START {
     }
 
     /* MSP */
-    ARM_LIB_STACK +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
+    ARM_LIB_STACK_MSP +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
     }
 
 # if !defined(TFM_PSA_API)
     /* PSP is unprivileged in single-core topology. Reserve 8 bytes for seal */
-    ER_INITIAL_PSP +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE - 0x8 {
+    ARM_LIB_STACK +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE - 0x8 {
     }
 
-    ER_INITIAL_PSP_SEAL +0 EMPTY 0x8 {
+    ARM_LIB_STACK_SEAL +0 EMPTY 0x8 {
     }
 # else
     /* PSP is unprivileged in single-core topology */
-    ER_INITIAL_PSP +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
+    ARM_LIB_STACK +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
     }
 # endif /* !defined(TFM_PSA_API) */
 #endif
@@ -284,7 +284,7 @@ LR_CODE S_CODE_START {
 #endif
 #endif /* TFM_PARTITION_TEST_CORE_IPC */
 
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_SP_SLIH_TEST_LINKER_DATA +0 ALIGN 32 {
         *tfm_slih_test_service.* (+RW +ZI)
         *timer_cmsdk* (+RW +ZI)
@@ -296,7 +296,7 @@ LR_CODE S_CODE_START {
     TFM_SP_SLIH_TEST_LINKER_STACK +0 ALIGN 128 EMPTY 0x0400 {
     }
 #endif
-#endif /* TEST_NS_SLIH_IRQ */
+#endif /* TFM_ENABLE_SLIH_TEST */
 
 #ifdef TFM_PARTITION_TEST_SECURE_SERVICES
     TFM_SP_SECURE_CLIENT_2_LINKER_DATA +0 ALIGN 32 {
@@ -347,11 +347,11 @@ LR_CODE S_CODE_START {
     }
 
     /* MSP */
-    ARM_LIB_STACK +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
+    ARM_LIB_STACK_MSP +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
     }
 
     /* PSP is privileged in multi-core topology */
-    ER_INITIAL_PSP +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
+    ARM_LIB_STACK +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
     }
 #endif
 
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/armclang/startup_cmsdk_m2351_s.s b/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/armclang/startup_cmsdk_m2351_s.s
index 9374d1ff6..97d1e7118 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/armclang/startup_cmsdk_m2351_s.s
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/armclang/startup_cmsdk_m2351_s.s
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2016-2021 ARM Limited
+; * Copyright (c) 2016-2018 ARM Limited
 ; * Copyright (c) 2020 Nuvoton Technology Corp. All rights reserved.
 
 ; * Licensed under the Apache License, Version 2.0 (the "License");
@@ -26,6 +26,7 @@
 ;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
 ; </h>
 
+                IMPORT |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|
                 IMPORT |Image$$ARM_LIB_STACK$$ZI$$Limit|
 
 ; Vector Table Mapped to Address 0 at Reset
@@ -38,7 +39,7 @@
 
                 PRESERVE8
 
-__Vectors       DCD     |Image$$ARM_LIB_STACK$$ZI$$Limit|  ; Top of Stack
+__Vectors       DCD     |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|  ; Top of Stack
                 DCD     Reset_Handler             ; Reset Handler
                 DCD     NMI_Handler               ; NMI Handler
                 DCD     HardFault_Handler         ; Hard Fault Handler
@@ -175,6 +176,14 @@ Reset_Handler   PROC
                 CPSID   i              ; Disable IRQs
                 LDR     R0, =SystemInit
                 BLX     R0
+                MRS     R0, control    ; Get control value
+                MOVS    R1, #2
+                ORRS    R0, R0, R1     ; Select switch to PSP
+                MSR     control, R0
+                LDR     R0, =|Image$$ARM_LIB_STACK$$ZI$$Limit|
+                MOVS    R1, #7
+                BICS    R0, R1         ; Make sure that the SP address is aligned to 8
+                MOV     SP, R0         ; Initialise PSP
                 LDR     R0, =__main
                 BX      R0
                 ENDP
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/gcc/startup_cmsdk_m2351_s.S b/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/gcc/startup_cmsdk_m2351_s.S
index 848d3af58..58f29dd99 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/gcc/startup_cmsdk_m2351_s.S
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/gcc/startup_cmsdk_m2351_s.S
@@ -27,7 +27,7 @@
     .align 2
     .globl    __Vectors
 __Vectors:
-    .long    Image$$ARM_LIB_STACK$$ZI$$Limit   /* Top of Stack */
+    .long    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit   /* Top of Stack */
 
     /* Core interrupts */
     .long    Reset_Handler                  /* Reset Handler */
@@ -289,6 +289,13 @@ Reset_Handler:
     cpsid   i              /* Disable IRQs */
     bl    SystemInit
 
+    mrs     r0, control    /* Get control value */
+    movs    r1, #2
+    orrs    r0, r0, r1     /* Select switch to PSP */
+    msr     control, r0
+    ldr     r0, =Image$$ARM_LIB_STACK$$ZI$$Limit
+    msr     psp, r0
+
 #ifndef __START
 #define __START _start
 #endif
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/iar/startup_cmsdk_m2351_ns.s b/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/iar/startup_cmsdk_m2351_ns.s
index 784591a98..789258437 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/iar/startup_cmsdk_m2351_ns.s
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/iar/startup_cmsdk_m2351_ns.s
@@ -1,7 +1,6 @@
 ;/*
 ; * Copyright (c) 2016-2020 ARM Limited
 ; * Copyright (c) 2020 Nuvoton Technology Corp. All rights reserved.
-; * Copyright (c) 2021 IAR Systems AB
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -172,6 +171,8 @@ __Vectors_Size  EQU     __Vectors_End - __Vectors
 
 Reset_Handler
                 MRS     R0, control    ; Get control value
+                MOVS    R1, #1
+                ORRS    R0, R0, R1     ; Select switch to unprivileged mode
                 MOVS    R1, #2
                 ORRS    R0, R0, R1     ; Select switch to PSP
                 MSR     control, R0
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/iar/startup_cmsdk_m2351_s.s b/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/iar/startup_cmsdk_m2351_s.s
index 01327f8d1..57761d420 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/iar/startup_cmsdk_m2351_s.s
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2351/device/source/iar/startup_cmsdk_m2351_s.s
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2016-2021 ARM Limited
+; * Copyright (c) 2016-2020 ARM Limited
 ; * Copyright (c) 2020 Nuvoton Technology Corp. All rights reserved.
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
@@ -29,6 +29,7 @@
                 MODULE   ?cstartup
 
                 ;; Forward declaration of sections.
+                SECTION  ARM_LIB_STACK_MSP:DATA:NOROOT(3)
                 SECTION  ARM_LIB_STACK:DATA:NOROOT(3)
 
                 SECTION  .intvec:CODE:NOROOT(2)
@@ -44,7 +45,7 @@
                 DATA
 
 __vector_table      ;Core Interrupts
-                DCD     sfe(ARM_LIB_STACK)        ; Top of Stack
+                DCD     sfe(ARM_LIB_STACK_MSP)    ; Top of Stack
                 DCD     Reset_Handler             ; Reset Handler
                 DCD     NMI_Handler               ; NMI Handler
                 DCD     HardFault_Handler         ; Hard Fault Handler
@@ -177,6 +178,14 @@ Reset_Handler
                 CPSID   i              ; Disable IRQs
                 LDR     R0, =SystemInit
                 BLX     R0
+                MRS     R0, control    ; Get control value
+                MOVS    R1, #2
+                ORRS    R0, R0, R1     ; Select switch to PSP
+                MSR     control, R0
+                LDR     R0, =sfe(ARM_LIB_STACK)      ; End of PROC_STACK
+                MOVS    R1, #7
+                BICS    R0, R1         ; Make sure that the SP address is aligned to 8
+                MOV     SP, R0         ; Initialise PSP
                 LDR     R0, =__iar_program_start
                 BX      R0
 
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2351/partition/flash_layout.h b/lib/tf-m/platform/ext/target/nuvoton/m2351/partition/flash_layout.h
index 19181c536..103867de8 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2351/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2351/partition/flash_layout.h
@@ -21,9 +21,9 @@
 /* Flash layout on M2351 with BL2 (single image boot):
  *
  * 0x0000_0000 BL2 - MCUBoot (32KB)
- * 0x0000_8000 Protected Storage Area (12 KB)
- * 0x0000_B000 Internal Trusted Storage Area (12 KB)
- * 0x0000_E000 OTP / NV counters area (8 KB)
+ * 0x0000_8000 Protected Storage Area (16 KB)
+ * 0x0000_C000 Internal Trusted Storage Area (12 KB)
+ * 0x0000_F000 NV counters area (4 KB)
  * 0x0001_0000 Primary image area (256KB):
  *    0x0001_0000 Secure     image primary
  *    0x0005_0000 Non-secure image primary
@@ -94,18 +94,17 @@
 
 /* Protected Storage (PS) Service definitions */
 #define FLASH_PS_AREA_OFFSET            (0x8000)
-#define FLASH_PS_AREA_SIZE              (0x3000)
+#define FLASH_PS_AREA_SIZE              (0x4000)
 
 /* Internal Trusted Storage (ITS) Service definitions */
 #define FLASH_ITS_AREA_OFFSET           (FLASH_PS_AREA_OFFSET + \
                                          FLASH_PS_AREA_SIZE)
 #define FLASH_ITS_AREA_SIZE             (0x3000)
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* Offset and size definition in flash area used by assemble.py */
 #define SECURE_IMAGE_OFFSET             (0x0)
@@ -119,8 +118,6 @@
  * Name is defined in flash driver file: Driver_Flash.c
  */
 #define FLASH_DEV_NAME Driver_FLASH0
-/* Smallest flash programmable unit in bytes */
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x4)
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -162,12 +159,11 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x4)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18) /* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
 
 /* Use SRAM1 memory to store Code data */
 #define S_ROM_ALIAS_BASE  (0x00000000)
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2351/plat_test.c b/lib/tf-m/platform/ext/target/nuvoton/m2351/plat_test.c
index 90de33573..22f43b885 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2351/plat_test.c
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2351/plat_test.c
@@ -11,8 +11,58 @@
 #include "tfm_plat_test.h"
 #include "device_definition.h"
 
+#define USERLED_MASK                (0x3)
+#define BTN_WAIT_INIT_COUNTER_VALUE (10000u)
 #define TIMER_RELOAD_VALUE          (12000000)
 
+/**
+ * \brief Store the state of the mocked LED
+ *
+ * This variable have to be linked to the data section of the partition
+ * TFM_SP_CORE_TEST so that in case of in case of isolation within the secure
+ * domain the Core Test service can access it.
+ */
+uint32_t led_status
+    TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_CORE_TEST", "PSA-ROT")
+    = 0x02u;
+
+/**
+ * \brief Simulate user reaction time
+ */
+static void busy_wait_to_simulate_user(void)
+{
+    volatile uint32_t counter = BTN_WAIT_INIT_COUNTER_VALUE;
+    while (counter)
+    {
+        --counter;
+    }
+}
+
+void tfm_plat_test_wait_user_button_pressed(void)
+{
+    busy_wait_to_simulate_user();
+}
+
+void tfm_plat_test_wait_user_button_released(void)
+{
+    busy_wait_to_simulate_user();
+}
+
+uint32_t tfm_plat_test_get_led_status(void)
+{
+    return led_status;
+}
+
+void tfm_plat_test_set_led_status(uint32_t status)
+{
+    led_status = status & USERLED_MASK;
+}
+
+uint32_t tfm_plat_test_get_userled_mask(void)
+{
+    return USERLED_MASK;
+}
+
 void tfm_plat_test_non_secure_timer_start(void)
 {
     if(!timer_cmsdk_is_initialized(&CMSDK_TIMER2_DEV_NS)) {
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2354/README.rst b/lib/tf-m/platform/ext/target/nuvoton/m2354/README.rst
index 20558e902..956ee6334 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2354/README.rst
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2354/README.rst
@@ -16,13 +16,14 @@ Build TF-M with M2354 by following commands:
             -DTFM_TOOLCHAIN_FILE=../toolchain_GNUARM.cmake \
             -DTEST_S=ON \
             -DTEST_NS=ON \
+            -DTFM_PSA_API=ON \
             -DTFM_ISOLATION_LEVEL=2 \
             -DCMAKE_BUILD_TYPE=Release \
     $ make install
 
 Define TEST_NS=ON or TEST_S=ON for non-secure or secure regression test.
 CMAKE_BUILD_TYPE could be "Release", "Debug", "RelWithDebInfo" or "Minsizerel"
-TFM_ISOLATION_LEVEL=2 can also be set.
+TFM_PSA_API=ON and TFM_ISOLATION_LEVEL=2 can also be set.
 Other cmake parameters should not be changed.
 
 Flashing Image with Nuvoton NuLink Tool
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/armclang/m2354_s.sct b/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/armclang/m2354_s.sct
index 2007801b9..102ed12e9 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/armclang/m2354_s.sct
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/armclang/m2354_s.sct
@@ -149,13 +149,13 @@ LR_CODE S_CODE_START {
     }
 #endif /* TFM_PARTITION_TEST_CORE_IPC */
 
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_SP_SLIH_TEST_LINKER +0 ALIGN 32 {
         *tfm_slih_test_service.* (+RO)
         *timer_cmsdk* (+RO)
         *(TFM_SP_SLIH_TEST_ATTR_FN)
     }
-#endif /* TEST_NS_SLIH_IRQ */
+#endif /* TFM_ENABLE_SLIH_TEST */
 
 #ifdef TFM_PARTITION_TEST_SECURE_SERVICES
     TFM_SP_SECURE_CLIENT_2_LINKER +0 ALIGN 32 {
@@ -208,19 +208,19 @@ LR_CODE S_CODE_START {
     }
 
     /* MSP */
-    ARM_LIB_STACK +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
+    ARM_LIB_STACK_MSP +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
     }
 
 # if !defined(TFM_PSA_API)
     /* PSP is unprivileged in single-core topology. Reserve 8 bytes for seal */
-    ER_INITIAL_PSP +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE - 0x8 {
+    ARM_LIB_STACK +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE - 0x8 {
     }
 
-    ER_INITIAL_PSP_SEAL +0 EMPTY 0x8 {
+    ARM_LIB_STACK_SEAL +0 EMPTY 0x8 {
     }
 # else
     /* PSP is unprivileged in single-core topology */
-    ER_INITIAL_PSP +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
+    ARM_LIB_STACK +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
     }
 # endif /* !defined(TFM_PSA_API) */
 #endif
@@ -278,7 +278,7 @@ LR_CODE S_CODE_START {
 #endif
 #endif /* TFM_PARTITION_TEST_CORE_IPC */
 
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
     TFM_SP_SLIH_TEST_LINKER_DATA +0 ALIGN 32 {
         *tfm_slih_test_service.* (+RW +ZI)
         *timer_cmsdk* (+RW +ZI)
@@ -290,7 +290,7 @@ LR_CODE S_CODE_START {
     TFM_SP_SLIH_TEST_LINKER_STACK +0 ALIGN 128 EMPTY 0x0400 {
     }
 #endif
-#endif /* TEST_NS_SLIH_IRQ */
+#endif /* TFM_ENABLE_SLIH_TEST */
 
 #ifdef TFM_PARTITION_TEST_SECURE_SERVICES
     TFM_SP_SECURE_CLIENT_2_LINKER_DATA +0 ALIGN 32 {
@@ -341,11 +341,11 @@ LR_CODE S_CODE_START {
     }
 
     /* MSP */
-    ARM_LIB_STACK +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
+    ARM_LIB_STACK_MSP +0 ALIGN 32 OVERLAY EMPTY S_MSP_STACK_SIZE {
     }
 
     /* PSP is privileged in multi-core topology */
-    ER_INITIAL_PSP +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
+    ARM_LIB_STACK +0 ALIGN 32 EMPTY S_PSP_STACK_SIZE {
     }
 #endif
 
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/armclang/startup_cmsdk_m2354_s.s b/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/armclang/startup_cmsdk_m2354_s.s
index c78dd4eb3..394fef665 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/armclang/startup_cmsdk_m2354_s.s
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/armclang/startup_cmsdk_m2354_s.s
@@ -26,6 +26,7 @@
 ;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
 ; </h>
 
+                IMPORT |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|
                 IMPORT |Image$$ARM_LIB_STACK$$ZI$$Limit|
 
 ; Vector Table Mapped to Address 0 at Reset
@@ -38,7 +39,7 @@
 
                 PRESERVE8
 
-__Vectors       DCD     |Image$$ARM_LIB_STACK$$ZI$$Limit|  ; Top of Stack
+__Vectors       DCD     |Image$$ARM_LIB_STACK_MSP$$ZI$$Limit|  ; Top of Stack
                 DCD     Reset_Handler             ; Reset Handler
                 DCD     NMI_Handler               ; NMI Handler
                 DCD     HardFault_Handler         ; Hard Fault Handler
@@ -175,6 +176,14 @@ Reset_Handler   PROC
                 CPSID   i              ; Disable IRQs
                 LDR     R0, =SystemInit
                 BLX     R0
+                MRS     R0, control    ; Get control value
+                MOVS    R1, #2
+                ORRS    R0, R0, R1     ; Select switch to PSP
+                MSR     control, R0
+                LDR     R0, =|Image$$ARM_LIB_STACK$$ZI$$Limit|
+                MOVS    R1, #7
+                BICS    R0, R1         ; Make sure that the SP address is aligned to 8
+                MOV     SP, R0         ; Initialise PSP
                 LDR     R0, =__main
                 BX      R0
                 ENDP
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/gcc/startup_cmsdk_m2354_s.S b/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/gcc/startup_cmsdk_m2354_s.S
index 92429464e..196950238 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/gcc/startup_cmsdk_m2354_s.S
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/gcc/startup_cmsdk_m2354_s.S
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2009-2021 ARM Limited
+; * Copyright (c) 2009-2018 ARM Limited
 ; * Copyright (c) 2020 Nuvoton Technology Corp. All rights reserved.
 
 ; * Licensed under the Apache License, Version 2.0 (the "License");
@@ -27,7 +27,7 @@
     .align 2
     .globl    __Vectors
 __Vectors:
-    .long    Image$$ARM_LIB_STACK$$ZI$$Limit   /* Top of Stack */
+    .long    Image$$ARM_LIB_STACK_MSP$$ZI$$Limit   /* Top of Stack */
 
     /* Core interrupts */
     .long    Reset_Handler                  /* Reset Handler */
@@ -289,6 +289,13 @@ Reset_Handler:
     cpsid   i              /* Disable IRQs */
     bl    SystemInit
 
+    mrs     r0, control    /* Get control value */
+    movs    r1, #2
+    orrs    r0, r0, r1     /* Select switch to PSP */
+    msr     control, r0
+    ldr     r0, =Image$$ARM_LIB_STACK$$ZI$$Limit
+    msr     psp, r0
+
 #ifndef __START
 #define __START _start
 #endif
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/iar/startup_cmsdk_m2354_s.s b/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/iar/startup_cmsdk_m2354_s.s
index 01327f8d1..57761d420 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/iar/startup_cmsdk_m2354_s.s
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2354/device/source/iar/startup_cmsdk_m2354_s.s
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2016-2021 ARM Limited
+; * Copyright (c) 2016-2020 ARM Limited
 ; * Copyright (c) 2020 Nuvoton Technology Corp. All rights reserved.
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
@@ -29,6 +29,7 @@
                 MODULE   ?cstartup
 
                 ;; Forward declaration of sections.
+                SECTION  ARM_LIB_STACK_MSP:DATA:NOROOT(3)
                 SECTION  ARM_LIB_STACK:DATA:NOROOT(3)
 
                 SECTION  .intvec:CODE:NOROOT(2)
@@ -44,7 +45,7 @@
                 DATA
 
 __vector_table      ;Core Interrupts
-                DCD     sfe(ARM_LIB_STACK)        ; Top of Stack
+                DCD     sfe(ARM_LIB_STACK_MSP)    ; Top of Stack
                 DCD     Reset_Handler             ; Reset Handler
                 DCD     NMI_Handler               ; NMI Handler
                 DCD     HardFault_Handler         ; Hard Fault Handler
@@ -177,6 +178,14 @@ Reset_Handler
                 CPSID   i              ; Disable IRQs
                 LDR     R0, =SystemInit
                 BLX     R0
+                MRS     R0, control    ; Get control value
+                MOVS    R1, #2
+                ORRS    R0, R0, R1     ; Select switch to PSP
+                MSR     control, R0
+                LDR     R0, =sfe(ARM_LIB_STACK)      ; End of PROC_STACK
+                MOVS    R1, #7
+                BICS    R0, R1         ; Make sure that the SP address is aligned to 8
+                MOV     SP, R0         ; Initialise PSP
                 LDR     R0, =__iar_program_start
                 BX      R0
 
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2354/partition/flash_layout.h b/lib/tf-m/platform/ext/target/nuvoton/m2354/partition/flash_layout.h
index bc6eb46cd..ecf61a6cc 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2354/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2354/partition/flash_layout.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
  * Copyright (c) 2020 Nuvoton Technology Corp. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -21,9 +21,9 @@
 /* Flash layout on M2354 with BL2 (single image boot):
  *
  * 0x0000_0000 BL2 - MCUBoot (64KB)
- * 0x0001_0000 Protected Storage Area (28 KB)
- * 0x0000_7000 Internal Trusted Storage Area (28 KB)
- * 0x0000_E000 OTP / NV counters area (8 KB)
+ * 0x0001_0000 Protected Storage Area (32 KB)
+ * 0x0000_8000 Internal Trusted Storage Area (28 KB)
+ * 0x0000_F000 NV counters area (4 KB)
  * 0x0002_0000 Primary image area (320KB):
  *    0x0002_0000 Secure     image primary
  *    0x0007_0000 Non-secure image primary
@@ -94,18 +94,17 @@
 
 /* Protected Storage (PS) Service definitions */
 #define FLASH_PS_AREA_OFFSET            (0x10000)
-#define FLASH_PS_AREA_SIZE              (0x7000)
+#define FLASH_PS_AREA_SIZE              (0x8000)
 
 /* Internal Trusted Storage (ITS) Service definitions */
 #define FLASH_ITS_AREA_OFFSET           (FLASH_PS_AREA_OFFSET + \
                                          FLASH_PS_AREA_SIZE)
 #define FLASH_ITS_AREA_SIZE             (0x7000)
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* Offset and size definition in flash area used by assemble.py */
 #define SECURE_IMAGE_OFFSET             (0x0)
@@ -119,8 +118,6 @@
  * Name is defined in flash driver file: Driver_Flash.c
  */
 #define FLASH_DEV_NAME Driver_FLASH0
-/* Smallest flash programmable unit in bytes */
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x4)
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -160,12 +157,11 @@
 /* Specifies the smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT  (0x4)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18) /* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
 
 /* Use SRAM1 memory to store Code data */
 #define S_ROM_ALIAS_BASE  (0x00000000)
diff --git a/lib/tf-m/platform/ext/target/nuvoton/m2354/plat_test.c b/lib/tf-m/platform/ext/target/nuvoton/m2354/plat_test.c
index 90de33573..1af8bcf09 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/m2354/plat_test.c
+++ b/lib/tf-m/platform/ext/target/nuvoton/m2354/plat_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  * Copyright (c) 2020 Nuvoton Technology Corp. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -11,8 +11,41 @@
 #include "tfm_plat_test.h"
 #include "device_definition.h"
 
+#define USERLED_MASK                (0x3)
+#define BTN_WAIT_INIT_COUNTER_VALUE (10000u)
 #define TIMER_RELOAD_VALUE          (12000000)
 
+void tfm_plat_test_wait_user_button_pressed(void)
+{
+    /* Wait until user button 0 is pressed */
+    while(PF11){
+        ;
+    }
+}
+
+void tfm_plat_test_wait_user_button_released(void)
+{
+    /* Wait until user button 0 is released */
+    while(!PF11){
+        ;
+    }
+}
+
+uint32_t tfm_plat_test_get_led_status(void)
+{
+    return PD2;
+}
+
+void tfm_plat_test_set_led_status(uint32_t status)
+{
+    PD2 = status;
+}
+
+uint32_t tfm_plat_test_get_userled_mask(void)
+{
+    return USERLED_MASK;
+}
+
 void tfm_plat_test_non_secure_timer_start(void)
 {
     if(!timer_cmsdk_is_initialized(&CMSDK_TIMER2_DEV_NS)) {
diff --git a/lib/tf-m/platform/ext/target/nxp/common/Native_Driver/mpu_armv8m_drv.h b/lib/tf-m/platform/ext/target/nxp/common/Native_Driver/mpu_armv8m_drv.h
index 9244cdf2b..d427604f3 100755
--- a/lib/tf-m/platform/ext/target/nxp/common/Native_Driver/mpu_armv8m_drv.h
+++ b/lib/tf-m/platform/ext/target/nxp/common/Native_Driver/mpu_armv8m_drv.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2019, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -91,7 +91,7 @@ enum mpu_armv8m_error_t mpu_armv8m_enable(struct mpu_armv8m_dev_t *dev,
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -102,7 +102,7 @@ enum mpu_armv8m_error_t mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev);
  *
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -114,7 +114,7 @@ enum mpu_armv8m_error_t mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev);
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_cfg     MPU region config \ref mpu_armv8m_region_cfg_t
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
@@ -128,7 +128,7 @@ enum mpu_armv8m_error_t mpu_armv8m_region_enable(
  * \param[in] dev            MPU device \ref mpu_armv8m_dev_t
  * \param[in] region_nr            Region number
  *
- * \return Error code \ref mpu_armv8m_error_t
+ * \return Error code \ref arm_mpu_error_t
  *
  * \note This function doesn't check if dev is NULL.
  */
diff --git a/lib/tf-m/platform/ext/target/nxp/common/plat_attest_hal.c b/lib/tf-m/platform/ext/target/nxp/common/plat_attest_hal.c
index 646ab804c..ff1624968 100644
--- a/lib/tf-m/platform/ext/target/nxp/common/plat_attest_hal.c
+++ b/lib/tf-m/platform/ext/target/nxp/common/plat_attest_hal.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
  * Copyright 2020 NXP. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -11,7 +11,6 @@
 #include "tfm_attest_hal.h"
 #include "tfm_plat_boot_seed.h"
 #include "tfm_plat_device_id.h"
-#include "tfm_plat_otp.h"
 
 #include "log/tfm_log.h"
 
@@ -19,72 +18,52 @@
 #include "fsl_common.h"
 #endif
 
-static size_t strnlen(const char *s, size_t maxlen)
-{
-    size_t idx;
+/*!
+ * \def BOOT_SEED
+ *
+ * \brief Fixed value for boot seed used for test.
+ */
+#define BOOT_SEED   0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, \
+                    0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, \
+                    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, \
+                    0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF
 
-    for (idx = 0; idx < maxlen; idx++) {
-        if (s[idx] == '\0') {
-            return idx;
-        }
-    }
+static const uint8_t boot_seed[BOOT_SEED_SIZE] = {BOOT_SEED};
 
-    return idx;
-}
+/* Example verification service URL for initial attestation token */
+static const char verification_service_url[] = "www.trustedfirmware.org";
 
-enum tfm_security_lifecycle_t tfm_attest_hal_get_security_lifecycle(void)
-{
-    uint32_t lcs;
-    enum tfm_plat_err_t err;
+/* Example profile definition document for initial attestation token */
+static const char attestation_profile_definition[] = "PSA_IOT_PROFILE_1";
 
-    err = tfm_plat_otp_read(PLAT_OTP_ID_LCS, sizeof(lcs), (uint8_t*)&lcs);
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        return TFM_SLC_UNKNOWN;
-    }
+static const uint8_t implementation_id[] = {
+    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
+    0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
+    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
+    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
+};
 
-    return (enum tfm_security_lifecycle_t) lcs;
-}
+static const uint8_t example_ean_13[] = "060456527282910010";
 
-enum tfm_plat_err_t
-tfm_attest_hal_get_verification_service(uint32_t *size, uint8_t *buf)
+enum tfm_security_lifecycle_t tfm_attest_hal_get_security_lifecycle(void)
 {
-    enum tfm_plat_err_t err;
-    size_t otp_size;
-
-    err = tfm_plat_otp_read(PLAT_OTP_ID_VERIFICATION_SERVICE_URL, *size, buf);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
-
-    err =  tfm_plat_otp_get_size(PLAT_OTP_ID_VERIFICATION_SERVICE_URL, &otp_size);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
-
-    *size = strnlen((char*)buf, otp_size);
-
-    return TFM_PLAT_ERR_SUCCESS;
+    return TFM_SLC_SECURED;
 }
 
-enum tfm_plat_err_t
-tfm_attest_hal_get_profile_definition(uint32_t *size, uint8_t *buf)
+const char *
+tfm_attest_hal_get_verification_service(uint32_t *size)
 {
-    enum tfm_plat_err_t err;
-    size_t otp_size;
+    *size = sizeof(verification_service_url) - 1;
 
-    err = tfm_plat_otp_read(PLAT_OTP_ID_PROFILE_DEFINITION, *size, buf);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
-
-    err =  tfm_plat_otp_get_size(PLAT_OTP_ID_PROFILE_DEFINITION, &otp_size);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+    return verification_service_url;
+}
 
-    *size = strnlen((char*)buf, otp_size);
+const char *
+tfm_attest_hal_get_profile_definition(uint32_t *size)
+{
+    *size = sizeof(attestation_profile_definition) - 1;
 
-    return TFM_PLAT_ERR_SUCCESS;
+    return attestation_profile_definition;
 }
 
 /**
@@ -107,27 +86,23 @@ static inline void copy_buf(uint8_t *p_dst, const uint8_t *p_src, size_t size)
 
 enum tfm_plat_err_t tfm_plat_get_boot_seed(uint32_t size, uint8_t *buf)
 {
-    enum tfm_plat_err_t err;
+    uint8_t *p_dst = buf;
+    const uint8_t *p_src = boot_seed;
 
     if (size != BOOT_SEED_SIZE) {
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
-
+        
 #ifdef PLAT_HAS_BOOT_SEED /* Platform has boot seed register */
-
+   
     if(SYSCON->BOOT_SEED_REG0 != 0) /* Check if the seed was generated */
     {
-        /* Copy from array of BOOT_SEED_REG[0-7] */
-        copy_buf(buf, (uint8_t *)&SYSCON->BOOT_SEED_REG0;, size);
-        return TFM_PLAT_ERR_SUCCESS
+        p_src = (uint8_t *)&SYSCON->BOOT_SEED_REG0; /* Array of BOOT_SEED_REG[0-7] */
     }
-
+    
 #endif
-
-    err = tfm_plat_otp_read(PLAT_OTP_ID_BOOT_SEED, size, buf);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+    
+    copy_buf(p_dst, p_src, size);
 
     return TFM_PLAT_ERR_SUCCESS;
 }
@@ -135,40 +110,30 @@ enum tfm_plat_err_t tfm_plat_get_boot_seed(uint32_t size, uint8_t *buf)
 enum tfm_plat_err_t tfm_plat_get_implementation_id(uint32_t *size,
                                                    uint8_t  *buf)
 {
-    enum tfm_plat_err_t err;
-    size_t otp_size;
-
-    err = tfm_plat_otp_read(PLAT_OTP_ID_IMPLEMENTATION_ID, *size, buf);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+    const uint8_t *p_impl_id = implementation_id;
+    uint32_t impl_id_size = sizeof(implementation_id);
 
-    err =  tfm_plat_otp_get_size(PLAT_OTP_ID_IMPLEMENTATION_ID, &otp_size);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
+    if (*size < impl_id_size) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
-    *size = otp_size;
+    copy_buf(buf, p_impl_id, impl_id_size);
+    *size = impl_id_size;
 
     return TFM_PLAT_ERR_SUCCESS;
 }
 
 enum tfm_plat_err_t tfm_plat_get_hw_version(uint32_t *size, uint8_t *buf)
 {
-    enum tfm_plat_err_t err;
-    size_t otp_size;
-
-    err = tfm_plat_otp_read(PLAT_OTP_ID_HW_VERSION, *size, buf);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
-    }
+    const uint8_t *p_hw_version = example_ean_13;
+    uint32_t hw_version_size = sizeof(example_ean_13) - 1;
 
-    err =  tfm_plat_otp_get_size(PLAT_OTP_ID_HW_VERSION, &otp_size);
-    if(err != TFM_PLAT_ERR_SUCCESS) {
-        return err;
+    if (*size < hw_version_size) {
+        return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
-    *size = strnlen((char*)buf, otp_size);
+    copy_buf(buf, p_hw_version, hw_version_size);
+    *size = hw_version_size;
 
     return TFM_PLAT_ERR_SUCCESS;
 }
diff --git a/lib/tf-m/platform/ext/target/nxp/common/plat_test.c b/lib/tf-m/platform/ext/target/nxp/common/plat_test.c
index 6a34c00b4..416b6d744 100644
--- a/lib/tf-m/platform/ext/target/nxp/common/plat_test.c
+++ b/lib/tf-m/platform/ext/target/nxp/common/plat_test.c
@@ -11,9 +11,63 @@
 #include "device_definition.h"
 #include "tfm_peripherals_def.h"
 
+#define USERLED_MASK                (0x3)
+#define BTN_WAIT_INIT_COUNTER_VALUE (10000u)
 #define TIMER_RELOAD_VALUE          (CTIMER_CLK_FREQ * 1) /* 1 sec */
 
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_PERIPH_ACCESS_TEST
+
+/**
+ * \brief Store the state of the mocked LED
+ *
+ * This variable have to be linked to the data section of the partition
+ * TFM_SP_CORE_TEST so that in case of in case of isolation within the secure
+ * domain the Core Test service can access it.
+ */
+uint32_t led_status
+    TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_CORE_TEST", "PSA-ROT")
+    = 0x02u;
+
+/**
+ * \brief Simulate user reaction time
+ */
+static void busy_wait_to_simulate_user(void)
+{
+    volatile uint32_t counter = BTN_WAIT_INIT_COUNTER_VALUE;
+    while (counter)
+    {
+        --counter;
+    }
+}
+
+void tfm_plat_test_wait_user_button_pressed(void)
+{
+    busy_wait_to_simulate_user();
+}
+
+void tfm_plat_test_wait_user_button_released(void)
+{
+    busy_wait_to_simulate_user();
+}
+
+uint32_t tfm_plat_test_get_led_status(void)
+{
+    return led_status;
+}
+
+void tfm_plat_test_set_led_status(uint32_t status)
+{
+    led_status = status & USERLED_MASK;
+}
+
+uint32_t tfm_plat_test_get_userled_mask(void)
+{
+    return USERLED_MASK;
+}
+
+#endif /* TFM_ENABLE_PERIPH_ACCESS_TEST */
+
+#ifdef TFM_ENABLE_SLIH_TEST
 
 #if (__ARM_FEATURE_CMSE & 0x2) /* Secure */
 
@@ -100,4 +154,4 @@ void tfm_plat_test_non_secure_timer_stop(void)
 }
 #endif /* (__ARM_FEATURE_CMSE & 0x2) */
 
-#endif /* TEST_NS_SLIH_IRQ */
+#endif /* TFM_ENABLE_SLIH_TEST */
diff --git a/lib/tf-m/platform/ext/target/nxp/common/spm_hal.c b/lib/tf-m/platform/ext/target/nxp/common/spm_hal.c
index 4d52eb104..9844bb4a8 100644
--- a/lib/tf-m/platform/ext/target/nxp/common/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/nxp/common/spm_hal.c
@@ -6,10 +6,12 @@
  *
  */
 
+#include <stdio.h>
 #include "cmsis.h"
 #include "tfm_spm_hal.h"
 #include "tfm_platform_core_api.h"
 #include "target_cfg.h"
+#include "mpu_armv8m_drv.h"
 #include "utilities.h"
 
 #include "Driver_Common.h"
@@ -18,6 +20,58 @@
 /* Get address of memory regions to configure MPU */
 extern const struct memory_region_limits memory_regions;
 
+struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
+
+#ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
+#define PARTITION_REGION_PERIPH_START   6   //NXP 5
+#define PARTITION_REGION_PERIPH_MAX_NUM 2
+
+uint32_t periph_num_count = 0;
+#endif /* CONFIG_TFM_ENABLE_MEMORY_PROTECT */
+
+enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
+                  bool privileged,
+                  const struct platform_data_t *platform_data)
+{
+#if defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1)
+    struct mpu_armv8m_region_cfg_t region_cfg;
+#endif
+
+    if (!platform_data) {
+        return TFM_PLAT_ERR_INVALID_INPUT;
+    }
+
+#if defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1)
+    if (!privileged) {
+        region_cfg.region_nr = PARTITION_REGION_PERIPH_START + periph_num_count;
+        periph_num_count++;
+        if (periph_num_count >= PARTITION_REGION_PERIPH_MAX_NUM) {
+            return TFM_PLAT_ERR_MAX_VALUE;
+        }
+        region_cfg.region_base = platform_data->periph_start;
+        region_cfg.region_limit = platform_data->periph_limit;
+        region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
+        region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
+        region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
+        region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
+
+        mpu_armv8m_disable(&dev_mpu_s);
+
+        if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg)
+            != MPU_ARMV8M_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+        mpu_armv8m_enable(&dev_mpu_s, PRIVILEGED_DEFAULT_ENABLE,
+                          HARDFAULT_NMI_ENABLE);
+    }
+#endif /* defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1) */
+    if (platform_data->periph_ppc_bank != 0 /* PPC_SP_DO_NOT_CONFIGURE */) {
+        ppc_configure_to_secure(platform_data->periph_ppc_bank,
+                                platform_data->periph_ppc_loc, privileged);
+
+    }
+    return TFM_PLAT_ERR_SUCCESS;
+}
 
 void SEC_VIO_IRQHandler(void)
 {
@@ -110,19 +164,3 @@ enum tfm_plat_err_t tfm_spm_hal_nvic_interrupt_enable(void)
 {
     return nvic_interrupt_enable();
 }
-
-#ifndef TFM_PSA_API
-enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
-                  bool privileged,
-                  const struct platform_data_t *platform_data)
-{
-    if (!platform_data) {
-        return TFM_PLAT_ERR_INVALID_INPUT;
-    }
-    if (platform_data->periph_ppc_bank != PPC_SP_DO_NOT_CONFIGURE) {
-        ppc_configure_to_secure(platform_data->periph_ppc_bank,
-                                platform_data->periph_ppc_loc, privileged);
-    }
-    return TFM_PLAT_ERR_SUCCESS;
-}
-#endif /* TFM_PSA_API */
\ No newline at end of file
diff --git a/lib/tf-m/platform/ext/target/nxp/common/tfm_hal_isolation.c b/lib/tf-m/platform/ext/target/nxp/common/tfm_hal_isolation.c
index 5d9442758..425c8d56c 100644
--- a/lib/tf-m/platform/ext/target/nxp/common/tfm_hal_isolation.c
+++ b/lib/tf-m/platform/ext/target/nxp/common/tfm_hal_isolation.c
@@ -1,33 +1,21 @@
 /*
- * Copyright (c) 2020-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
  */
 
-#include "array.h"
 #include "cmsis.h"
 #include "Driver_Common.h"
-#include "mmio_defs.h"
 #include "mpu_armv8m_drv.h"
 #include "region.h"
 #include "target_cfg.h"
 #include "tfm_hal_isolation.h"
 #include "region_defs.h" //NXP
 #include "log/tfm_log.h"
-#include "tfm_peripherals_def.h"
-#include "tfm_core_utils.h"
-#include "load/partition_defs.h"
-#include "load/asset_defs.h"
-#include "load/spm_load_api.h"
-/* It can be retrieved from the MPU_TYPE register. */
-#define MPU_REGION_NUM                  8
 
 #ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
-static uint32_t n_configured_regions = 0;
-struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 #if TFM_LVL == 3
-static uint32_t idx_boundary_handle = 0;
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Base);
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Limit);
 REGION_DECLARE(Image$$, PT_RO_START, $$Base);
@@ -35,6 +23,8 @@ REGION_DECLARE(Image$$, PT_RO_END, $$Base);
 REGION_DECLARE(Image$$, PT_PRIV_RWZI_START, $$Base);
 REGION_DECLARE(Image$$, PT_PRIV_RWZI_END, $$Base);
 
+static uint32_t g_static_region_cnt;
+
 static struct mpu_armv8m_region_cfg_t isolation_regions[] = {
     {
         0, /* will be updated before using */
@@ -55,7 +45,7 @@ static struct mpu_armv8m_region_cfg_t isolation_regions[] = {
         MPU_ARMV8M_SH_NONE,
     },
     /* For isolation Level 3, set up static isolation for privileged data.
-     * Unprivileged data is dynamically set during Partition scheduling.
+     * Unprivileged data is dynamically set during Partition sheduling.
      */
     {
         0, /* will be updated before using */
@@ -84,8 +74,8 @@ REGION_DECLARE(Image$$, TFM_APP_CODE_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_CODE_END, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_END, $$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Base);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
 #ifdef TFM_SP_META_PTR_ENABLE
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Base);
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
@@ -114,17 +104,14 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 
     mpu_armv8m_clean(&dev_mpu_s);
-#if TFM_LVL == 3    
+#if TFM_LVL == 3
+    uint32_t cnt;
     int32_t i;
-    /*
-     * Update MPU region numbers. The numbers start from 0 and are continuous.
-     * Under isolation level3, at lease one MPU region is reserved for private
-     * data asset.
-     */
-    if (ARRAY_SIZE(isolation_regions) >= MPU_REGION_NUM) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-    for (i = 0; i < ARRAY_SIZE(isolation_regions); i++) {
+
+    /* Update MPU region numbers. The numbers start from 0 and are continuous */
+    cnt = sizeof(isolation_regions) / sizeof(isolation_regions[0]);
+    g_static_region_cnt = cnt;
+    for (i = 0; i < cnt; i++) {
         /* Update region number */
         isolation_regions[i].region_nr = i;
         /* Enable regions */
@@ -133,8 +120,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
             return TFM_HAL_ERROR_GENERIC;
         }
     }
-    n_configured_regions = i;
-
 #else /* TFM_LVL == 3 */
     struct mpu_armv8m_region_cfg_t region_cfg;
 
@@ -149,7 +134,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
 #if TARGET_DEBUG_LOG //NXP
     LOG_MSG("=== [MPU Unpriviladged] =======\r\n");
@@ -169,7 +153,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
 #if TARGET_DEBUG_LOG //NXP
     LOG_MSG("Code = [0x%x, 0x%x] \r\n", region_cfg.region_base, region_cfg.region_limit);    
@@ -178,9 +161,9 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     /* NSPM PSP */
     region_cfg.region_nr = MPU_REGION_NS_STACK;
     region_cfg.region_base =
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base);
     region_cfg.region_limit =
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
     region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
     region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
     region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
@@ -188,7 +171,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
 #if TARGET_DEBUG_LOG //NXP
     LOG_MSG("NS STACK = [0x%x, 0x%x] \r\n", region_cfg.region_base, region_cfg.region_limit); 
@@ -207,7 +189,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
 #if TARGET_DEBUG_LOG //NXP
     LOG_MSG("RO APP CODE = [0x%x, 0x%x] \r\n", region_cfg.region_base, region_cfg.region_limit); 
@@ -226,8 +207,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
-
 #if TARGET_DEBUG_LOG //NXP
     LOG_MSG("RW,ZI APP = [0x%x, 0x%x] \r\n", region_cfg.region_base, region_cfg.region_limit); 
     LOG_MSG("===============================\r\n");
@@ -244,7 +223,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
 
 #if TARGET_DEBUG_LOG
     LOG_MSG("NS Data = [0x%x, 0x%x] \r\n", NS_DATA_START, NS_DATA_LIMIT); 
@@ -265,8 +243,6 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    n_configured_regions++;
-
 #endif /* TFM_SP_META_PTR_ENABLE */
 #endif /* TFM_LVL == 3 */
 
@@ -281,202 +257,26 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     return TFM_HAL_SUCCESS;
 }
 
-/*
- * Implementation of tfm_hal_bind_boundaries() on LPCXpresso55s69:
- *
- * The API encodes some attributes into a handle and returns it to SPM.
- * The attributes include isolation boundaries, privilege, and MMIO information.
- * When scheduler switches running partitions, SPM compares the handle between
- * partitions to know if boundary update is necessary. If update is required,
- * SPM passes the handle to platform to do platform settings and update
- * isolation boundaries.
- *
- * The handle should be unique under isolation level 3. The implementation
- * encodes an index at the highest 8 bits to assure handle uniqueness. While
- * under isolation level 1/2, handles may not be unique.
- *
- * The encoding format assignment:
- * - For isolation level 3
- *      BIT | 31        24 | 23         20 | ... | 7           4 | 3        0 |
- *          | Unique Index | Region Attr 5 | ... | Region Attr 1 | Privileged |
- *
- *      In which the "Region Attr i" is:
- *      BIT |       3      | 2        0 |
- *          | 1: RW, 0: RO | MMIO Index |
- *
- * - For isolation level 1/2
- *      BIT | 31                           0 |
- *          | 1: privileged, 0: unprivileged |
- *
- * This is a reference implementation on LPCXpresso55s69, and may have some
- * limitations.
- * 1. The maximum number of allowed MMIO regions is 5.
- * 2. Highest 8 bits are for index. It supports 256 unique handles at most.
- */
-enum tfm_hal_status_t tfm_hal_bind_boundaries(
-                                    const struct partition_load_info_t *p_ldinf,
-                                    void **pp_boundaries)
-{
-    uint32_t i, j;
-    bool privileged;
-    const struct asset_desc_t *p_asset;
-    struct platform_data_t *plat_data_ptr;
-#if TFM_LVL == 2
-    struct mpu_armv8m_region_cfg_t localcfg;
-#elif TFM_LVL == 3
-    uint32_t partition_attrs = 0;
-#endif
-    if (!p_ldinf || !pp_boundaries) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-
-#if TFM_LVL == 1
-    privileged = true;
-#else
-    privileged = !!(p_ldinf->flags & SPM_PART_FLAG_PSA_ROT);
-#endif
-    p_asset = (const struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
-    /*
-     * Validate if the named MMIO of partition is allowed by the platform.
-     * Otherwise, skip validation.
-     *
-     * NOTE: Need to add validation of numbered MMIO if platform requires.
-     */
-    for (i = 0; i < p_ldinf->nassets; i++) {
-        if (!(p_asset[i].attr & ASSET_ATTR_NAMED_MMIO)) {
-            continue;
-        }
-        for (j = 0; j < ARRAY_SIZE(partition_named_mmio_list); j++) {
-            if (p_asset[i].dev.dev_ref == partition_named_mmio_list[j]) {
-                break;
-            }
-        }
-        if (j == ARRAY_SIZE(partition_named_mmio_list)) {
-            /* The MMIO asset is not in the allowed list of platform. */
-            return TFM_HAL_ERROR_GENERIC;
-        }
-        /* Assume PPC & MPC settings are required even under level 1 */
-        plat_data_ptr = REFERENCE_TO_PTR(p_asset[i].dev.dev_ref,
-                                         struct platform_data_t *);
-        ppc_configure_to_secure(plat_data_ptr->periph_ppc_bank,
-                                plat_data_ptr->periph_ppc_loc, privileged);
-#if TFM_LVL == 2
-        /*
-            * Static boundaries are set. Set up MPU region for MMIO.
-            * Setup regions for unprivileged assets only.
-            */
-        if (!privileged) {
-            localcfg.region_base = plat_data_ptr->periph_start;
-            localcfg.region_limit = plat_data_ptr->periph_limit;
-            localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
-            localcfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
-            localcfg.attr_sh = MPU_ARMV8M_SH_NONE;
-            localcfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
-            localcfg.region_nr = n_configured_regions++;
-            if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg)
-                != MPU_ARMV8M_OK) {
-                return TFM_HAL_ERROR_GENERIC;
-            }
-        }
-        #elif TFM_LVL == 3
-        /* Encode MMIO attributes into the "partition_attrs". */
-        partition_attrs <<= HANDLE_PER_ATTR_BITS;
-        partition_attrs |= ((j + 1) & HANDLE_ATTR_INDEX_MASK);
-        if (p_asset[i].attr & ASSET_ATTR_READ_WRITE) {
-            partition_attrs |= HANDLE_ATTR_RW_POS;
-        }
-#endif
-    }
 #if TFM_LVL == 3
-    partition_attrs <<= HANDLE_PER_ATTR_BITS;
-    partition_attrs |= ((uint8_t)privileged) & HANDLE_ATTR_PRIV_MASK;
-    /*
-     * Highest 8 bits are reserved for index, if they are non-zero, MMIO numbers
-     * must have exceeded the limit of 5.
-     */
-    if (partition_attrs & HANDLE_INDEX_MASK) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-    HANDLE_ENCODE_INDEX(partition_attrs, idx_boundary_handle);
-    *pp_boundaries = (void *)partition_attrs;
-#else
-    *pp_boundaries = (void *)(((uint32_t)privileged) & HANDLE_ATTR_PRIV_MASK);
-#endif
-
-    return TFM_HAL_SUCCESS;
-}
-enum tfm_hal_status_t tfm_hal_update_boundaries(
-                             const struct partition_load_info_t *p_ldinf,
-                             void *p_boundaries)
+enum tfm_hal_status_t tfm_hal_mpu_update_partition_boundary(uintptr_t start,
+                                                            uintptr_t end)
 {
-    CONTROL_Type ctrl;
-    uint32_t local_handle = (uint32_t)p_boundaries;
-    bool privileged = !!(local_handle & HANDLE_ATTR_PRIV_MASK);
-#if TFM_LVL == 3
-    struct mpu_armv8m_region_cfg_t localcfg;
-    uint32_t i, mmio_index;
-    struct platform_data_t *plat_data_ptr;
-    struct asset_desc_t *rt_mem;
-#endif
-    /* Privileged level is required to be set always */
-    ctrl.w = __get_CONTROL();
-    ctrl.b.nPRIV = privileged ? 0 : 1;
-    __set_CONTROL(ctrl.w);
-#if TFM_LVL == 3
-    if (!p_ldinf) {
+    struct mpu_armv8m_region_cfg_t cfg;
+    enum mpu_armv8m_error_t mpu_err;
+    struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
+
+    /* Partition boundary regions is right after static regions */
+    cfg.region_nr = g_static_region_cnt;
+    cfg.region_base = start;
+    cfg.region_limit = end;
+    cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
+    cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
+    cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
+    cfg.attr_sh = MPU_ARMV8M_SH_NONE;
+    mpu_err = mpu_armv8m_region_enable(&dev_mpu_s, &cfg);
+    if (mpu_err != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-    /* Update regions, for unprivileged partitions only */
-    if (privileged) {
-        return TFM_HAL_SUCCESS;
-    }
-    /* Setup runtime memory first */
-    localcfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
-    localcfg.attr_sh = MPU_ARMV8M_SH_NONE;
-    localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
-    localcfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
-    rt_mem = (struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
-    /*
-     * NXP shortcut: The first item is the only runtime memory asset.
-     * Platforms with many memory assets please check this part.
-     */
-    for (i = 0;
-         i < p_ldinf->nassets && !(rt_mem[i].attr & ASSET_ATTR_MMIO);
-         i++) {
-        localcfg.region_nr = n_configured_regions + i;
-        localcfg.region_base = rt_mem[i].mem.start;
-        localcfg.region_limit = rt_mem[i].mem.limit;
-        if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg) != MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
-        }
-    }
-    /* Named MMIO part */
-    local_handle = local_handle & (~HANDLE_INDEX_MASK);
-    local_handle >>= HANDLE_PER_ATTR_BITS;
-    mmio_index = local_handle & HANDLE_ATTR_INDEX_MASK;
-    localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
-    i = n_configured_regions + i;
-    while (mmio_index && i < MPU_REGION_NUM) {
-        plat_data_ptr =
-          (struct platform_data_t *)partition_named_mmio_list[mmio_index - 1];
-        localcfg.region_nr = i++;
-        localcfg.attr_access = (local_handle & HANDLE_ATTR_RW_POS)?
-                            MPU_ARMV8M_AP_RW_PRIV_UNPRIV :
-                            MPU_ARMV8M_AP_RO_PRIV_UNPRIV;
-        localcfg.region_base = plat_data_ptr->periph_start;
-        localcfg.region_limit = plat_data_ptr->periph_limit;
-        if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg) != MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
-        }
-        local_handle >>= HANDLE_PER_ATTR_BITS;
-        mmio_index = local_handle & HANDLE_ATTR_INDEX_MASK;
-    }
-    /* Disable unused regions */
-    while (i < MPU_REGION_NUM) {
-        if (mpu_armv8m_region_disable(&dev_mpu_s, i++)!= MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
-        }
-    }
-#endif
     return TFM_HAL_SUCCESS;
 }
+#endif /* TFM_LVL == 3 */
diff --git a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/armgcc/startup_LPC55S69_cm33_core0_s.S b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/armgcc/startup_LPC55S69_cm33_core0_s.S
index 23e3dfaa3..01aa5961a 100755
--- a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/armgcc/startup_LPC55S69_cm33_core0_s.S
+++ b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/armgcc/startup_LPC55S69_cm33_core0_s.S
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2009-2021 Arm Limited
+; * Copyright (c) 2009-2020 Arm Limited
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -26,7 +26,7 @@
     .align 2
     .globl    __Vectors
 __Vectors:
-    .long   Image$$ARM_LIB_STACK$$ZI$$Limit                 /* Top of Stack */
+    .long   Image$$ARM_LIB_STACK_MSP$$ZI$$Limit             /* Top of Stack */
     .long   Reset_Handler                                   /* Reset Handler */
     .long   NMI_Handler                                     /* NMI Handler*/
     .long   HardFault_Handler                               /* Hard Fault Handler*/
@@ -233,6 +233,12 @@ Reset_Handler:
     cpsid   i              /* Disable IRQs */
     bl    SystemInit
 
+    mrs     r0, control    /* Get control value */
+    orr     r0, r0, #2     /* Select switch to PSP */
+    msr     control, r0
+    ldr     r0, =Image$$ARM_LIB_STACK$$ZI$$Limit
+    msr     psp, r0
+
 #ifndef __START
 #define __START _start
 #endif
diff --git a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/iar/startup_LPC55S69_cm33_core0_ns.s b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/iar/startup_LPC55S69_cm33_core0_ns.s
index e546efdb0..2c9f7d5cd 100755
--- a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/iar/startup_LPC55S69_cm33_core0_ns.s
+++ b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/iar/startup_LPC55S69_cm33_core0_ns.s
@@ -133,6 +133,7 @@ Reset_Handler
                 LDR      R0, =sfe(ARM_LIB_STACK)       ; End of ARM_LIB_STACK
                 MSR      PSP, R0
                 MRS      R0, CONTROL    ; Get control value
+                ORR      R0, R0, #1     ; Select switch to non privileged mode
                 ORR      R0, R0, #2     ; Select switch to PSP
                 MSR      CONTROL, R0
                 LDR      R0, =__iar_program_start
diff --git a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/iar/startup_LPC55S69_cm33_core0_s.s b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/iar/startup_LPC55S69_cm33_core0_s.s
index 07d8e6985..a1b77c6cb 100755
--- a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/iar/startup_LPC55S69_cm33_core0_s.s
+++ b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/iar/startup_LPC55S69_cm33_core0_s.s
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2017-2021 ARM Limited
+; * Copyright (c) 2017-2020 ARM Limited
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -29,6 +29,7 @@
                 MODULE   ?cstartup
 
                 ;; Forward declaration of sections.
+                SECTION  ARM_LIB_STACK_MSP:DATA:NOROOT(3)
                 SECTION  ARM_LIB_STACK:DATA:NOROOT(3)
 
                 SECTION  .intvec:CODE:NOROOT(2)
@@ -43,7 +44,7 @@
                 DATA
 
 __vector_table      ;Core Interrupts
-                DCD     sfe(ARM_LIB_STACK)             ; Top of Stack
+                DCD     sfe(ARM_LIB_STACK_MSP)         ; Top of Stack
                 DCD     Reset_Handler                  ; Reset Handler
                 DCD     NMI_Handler                    ; NMI Handler
                 DCD     HardFault_Handler              ; Hard Fault Handler
@@ -134,6 +135,11 @@ Reset_Handler
                 CPSID   i              ; Disable IRQs
                 LDR     R0, =SystemInit
                 BLX     R0
+                LDR     R0, =sfe(ARM_LIB_STACK)      ; End of PROC_STACK
+                MSR     PSP, R0
+                MRS     R0, control    ; Get control value
+                ORR     R0, R0, #2     ; Select switch to PSP
+                MSR     control, R0
                 LDR     R0, =__iar_program_start
                 BX      R0
 End_Of_Main
diff --git a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/README.rst b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/README.rst
index ed78fd987..0cdc3347e 100644
--- a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/README.rst
+++ b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/README.rst
@@ -16,7 +16,7 @@ Or do it manually using the following commands:
 
 .. code:: bash
 
-    $ cmake -S . -B build -DTFM_PLATFORM=nxp/lpcxpresso55s69 -DTFM_TOOLCHAIN_FILE=toolchain_GNUARM.cmake -DTFM_PROFILE=profile_medium -DCMAKE_BUILD_TYPE=Relwithdebinfo -DBL2=OFF -DTFM_ISOLATION_LEVEL=2 -G"Unix Makefiles"
+    $ cmake -S . -B build -DTFM_PLATFORM=nxp/lpcxpresso55s69 -DTFM_TOOLCHAIN_FILE=toolchain_GNUARM.cmake -DTFM_PROFILE=profile_medium -DCMAKE_BUILD_TYPE=Relwithdebinfo -DBL2=OFF -DTFM_PSA_API=ON -DTFM_ISOLATION_LEVEL=2 -G"Unix Makefiles"
     $ cd build && make install
 
 1.2 Building TF-M demo with BL2
@@ -29,7 +29,7 @@ Or do it manually using the following commands:
 
 .. code:: bash
 
-    $ cmake -S . -B build -DTFM_PLATFORM=nxp/lpcxpresso55s69 -DTFM_TOOLCHAIN_FILE=toolchain_GNUARM.cmake -DTFM_PROFILE=profile_medium -DCMAKE_BUILD_TYPE=Relwithdebinfo -DTFM_ISOLATION_LEVEL=2 -G"Unix Makefiles"
+    $ cmake -S . -B build -DTFM_PLATFORM=nxp/lpcxpresso55s69 -DTFM_TOOLCHAIN_FILE=toolchain_GNUARM.cmake -DTFM_PROFILE=profile_medium -DCMAKE_BUILD_TYPE=Relwithdebinfo -DTFM_PSA_API=ON -DTFM_ISOLATION_LEVEL=2 -G"Unix Makefiles"
     $ cd build && make install
 
 1.3 Building TF-M regression tests
@@ -42,7 +42,7 @@ or do it manually using following commands:
 
 .. code:: bash
 
-    $ cmake -S . -B build -DTFM_PLATFORM=nxp/lpcxpresso55s69 -DTFM_TOOLCHAIN_FILE=toolchain_GNUARM.cmake -DTFM_PROFILE=profile_medium -DCMAKE_BUILD_TYPE=Relwithdebinfo -DBL2=OFF -DTEST_S=ON -DTEST_NS=ON -DTFM_ISOLATION_LEVEL=2 -G"Unix Makefiles"
+    $ cmake -S . -B build -DTFM_PLATFORM=nxp/lpcxpresso55s69 -DTFM_TOOLCHAIN_FILE=toolchain_GNUARM.cmake -DTFM_PROFILE=profile_medium -DCMAKE_BUILD_TYPE=Relwithdebinfo -DBL2=OFF -DTEST_S=ON -DTEST_NS=ON -DTFM_PSA_API=ON -DTFM_ISOLATION_LEVEL=2 -G"Unix Makefiles"
     $ cd build && make install
 
 .. Note::
@@ -323,7 +323,7 @@ device (``monitor reset``), and continue (``c``) execution.
 
     Breakpoint 1, main ()
         at [path]/secure_fw/core/tfm_core.c:189
-    189     tfm_arch_init_secure_msp((uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK,
+    189     tfm_arch_init_secure_msp((uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK_MSP,
 
 3.2.4 Commonly used GDB commands
 --------------------------------
@@ -356,5 +356,5 @@ common problems.
 
 *Copyright (c) 2021, NXP Semiconductors. All rights reserved.*
 *Copyright (c) 2020, Linaro. All rights reserved.*
-*Copyright (c) 2020-2021, Arm Limited. All rights reserved.*
+*Copyright (c) 2020, Arm Limited. All rights reserved.*
 *SPDX-License-Identifier: BSD-3-Clause*
\ No newline at end of file
diff --git a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/partition/flash_layout.h b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/partition/flash_layout.h
index 33f40faa9..d2f094404 100755
--- a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/partition/flash_layout.h
@@ -27,8 +27,8 @@
  * 0x0007_0000 Non-secure image secondary slot (96 KB)
  * 0x0008_8000 Protected Storage Area (10 KB)
  * 0x0008_A800 Internal Trusted Storage Area (8 KB)
- * 0x0008_C800 OTP / NV counters area (2 KB)
- * 0x0008_D000 Unused (44 KB)
+ * 0x0008_C800 NV counters area (512 B)
+ * 0x0008_CA00 Unused (45.5 KB)
  *
  * Flash layout on LPC55S69 with BL2 (single image boot):
  *
@@ -37,8 +37,8 @@
  * 0x0004_8000 Secondary image area (Secure + Non-secure images) (256 KB)
  * 0x0008_8000 Protected Storage Area (10 KB)
  * 0x0008_A800 Internal Trusted Storage Area (8 KB)
- * 0x0008_C800 OTP / NV counters area (2 KB)
- * 0x0008_D000 Unused (44 KB)
+ * 0x0008_C800 NV counters area (512 B)
+ * 0x0008_CA00 Unused (45.5 KB)
  *
  * Flash layout on LPC55S69 without BL2:
  *
@@ -49,7 +49,7 @@
  * 0xXXXX_XXXX Secure Binary tail Area (4 KB), if SB is used.
  * 0xXXXX_XXXX Protected Storage Area (3 KB)
  * 0xXXXX_XXXX Internal Trusted Storage Area (3 KB)
- * 0xXXXX_XXXX OTP area (2 KB)
+ * 0xXXXX_XXXX NV counters area (512 B)
  * 0xXXXX_XXXX Unused
  */
 
@@ -174,8 +174,8 @@
 #endif /* BL2 */
 
 /* Note: FLASH_PS_AREA_OFFSET, FLASH_ITS_AREA_OFFSET and
- * FLASH_OTP_NV_COUNTERS_AREA_OFFSET point to offsets in flash, but reads and
- * writes to these addresses are redirected to Code SRAM by Driver_Flash.c.
+ * FLASH_NV_COUNTERS_AREA_OFFSET point to offsets in flash, but reads and writes
+ * to these addresses are redirected to Code SRAM by Driver_Flash.c.
  */
 
 /* Protected Storage (PS) Service definitions */
@@ -188,11 +188,10 @@
                                          FLASH_PS_AREA_SIZE)
 #define FLASH_ITS_AREA_SIZE             (0xC00) /* 3 KB */
 
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 4)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
+/* NV Counters definitions */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_ITS_AREA_OFFSET + \
+                                         FLASH_ITS_AREA_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (FLASH_AREA_IMAGE_SECTOR_SIZE)
 
 /* Offset and size definition in flash area used by assemble.py */
 #define SECURE_IMAGE_OFFSET             (0x0)
@@ -206,8 +205,6 @@
  * Name is defined in flash driver file: Driver_Flash.c
  */
 #define FLASH_DEV_NAME Driver_FLASH0
-/* Smallest flash programmable unit in bytes */
-#define TFM_HAL_FLASH_PROGRAM_UNIT       FLASH_AREA_IMAGE_SECTOR_SIZE
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -255,12 +252,11 @@
 #define ITS_FLASH_NAND_BUF_SIZE        (FLASH_AREA_IMAGE_SECTOR_SIZE * \
                                         TFM_HAL_ITS_SECTORS_PER_BLOCK)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    FLASH_NV_COUNTERS_AREA_SIZE
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
 
 /* Use Flash memory to store Code data */
 #define S_ROM_ALIAS_BASE    (0x10000000)
diff --git a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/partition/region_defs.h b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/partition/region_defs.h
index b0feb6a0f..215858122 100755
--- a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/partition/region_defs.h
+++ b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/partition/region_defs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021 Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
  * Copyright 2019-2020 NXP. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -73,26 +73,14 @@
 #ifdef BL2
 #define BL2_HEADER_SIZE      (0x400)       /* 1 KB */
 #define BL2_TRAILER_SIZE     (0x400)       /* 1 KB */
-#if (MCUBOOT_IMAGE_NUMBER == 1) && \
-    (NS_IMAGE_PRIMARY_PARTITION_OFFSET > S_IMAGE_PRIMARY_PARTITION_OFFSET)
-/* If secure image and nonsecure image are concatenated, and nonsecure image
- * locates at the higher memory range, then the secure image does not need
- * the trailer area.
- */
-#define IMAGE_S_CODE_SIZE \
-            (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE)
-#endif
 #else
 /* No header if no bootloader, but keep IMAGE_CODE_SIZE the same */
 #define BL2_HEADER_SIZE      (0x0)
 #define BL2_TRAILER_SIZE     (0x0)
 #endif /* BL2 */
 
-#ifndef IMAGE_S_CODE_SIZE
 #define IMAGE_S_CODE_SIZE \
             (FLASH_S_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
-#endif
-
 #define IMAGE_NS_CODE_SIZE \
             (FLASH_NS_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
 
diff --git a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/scripts/build_tfm_demo.py b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/scripts/build_tfm_demo.py
index d715ae928..ef29f7ba0 100644
--- a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/scripts/build_tfm_demo.py
+++ b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/scripts/build_tfm_demo.py
@@ -17,7 +17,7 @@ if os.path.isdir("build"):
         os.system('rm -rf build')
 
 # Generate the S and NS makefiles
-os.system('cmake -S . -B build -DTFM_PLATFORM=nxp/lpcxpresso55s69 -DTFM_TOOLCHAIN_FILE=toolchain_GNUARM.cmake -DTFM_PROFILE=profile_medium -DCMAKE_BUILD_TYPE=Relwithdebinfo -DBL2=OFF -DTFM_ISOLATION_LEVEL=2 -G"Unix Makefiles"')
+os.system('cmake -S . -B build -DTFM_PLATFORM=nxp/lpcxpresso55s69 -DTFM_TOOLCHAIN_FILE=toolchain_GNUARM.cmake -DTFM_PROFILE=profile_medium -DCMAKE_BUILD_TYPE=Relwithdebinfo -DBL2=OFF -DTFM_PSA_API=ON -DTFM_ISOLATION_LEVEL=2 -G"Unix Makefiles"')
 
 # Build the binaries
 os.chdir('build')
diff --git a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/scripts/build_tfm_demo_bl2.py b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/scripts/build_tfm_demo_bl2.py
index 5c3f11d82..51b5bc5f6 100644
--- a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/scripts/build_tfm_demo_bl2.py
+++ b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/scripts/build_tfm_demo_bl2.py
@@ -46,7 +46,7 @@ if os.path.isdir("build"):
         os.system('rm -rf build')
 
 # Generate the S and NS makefiles
-os.system('cmake -S . -B build -DBL2_S_IMAGE_START=' + BL2_S_IMAGE_START + ' -DBL2_NS_IMAGE_START=' + BL2_NS_IMAGE_START + ' -DTFM_PLATFORM=nxp/lpcxpresso55s69 -DTFM_TOOLCHAIN_FILE=toolchain_GNUARM.cmake -DTFM_PROFILE=profile_medium -DCMAKE_BUILD_TYPE=Relwithdebinfo -DTFM_ISOLATION_LEVEL=2 -G"Unix Makefiles"')
+os.system('cmake -S . -B build -DBL2_S_IMAGE_START=' + BL2_S_IMAGE_START + ' -DBL2_NS_IMAGE_START=' + BL2_NS_IMAGE_START + ' -DTFM_PLATFORM=nxp/lpcxpresso55s69 -DTFM_TOOLCHAIN_FILE=toolchain_GNUARM.cmake -DTFM_PROFILE=profile_medium -DCMAKE_BUILD_TYPE=Relwithdebinfo -DTFM_PSA_API=ON -DTFM_ISOLATION_LEVEL=2 -G"Unix Makefiles"')
 
 # Build the binaries
 os.chdir('build')
diff --git a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/scripts/build_tfm_regression.py b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/scripts/build_tfm_regression.py
index 7407bf5b2..fc59f8629 100644
--- a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/scripts/build_tfm_regression.py
+++ b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/scripts/build_tfm_regression.py
@@ -17,7 +17,7 @@ if os.path.isdir("build"):
         os.system('rm -rf build')
 
 # Generate the S and NS makefiles
-os.system('cmake -S . -B build -DTFM_PLATFORM=nxp/lpcxpresso55s69 -DTFM_TOOLCHAIN_FILE=toolchain_GNUARM.cmake -DTFM_PROFILE=profile_medium -DCMAKE_BUILD_TYPE=Relwithdebinfo -DBL2=OFF -DTEST_S=ON -DTEST_NS=ON -DTFM_ISOLATION_LEVEL=2 -G"Unix Makefiles"')
+os.system('cmake -S . -B build -DTFM_PLATFORM=nxp/lpcxpresso55s69 -DTFM_TOOLCHAIN_FILE=toolchain_GNUARM.cmake -DTFM_PROFILE=profile_medium -DCMAKE_BUILD_TYPE=Relwithdebinfo -DBL2=OFF -DTEST_S=ON -DTEST_NS=ON -DTFM_PSA_API=ON -DTFM_ISOLATION_LEVEL=2 -G"Unix Makefiles"')
 
 # Build the binaries
 os.chdir('build')
diff --git a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/tfm_peripherals_def.h
index 8b83c4309..402c6c3a0 100755
--- a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/tfm_peripherals_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2019, Arm Limited. All rights reserved.
  * Copyright 2019-2020 NXP. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -31,6 +31,7 @@ extern struct platform_data_t tfm_peripheral_timer0;
 
 #define TFM_PERIPHERAL_STD_UART     (&tfm_peripheral_std_uart)
 #define TFM_PERIPHERAL_TIMER0       (&tfm_peripheral_timer0)
+#define TFM_PERIPHERAL_FPGA_IO      (0)
 
 #ifdef __cplusplus
 }
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/Device/Source/startup_stm32l5xx_s.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/Device/Source/startup_stm32l5xx_s.c
index 59c51904c..9bdea560c 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/Device/Source/startup_stm32l5xx_s.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/Device/Source/startup_stm32l5xx_s.c
@@ -32,11 +32,13 @@ typedef void( *pFunc )( void );
 /*----------------------------------------------------------------------------
   External References
  *----------------------------------------------------------------------------*/
-#define __MSP_INITIAL_SP              REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit)
-#define __MSP_STACK_LIMIT             REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base)
+#define __MSP_INITIAL_SP              REGION_NAME(Image$$, ARM_LIB_STACK_MSP, $$ZI$$Limit)
+#define __MSP_STACK_LIMIT             REGION_NAME(Image$$, ARM_LIB_STACK_MSP, $$ZI$$Base)
 
 extern uint32_t __MSP_INITIAL_SP;
 extern uint32_t __MSP_STACK_LIMIT;
+extern uint32_t __INITIAL_SP;
+extern uint32_t __STACK_LIMIT;
 
 extern void __PROGRAM_START(void) __NO_RETURN;
 
@@ -346,8 +348,17 @@ void Reset_Handler(void)
 {
   __disable_irq();
   __set_MSPLIM((uint32_t)(&__MSP_STACK_LIMIT));
-
+#if defined ( __GNUC__ )
+  __set_MSP((uint32_t)(&__MSP_INITIAL_SP));
+#endif
   SystemInit();   /* CMSIS System Initialization */
-
+  __set_PSP((uint32_t)(&__INITIAL_SP));
+  __set_PSPLIM((uint32_t)(&__STACK_LIMIT));
+  __ASM volatile("MRS     R0, control\n"    /* Get control value */
+                 "ORR     R0, R0, #2\n"     /* Select switch to PSP */
+                 "MSR     control, R0\n"    /* Load control register */
+                 :
+                 :
+                 : "r0");
   __PROGRAM_START();                        /* Enter PreMain (C library entry point) */
 }
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/bl2/boot_hal.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/bl2/boot_hal.c
index 6e928cbb9..96011db45 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/bl2/boot_hal.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/bl2/boot_hal.c
@@ -22,7 +22,6 @@
 #include "boot_hal_cfg.h"
 #include "boot_hal.h"
 #include "uart_stdout.h"
-#include "low_level_rng.h"
 #include "tfm_low_level_security.h"
 #include "target_cfg.h"
 #include "cmsis.h"
@@ -121,7 +120,6 @@ void boot_platform_quit(struct boot_arm_vector_table *vt)
     static struct boot_arm_vector_table *vt_cpy;
 
     vt_cpy=vt;
-    RNG_DeInit();
     /* activate protection before jumping in secure image */
     TFM_LL_SECU_UpdateRunTimeProtections();
 #if defined(__ARM_ARCH_8M_MAIN__) || defined(__ARM_ARCH_8M_BASE__)
@@ -201,11 +199,6 @@ int32_t boot_platform_init(void)
      */
   int result;
   HAL_Init();
-  /* Initialize RNG */
-  if (RNG_Init()){
-      BOOT_LOG_ERR("Error while initializing RNG Ip");
-      Error_Handler();
-  }
 #ifdef CRYPTO_HW_ACCELERATOR
   result = crypto_hw_accelerator_init();
   if (result) {
@@ -322,11 +315,11 @@ void SystemClock_Config(void)
 
 /* Place code in a specific section */
 #if defined(__ICCARM__)
-#pragma default_function_attributes = @ ".BL2_Error_Code"
+#pragma default_function_attributes = @ ".BL2_NoHdp_Code"
 #elif defined(__CC_ARM)
-#pragma arm section code = ".BL2_Error_Code"
+#pragma arm section code = ".BL2_NoHdp_Code"
 #else
-__attribute__((section(".BL2_Error_Code")))
+__attribute__((section(".BL2_NoHdp_Code")))
 #endif /* __ICCARM__ */
 
 /**
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/bl2/low_level_device.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/bl2/low_level_device.c
index c7a6901fe..7acd1b302 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/bl2/low_level_device.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/bl2/low_level_device.c
@@ -8,10 +8,8 @@
   *
   * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
   * All rights reserved.</center></h2>
-  * <h2><center>&copy; Copyright (c) 2021 Arm Limited.
-  * All rights reserved.</center></h2>
   *
-  * This software component is licensed under BSD 3-Clause license,
+  * This software component is licensed by ST under BSD 3-Clause license,
   * the "License"; You may not use this file except in compliance with the
   * License. You may obtain a copy of the License at:
   *                        opensource.org/licenses/BSD-3-Clause
@@ -22,7 +20,7 @@
 #include "low_level_flash.h"
 static struct flash_range erase_vect[] =
 {
-  {FLASH_OTP_NV_COUNTERS_AREA_OFFSET, FLASH_OTP_NV_COUNTERS_AREA_OFFSET + FLASH_OTP_NV_COUNTERS_AREA_SIZE - 1},
+  {FLASH_NV_COUNTERS_AREA_OFFSET, FLASH_NV_COUNTERS_AREA_OFFSET + FLASH_NV_COUNTERS_SECTOR_SIZE - 1},
   {FLASH_AREA_SCRATCH_OFFSET, FLASH_AREA_SCRATCH_OFFSET + FLASH_AREA_SCRATCH_SIZE - 1},
 #if defined(EXTERNAL_FLASH)
   {FLASH_AREA_0_OFFSET, FLASH_AREA_1_OFFSET + FLASH_AREA_1_SIZE - 1}
@@ -32,7 +30,7 @@ static struct flash_range erase_vect[] =
 };
 static struct flash_range write_vect[] =
 {
-  { FLASH_OTP_NV_COUNTERS_AREA_OFFSET, FLASH_OTP_NV_COUNTERS_AREA_OFFSET + FLASH_OTP_NV_COUNTERS_AREA_SIZE - 1},
+  { FLASH_NV_COUNTERS_AREA_OFFSET, FLASH_NV_COUNTERS_AREA_OFFSET + FLASH_NV_COUNTERS_SECTOR_SIZE - 1},
   { FLASH_AREA_SCRATCH_OFFSET, FLASH_AREA_SCRATCH_OFFSET + FLASH_AREA_SCRATCH_SIZE - 1},
 #if defined(EXTERNAL_FLASH)
   {FLASH_AREA_0_OFFSET, FLASH_AREA_1_OFFSET + FLASH_AREA_1_SIZE - 1}
@@ -43,7 +41,7 @@ static struct flash_range write_vect[] =
 
 static struct flash_range secure_vect[] =
 {
-  { FLASH_OTP_NV_COUNTERS_AREA_OFFSET, FLASH_OTP_NV_COUNTERS_AREA_OFFSET + FLASH_OTP_NV_COUNTERS_AREA_SIZE - 1},
+  { FLASH_NV_COUNTERS_AREA_OFFSET, FLASH_NV_COUNTERS_AREA_OFFSET + FLASH_NV_COUNTERS_SECTOR_SIZE - 1},
   { FLASH_AREA_SCRATCH_OFFSET, FLASH_AREA_SCRATCH_OFFSET + FLASH_AREA_SCRATCH_SIZE - 1},
   { FLASH_AREA_0_OFFSET, FLASH_AREA_0_OFFSET + FLASH_AREA_0_SIZE - 1}
 };
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/boards/tfm_peripherals_def.h b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/boards/tfm_peripherals_def.h
index f525f52fb..28ffc086b 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/boards/tfm_peripherals_def.h
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/boards/tfm_peripherals_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -14,5 +14,6 @@ struct platform_data_t;
 
 #define TFM_PERIPHERAL_STD_UART     (0)
 #define TFM_PERIPHERAL_TIMER0       (0)
+#define TFM_PERIPHERAL_FPGA_IO      (0)
 
 #endif /* __TFM_PERIPHERALS_DEF_H__ */
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/low_level_device.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/low_level_device.c
index 0cf4243b3..83c9dc435 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/low_level_device.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/low_level_device.c
@@ -8,10 +8,8 @@
   *
   * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
   * All rights reserved.</center></h2>
-  * <h2><center>&copy; Copyright (c) 2021 Arm Limited.
-  * All rights reserved.</center></h2>
   *
-  * This software component is licensed under BSD 3-Clause license,
+  * This software component is licensed by ST under BSD 3-Clause license,
   * the "License"; You may not use this file except in compliance with the
   * License. You may obtain a copy of the License at:
   *                        opensource.org/licenses/BSD-3-Clause
@@ -23,7 +21,7 @@
 #include "low_level_flash.h"
 
 struct flash_range nvm_psa_its_vect[] = {
-	{ FLASH_OTP_NV_COUNTERS_AREA_OFFSET, FLASH_ITS_AREA_OFFSET + FLASH_ITS_AREA_SIZE - 1},
+	{ FLASH_NV_COUNTERS_AREA_OFFSET, FLASH_ITS_AREA_OFFSET + FLASH_ITS_AREA_SIZE - 1},
 };
 
 struct low_level_device FLASH0_DEV =  {
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/spm_hal.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/spm_hal.c
index 8ba64b0a4..42af56ee7 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/spm_hal.c
@@ -5,16 +5,27 @@
  *
  */
 
+#include <stdio.h>
 #include "tfm_spm_hal.h"
 #include "tfm_platform_core_api.h"
 #include "target_cfg.h"
 #include "Driver_MPC.h"
+#include "mpu_armv8m_drv.h"
+#include "region_defs.h"
 #include "utilities.h"
 #include "region.h"
 
 /* Get address of memory regions to configure MPU */
 extern const struct memory_region_limits memory_regions;
 
+enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
+                  bool privileged,
+                  const struct platform_data_t *platform_data)
+{
+    /* plat data are ignored */
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
 uint32_t tfm_spm_hal_get_ns_VTOR(void)
 {
     return memory_regions.non_secure_code_start;
@@ -95,15 +106,3 @@ enum tfm_plat_err_t tfm_spm_hal_nvic_interrupt_enable(void)
 /*    return nvic_interrupt_enable();*/
     return TFM_PLAT_ERR_SUCCESS;
 }
-
-#ifndef TFM_PSA_API
-
-enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
-                  bool privileged,
-                  const struct platform_data_t *platform_data)
-{
-    /* plat data are ignored */
-    return TFM_PLAT_ERR_SUCCESS;
-}
-
-#endif /* TFM_PSA_API */
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/tfm_hal_isolation.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/tfm_hal_isolation.c
index cfaf05f09..c011cf3b4 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/tfm_hal_isolation.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/tfm_hal_isolation.c
@@ -5,28 +5,15 @@
  *
  */
 
-#include "array.h"
 #include "cmsis.h"
 #include "Driver_Common.h"
-#include "mmio_defs.h"
 #include "mpu_armv8m_drv.h"
 #include "region.h"
 #include "target_cfg.h"
 #include "tfm_hal_isolation.h"
 #include "tfm_plat_defs.h"
-#include "tfm_peripherals_def.h"
-#include "tfm_core_utils.h"
-#include "load/partition_defs.h"
-#include "load/asset_defs.h"
-#include "load/spm_load_api.h"
-#include "low_level_rng.h"
-/* It can be retrieved from the MPU_TYPE register. */
-#define MPU_REGION_NUM                  8
 #ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
-static uint32_t n_configured_regions = 0;
-struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 #if TFM_LVL == 3
-static uint32_t idx_boundary_handle = 0;
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Base);
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Limit);
 REGION_DECLARE(Image$$, PT_RO_START, $$Base);
@@ -34,7 +21,9 @@ REGION_DECLARE(Image$$, PT_RO_END, $$Base);
 REGION_DECLARE(Image$$, PT_PRIV_RWZI_START, $$Base);
 REGION_DECLARE(Image$$, PT_PRIV_RWZI_END, $$Base);
 
-const static struct mpu_armv8m_region_cfg_t isolation_regions[] = {
+static uint32_t g_static_region_cnt;
+
+static struct mpu_armv8m_region_cfg_t isolation_regions[] = {
     {
         0, /* will be updated before using */
         (uint32_t)&REGION_NAME(Load$$LR$$, LR_VENEER, $$Base),
@@ -54,7 +43,7 @@ const static struct mpu_armv8m_region_cfg_t isolation_regions[] = {
         MPU_ARMV8M_SH_NONE,
     },
     /* For isolation Level 3, set up static isolation for privileged data.
-     * Unprivileged data is dynamically set during Partition scheduling.
+     * Unprivileged data is dynamically set during Partition sheduling.
      */
     {
         0, /* will be updated before using */
@@ -67,6 +56,16 @@ const static struct mpu_armv8m_region_cfg_t isolation_regions[] = {
     },
 };
 #else /* TFM_LVL == 3 */
+#define ARRAY_SIZE(arr) (sizeof(arr)/sizeof(arr[0]))
+
+#define MPU_REGION_VENEERS              0
+#define MPU_REGION_TFM_UNPRIV_CODE      1
+#define MPU_REGION_NS_STACK             2
+#define PARTITION_REGION_RO             3
+#define PARTITION_REGION_RW_STACK       4
+#ifdef TFM_SP_META_PTR_ENABLE
+#define MPU_REGION_SP_META_PTR          7
+#endif /* TFM_SP_META_PTR_ENABLE */
 
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Base);
 REGION_DECLARE(Load$$LR$$, LR_VENEER, $$Limit);
@@ -76,8 +75,8 @@ REGION_DECLARE(Image$$, TFM_APP_CODE_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_CODE_END, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_START, $$Base);
 REGION_DECLARE(Image$$, TFM_APP_RW_STACK_END, $$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
-REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Limit);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Base);
+REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
 #ifdef TFM_SP_META_PTR_ENABLE
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Base);
 REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
@@ -86,7 +85,7 @@ REGION_DECLARE(Image$$, TFM_SP_META_PTR, $$RW$$Limit);
 const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     /* Veneer region */
     {
-        0, /* will be updated before using */
+        MPU_REGION_VENEERS,
         (uint32_t)&REGION_NAME(Load$$LR$$, LR_VENEER, $$Base),
         (uint32_t)&REGION_NAME(Load$$LR$$, LR_VENEER, $$Limit),
         MPU_ARMV8M_MAIR_ATTR_CODE_IDX,
@@ -96,7 +95,7 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     },
     /* TFM Core unprivileged code region */
     {
-        0, /* will be updated before using */
+        MPU_REGION_TFM_UNPRIV_CODE,
         (uint32_t)&REGION_NAME(Image$$, TFM_UNPRIV_CODE, $$RO$$Base),
         (uint32_t)&REGION_NAME(Image$$, TFM_UNPRIV_CODE, $$RO$$Limit),
         MPU_ARMV8M_MAIR_ATTR_CODE_IDX,
@@ -106,9 +105,9 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     },
     /* NSPM PSP */
     {
-        0, /* will be updated before using */
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Base),
-        (uint32_t)&REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Limit),
+        MPU_REGION_NS_STACK,
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base),
+        (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit),
         MPU_ARMV8M_MAIR_ATTR_DATA_IDX,
         MPU_ARMV8M_XN_EXEC_NEVER,
         MPU_ARMV8M_AP_RW_PRIV_UNPRIV,
@@ -116,7 +115,7 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     },
     /* RO region */
     {
-        0, /* will be updated before using */
+        PARTITION_REGION_RO,
         (uint32_t)&REGION_NAME(Image$$, TFM_APP_CODE_START, $$Base),
         (uint32_t)&REGION_NAME(Image$$, TFM_APP_CODE_END, $$Base),
         MPU_ARMV8M_MAIR_ATTR_CODE_IDX,
@@ -126,7 +125,7 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
     },
     /* RW, ZI and stack as one region */
     {
-        0, /* will be updated before using */
+        PARTITION_REGION_RW_STACK,
         (uint32_t)&REGION_NAME(Image$$, TFM_APP_RW_STACK_START, $$Base),
         (uint32_t)&REGION_NAME(Image$$, TFM_APP_RW_STACK_END, $$Base),
         MPU_ARMV8M_MAIR_ATTR_DATA_IDX,
@@ -137,7 +136,7 @@ const struct mpu_armv8m_region_cfg_t region_cfg[] = {
 #ifdef TFM_SP_META_PTR_ENABLE
     /* TFM partition metadata pointer region */
     {
-        0, /* will be updated before using */
+        MPU_REGION_SP_META_PTR,
         (uint32_t)&REGION_NAME(Image$$, TFM_SP_META_PTR, $$RW$$Base),
         (uint32_t)&REGION_NAME(Image$$, TFM_SP_META_PTR, $$RW$$Limit),
         MPU_ARMV8M_MAIR_ATTR_DATA_IDX,
@@ -156,50 +155,37 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     gtzc_init_cfg();
     sau_and_idau_cfg();
     pinmux_init_cfg();
-    /* Start HW randomization */
-    if (RNG_Init()) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
+
     /* Set up static isolation boundaries inside SPE */
 #ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
-    struct mpu_armv8m_region_cfg_t localcfg;
     int32_t i;
+    struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 
     mpu_armv8m_clean(&dev_mpu_s);
 
 #if TFM_LVL == 3
-    /*
-     * Update MPU region numbers. The numbers start from 0 and are continuous.
-     * Under isolation level 3, at lease one MPU region is reserved for private
-     * data asset.
-     */
-    if (ARRAY_SIZE(isolation_regions) >= MPU_REGION_NUM) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-    for (i = 0; i < ARRAY_SIZE(isolation_regions); i++) {
-        spm_memcpy(&localcfg, &isolation_regions[i], sizeof(localcfg));
+    uint32_t cnt;
+
+    /* Update MPU region numbers. The numbers start from 0 and are continuous */
+    cnt = sizeof(isolation_regions) / sizeof(isolation_regions[0]);
+    g_static_region_cnt = cnt;
+    for (i = 0; i < cnt; i++) {
         /* Update region number */
-        localcfg.region_nr = i;
+        isolation_regions[i].region_nr = i;
         /* Enable regions */
-        if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg) != MPU_ARMV8M_OK) {
+        if (mpu_armv8m_region_enable(&dev_mpu_s, &isolation_regions[i])
+                                                             != MPU_ARMV8M_OK) {
             return TFM_HAL_ERROR_GENERIC;
         }
-    n_configured_regions = i;
     }
 #else /* TFM_LVL == 3 */
-    if (ARRAY_SIZE(region_cfg) > MPU_REGION_NUM) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
     for (i = 0; i < ARRAY_SIZE(region_cfg); i++) {
-        spm_memcpy(&localcfg, &region_cfg[i], sizeof(localcfg));
-        localcfg.region_nr = i;
         if (mpu_armv8m_region_enable(&dev_mpu_s,
-            (struct mpu_armv8m_region_cfg_t *)&localcfg)
+            (struct mpu_armv8m_region_cfg_t *)&region_cfg[i])
             != MPU_ARMV8M_OK) {
             return TFM_HAL_ERROR_GENERIC;
         }
     }
-    n_configured_regions = i;
 #endif /* TFM_LVL == 3 */
 
     /* Enable MPU */
@@ -213,218 +199,26 @@ enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
     return TFM_HAL_SUCCESS;
 }
 
-/*
- * Implementation of tfm_hal_bind_boundaries() on STM:
- *
- * The API encodes some attributes into a handle and returns it to SPM.
- * The attributes include isolation boundaries, privilege, and MMIO information.
- * When scheduler switches running partitions, SPM compares the handle between
- * partitions to know if boundary update is necessary. If update is required,
- * SPM passes the handle to platform to do platform settings and update
- * isolation boundaries.
- *
- * The handle should be unique under isolation level 3. The implementation
- * encodes an index at the highest 8 bits to assure handle uniqueness. While
- * under isolation level 1/2, handles may not be unique.
- *
- * The encoding format assignment:
- * - For isolation level 3
- *      BIT | 31        24 | 23         20 | ... | 7           4 | 3        0 |
- *          | Unique Index | Region Attr 5 | ... | Region Attr 1 | Privileged |
- *
- *      In which the "Region Attr i" is:
- *      BIT |       3      | 2        0 |
- *          | 1: RW, 0: RO | MMIO Index |
- *
- * - For isolation level 1/2
- *      BIT | 31                           0 |
- *          | 1: privileged, 0: unprivileged |
- *
- * This is a reference implementation on STM, and may have some limitations.
- * 1. The maximum number of allowed MMIO regions is 5.
- * 2. Highest 8 bits are for index. It supports 256 unique handles at most.
- */
-
-enum tfm_hal_status_t tfm_hal_bind_boundaries(
-
-                                    const struct partition_load_info_t *p_ldinf,
-                                    void **pp_boundaries)
-{
-    uint32_t i, j;
-    bool privileged;
-    const struct asset_desc_t *p_asset;
-#if TFM_LVL == 2
-    struct platform_data_t *plat_data_ptr;
-    struct mpu_armv8m_region_cfg_t localcfg;
-#elif TFM_LVL == 3
-    uint32_t partition_attrs = 0;
-#endif
-
-    if (!p_ldinf || !pp_boundaries) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-
-#if TFM_LVL == 1
-    privileged = true;
-#else
-    privileged = !!(p_ldinf->flags & SPM_PART_FLAG_PSA_ROT);
-#endif
-
-    p_asset = (const struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
-
-    /*
-     * Validate if the named MMIO of partition is allowed by the platform.
-     * Otherwise, skip validation.
-     *
-     * NOTE: Need to add validation of numbered MMIO if platform requires.
-     */
-    for (i = 0; i < p_ldinf->nassets; i++) {
-        if (!(p_asset[i].attr & ASSET_ATTR_NAMED_MMIO)) {
-            continue;
-        }
-        for (j = 0; j < ARRAY_SIZE(partition_named_mmio_list); j++) {
-            if (p_asset[i].dev.dev_ref == partition_named_mmio_list[j]) {
-                break;
-            }
-        }
-
-        if (j == ARRAY_SIZE(partition_named_mmio_list)) {
-            /* The MMIO asset is not in the allowed list of platform. */
-            return TFM_HAL_ERROR_GENERIC;
-        }
-#if TFM_LVL == 2
-        plat_data_ptr = REFERENCE_TO_PTR(p_asset[i].dev.dev_ref,
-                                         struct platform_data_t *);
-        /*
-         * Static boundaries are set. Set up MPU region for MMIO.
-         * Setup regions for unprivileged assets only.
-         */
-        if (!privileged) {
-            localcfg.region_base = plat_data_ptr->periph_start;
-            localcfg.region_limit = plat_data_ptr->periph_limit;
-            localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
-            localcfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
-            localcfg.attr_sh = MPU_ARMV8M_SH_NONE;
-            localcfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
-            localcfg.region_nr = n_configured_regions++;
-
-            if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg)
-                != MPU_ARMV8M_OK) {
-                return TFM_HAL_ERROR_GENERIC;
-            }
-        }
-#elif TFM_LVL == 3
-        /* Encode MMIO attributes into the "partition_attrs". */
-        partition_attrs <<= HANDLE_PER_ATTR_BITS;
-        partition_attrs |= ((j + 1) & HANDLE_ATTR_INDEX_MASK);
-        if (p_asset[i].attr & ASSET_ATTR_READ_WRITE) {
-            partition_attrs |= HANDLE_ATTR_RW_POS;
-        }
-#endif
-    }
-
 #if TFM_LVL == 3
-    partition_attrs <<= HANDLE_PER_ATTR_BITS;
-    partition_attrs |= ((uint8_t)privileged) & HANDLE_ATTR_PRIV_MASK;
-    /*
-     * Highest 8 bits are reserved for index, if they are non-zero, MMIO numbers
-     * must have exceeded the limit of 5.
-     */
-    if (partition_attrs & HANDLE_INDEX_MASK) {
-        return TFM_HAL_ERROR_GENERIC;
-    }
-    HANDLE_ENCODE_INDEX(partition_attrs, idx_boundary_handle);
-    *pp_boundaries = (void *)partition_attrs;
-#else
-    *pp_boundaries = (void *)(((uint32_t)privileged) & HANDLE_ATTR_PRIV_MASK);
-#endif
-
-    return TFM_HAL_SUCCESS;
-}
-
-enum tfm_hal_status_t tfm_hal_update_boundaries(
-                             const struct partition_load_info_t *p_ldinf,
-                             void *p_boundaries)
+enum tfm_hal_status_t tfm_hal_mpu_update_partition_boundary(uintptr_t start,
+                                                            uintptr_t end)
 {
-    CONTROL_Type ctrl;
-    uint32_t local_handle = (uint32_t)p_boundaries;
-    bool privileged = !!(local_handle & HANDLE_ATTR_PRIV_MASK);
-#if TFM_LVL == 3
-    struct mpu_armv8m_region_cfg_t localcfg;
-    uint32_t i, mmio_index;
-    struct platform_data_t *plat_data_ptr;
-    struct asset_desc_t *rt_mem;
-#endif
-
-    /* Privileged level is required to be set always */
-    ctrl.w = __get_CONTROL();
-    ctrl.b.nPRIV = privileged ? 0 : 1;
-    __set_CONTROL(ctrl.w);
-
-#if TFM_LVL == 3
-    if (!p_ldinf) {
+    struct mpu_armv8m_region_cfg_t cfg;
+    enum mpu_armv8m_error_t mpu_err;
+    struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
+
+    /* Partition boundary regions is right after static regions */
+    cfg.region_nr = g_static_region_cnt;
+    cfg.region_base = start;
+    cfg.region_limit = end;
+    cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
+    cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
+    cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
+    cfg.attr_sh = MPU_ARMV8M_SH_NONE;
+    mpu_err = mpu_armv8m_region_enable(&dev_mpu_s, &cfg);
+    if (mpu_err != MPU_ARMV8M_OK) {
         return TFM_HAL_ERROR_GENERIC;
     }
-
-    /* Update regions, for unprivileged partitions only */
-    if (privileged) {
-        return TFM_HAL_SUCCESS;
-    }
-
-    /* Setup runtime memory first */
-    localcfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
-    localcfg.attr_sh = MPU_ARMV8M_SH_NONE;
-    localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
-    localcfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
-    rt_mem = (struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
-    /*
-     * STM shortcut: The first item is the only runtime memory asset.
-     * Platforms with many memory assets please check this part.
-     */
-    for (i = 0;
-         i < p_ldinf->nassets && !(rt_mem[i].attr & ASSET_ATTR_MMIO);
-         i++) {
-        localcfg.region_nr = n_configured_regions + i;
-        localcfg.region_base = rt_mem[i].mem.start;
-        localcfg.region_limit = rt_mem[i].mem.limit;
-
-        if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg) != MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
-        }
-    }
-
-    /* Named MMIO part */
-    local_handle = local_handle & (~HANDLE_INDEX_MASK);
-    local_handle >>= HANDLE_PER_ATTR_BITS;
-    mmio_index = local_handle & HANDLE_ATTR_INDEX_MASK;
-
-    localcfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
-
-    i = n_configured_regions + i;
-    while (mmio_index && i < MPU_REGION_NUM) {
-        plat_data_ptr =
-          (struct platform_data_t *)partition_named_mmio_list[mmio_index - 1];
-        localcfg.region_nr = i++;
-        localcfg.attr_access = (local_handle & HANDLE_ATTR_RW_POS)?
-                            MPU_ARMV8M_AP_RW_PRIV_UNPRIV :
-                            MPU_ARMV8M_AP_RO_PRIV_UNPRIV;
-        localcfg.region_base = plat_data_ptr->periph_start;
-        localcfg.region_limit = plat_data_ptr->periph_limit;
-
-        if (mpu_armv8m_region_enable(&dev_mpu_s, &localcfg) != MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
-        }
-
-        local_handle >>= HANDLE_PER_ATTR_BITS;
-        mmio_index = local_handle & HANDLE_ATTR_INDEX_MASK;
-    }
-
-    /* Disable unused regions */
-    while (i < MPU_REGION_NUM) {
-        if (mpu_armv8m_region_disable(&dev_mpu_s, i++)!= MPU_ARMV8M_OK) {
-            return TFM_HAL_ERROR_GENERIC;
-        }
-    }
-#endif
     return TFM_HAL_SUCCESS;
 }
+#endif /* TFM_LVL == 3 */
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/tfm_platform_system.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/tfm_platform_system.c
index ae517fdfa..c3615f8fd 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/tfm_platform_system.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/tfm_platform_system.c
@@ -5,6 +5,7 @@
  *
  */
 
+
 #include "target_cfg.h"
 #include "tfm_spm_hal.h"
 #include "uart_stdout.h"
diff --git a/lib/tf-m/platform/ext/target/stm/index.rst b/lib/tf-m/platform/ext/target/stm/index.rst
index cb1c853b5..b974c9a5a 100644
--- a/lib/tf-m/platform/ext/target/stm/index.rst
+++ b/lib/tf-m/platform/ext/target/stm/index.rst
@@ -18,7 +18,6 @@ This document contains SOC and boards supported by stm32.
 
     nucleo*/**
     stm32*/**
-    b_*/**
 
 --------------
 
diff --git a/lib/tf-m/platform/ext/target/stm/nucleo_l552ze_q/image_macros_to_preprocess_bl2.c b/lib/tf-m/platform/ext/target/stm/nucleo_l552ze_q/image_macros_to_preprocess_bl2.c
index 0ed8b3ebe..046fe85c3 100644
--- a/lib/tf-m/platform/ext/target/stm/nucleo_l552ze_q/image_macros_to_preprocess_bl2.c
+++ b/lib/tf-m/platform/ext/target/stm/nucleo_l552ze_q/image_macros_to_preprocess_bl2.c
@@ -13,7 +13,7 @@ enum bl2_image_attributes {
 	RE_IMAGE_FLASH_NON_SECURE_UPDATE = (FLASH_BASE_ADDRESS+FLASH_AREA_3_OFFSET),
 	RE_IMAGE_FLASH_UNUSED = (FLASH_BASE_ADDRESS+FLASH_AREA_3_OFFSET+FLASH_AREA_3_SIZE),
 	RE_IMAGE_FLASH_SCRATCH = (FLASH_BASE_ADDRESS+FLASH_AREA_SCRATCH_OFFSET),
-	RE_IMAGE_FLASH_NV_COUNTERS = (FLASH_BASE_ADDRESS+FLASH_OTP_NV_COUNTERS_AREA_OFFSET),
+	RE_IMAGE_FLASH_NV_COUNTERS = (FLASH_BASE_ADDRESS+FLASH_NV_COUNTERS_AREA_OFFSET),
 	RE_IMAGE_FLASH_NV_PS = (FLASH_BASE_ADDRESS+FLASH_PS_AREA_OFFSET),
 	RE_IMAGE_FLASH_NV_ITS = (FLASH_BASE_ADDRESS+FLASH_ITS_AREA_OFFSET)
-}
+}
\ No newline at end of file
diff --git a/lib/tf-m/platform/ext/target/stm/nucleo_l552ze_q/include/flash_layout.h b/lib/tf-m/platform/ext/target/stm/nucleo_l552ze_q/include/flash_layout.h
index b2a605143..705e230ff 100644
--- a/lib/tf-m/platform/ext/target/stm/nucleo_l552ze_q/include/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/stm/nucleo_l552ze_q/include/flash_layout.h
@@ -27,23 +27,24 @@
  * Flash layout on nucleo_l552ze_q with BL2 (multiple image boot):
  *
  * 0x0000_0000 BL2 - MCUBoot (72 KB)
- * 0x0000_e000 OTP / NV counters area (8 KB)
- * 0x0001_0000 Secure Storage Area (8 KB)
- * 0x0001_2000 Internal Trusted Storage Area (8 KB)
- * 0x0001_4000 Secure image     primary slot (180 KB)
- * 0x0004_1000 Non-secure image primary slot (36 KB)
- * 0x0004_a000 Secure image     secondary slot (180 KB)
- * 0x0007_7000 Non-secure image secondary slot (36 KB)
+ * 0x0000_e000 NV counters area (4 KB)
+ * 0x0000_f000 Secure Storage Area (8 KB)
+ * 0x0001_1000 Internal Trusted Storage Area (8 KB)
+ * 0x0001_3000 Secure image     primary slot (180 KB)
+ * 0x0004_0000 Non-secure image primary slot (36 KB)
+ * 0x0004_9000 Secure image     secondary slot (180 KB)
+ * 0x0007_6000 Non-secure image secondary slot (36 KB)
+ * 0x0007_F000 Unused (4 KB)
  *
  * Flash layout on nucleo_l552ze_q with BL2 (multiple image boot, layout for test):
  * No Firmware update , ITS, PS in RAM.
  * 0x0000_0000 BL2 - MCUBoot (72 KB)
- * 0x0000_e000 OTP / NV counters area  area (8 KB)
- * 0x0001_0000 Secure Storage Area (8 KB)
- * 0x0001_2000 Internal Trusted Storage Area (8 KB)
- * 0x0001_4000 Secure image     primary slot (224 KB)
- * 0x0004_c000 Non-secure image primary slot (172 KB)
- * 0x0007_7000 Unused (40K)
+ * 0x0000_e000 NV counters area (4 KB)
+ * 0x0000_f000 Secure Storage Area (8 KB)
+ * 0x0001_1000 Internal Trusted Storage Area (8 KB)
+ * 0x0001_3000 Secure image     primary slot (224 KB)
+ * 0x0004_b000 Non-secure image primary slot (168 KB)
+ * 0x0007_5000 Unused (44K)
  * The size of a partition. This should be large enough to contain a S or NS
  * sw binary. Each FLASH_AREA_IMAGE contains two partitions. See Flash layout
  * above.
@@ -75,20 +76,16 @@
 #define FLASH_AREA_SCRATCH_OFFSET       (FLASH_AREA_BL2_NOHDP_OFFSET+FLASH_AREA_BL2_NOHDP_SIZE)
 #define FLASH_AREA_SCRATCH_SIZE         (0x2000)
 /* according to test flash layout can change */
-#if defined(FLASH_LAYOUT_FOR_TEST)
-
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_SECTOR_SIZE + \
-                                           FLASH_OTP_NV_COUNTERS_SECTOR_SIZE)
+#if defined(FLASH_LAYOUT_FOR_TEST) || defined(TEST_FRAMEWORK_S) || defined(TEST_FRAMEWORK_NS)
+/* Non Volatile Counters definitions */
+#define FLASH_NV_COUNTERS_SECTOR_SIZE      (0x1000)
+/* fix me with overwrite scratch is not required */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_AREA_SCRATCH_OFFSET)
 
 /* fix me with test config PS and ITS in RAM */
 /* Secure Storage (PS) Service definitions */
 #define FLASH_PS_AREA_SIZE             (0x2000)
-#define FLASH_PS_AREA_OFFSET           (FLASH_OTP_NV_COUNTERS_AREA_OFFSET + \
-                                        FLASH_OTP_NV_COUNTERS_AREA_SIZE)
+#define FLASH_PS_AREA_OFFSET           (FLASH_NV_COUNTERS_AREA_OFFSET+FLASH_NV_COUNTERS_SECTOR_SIZE)
 
 /* Internal Trusted Storage (ITS) Service definitions */
 #define FLASH_ITS_AREA_OFFSET           (FLASH_PS_AREA_OFFSET+FLASH_PS_AREA_SIZE)
@@ -102,17 +99,15 @@
 #define FLASH_AREA_0_OFFSET             (FLASH_ITS_AREA_OFFSET+FLASH_ITS_AREA_SIZE)
 #define FLASH_AREA_0_SIZE               (FLASH_S_PARTITION_SIZE)
 #else
-
-/* OTP_definitions */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET (FLASH_ITS_AREA_OFFSET + \
-                                           FLASH_ITS_AREA_SIZE)
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_AREA_IMAGE_SECTOR_SIZE
+/* Non Volatile Counters definitions */
+#define FLASH_NV_COUNTERS_SECTOR_SIZE      (0x1000)
+/* fix me with overwrite scratch is not required */
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_AREA_SCRATCH_OFFSET)
 
 /* fix me with test config PS and ITS in RAM */
 /* Secure Storage (PS) Service definitions */
 #define FLASH_PS_AREA_SIZE             (0x2000)
-#define FLASH_PS_AREA_OFFSET           (FLASH_OTP_NV_COUNTERS_AREA_OFFSET + \
-                                        FLASH_OTP_NV_COUNTERS_AREA_SIZE)
+#define FLASH_PS_AREA_OFFSET           (FLASH_NV_COUNTERS_AREA_OFFSET+FLASH_NV_COUNTERS_SECTOR_SIZE)
 
 /* Internal Trusted Storage (ITS) Service definitions */
 #define FLASH_ITS_AREA_OFFSET           (FLASH_PS_AREA_OFFSET+FLASH_PS_AREA_SIZE)
@@ -150,7 +145,7 @@
 #define MCUBOOT_MAX_IMG_SECTORS           ((2 * FLASH_PARTITION_SIZE) / \
                                          FLASH_AREA_IMAGE_SECTOR_SIZE)
 
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_AREA_IMAGE_SECTOR_SIZE * 2)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (0x18)     /* 16 Bytes */
 
 #define SECURE_IMAGE_OFFSET             (0x0)
 #define SECURE_IMAGE_MAX_SIZE           FLASH_S_PARTITION_SIZE
@@ -163,7 +158,6 @@
   */
 
 #define FLASH_DEV_NAME TFM_Driver_FLASH0
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x8)
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -203,12 +197,15 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x8)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18)/* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
+
+/* BL2 NV Counters definitions  */
+#define BL2_NV_COUNTERS_AREA_ADDR    FLASH_BL2_NVCNT_AREA_OFFSET
+#define BL2_NV_COUNTERS_AREA_SIZE    FLASH_BL2_NVCNT_AREA_SIZE
 
 #define BL2_S_RAM_ALIAS_BASE  (0x30000000)
 #define BL2_NS_RAM_ALIAS_BASE (0x20000000)
diff --git a/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/image_macros_to_preprocess_bl2.c b/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/image_macros_to_preprocess_bl2.c
index 0ed8b3ebe..046fe85c3 100644
--- a/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/image_macros_to_preprocess_bl2.c
+++ b/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/image_macros_to_preprocess_bl2.c
@@ -13,7 +13,7 @@ enum bl2_image_attributes {
 	RE_IMAGE_FLASH_NON_SECURE_UPDATE = (FLASH_BASE_ADDRESS+FLASH_AREA_3_OFFSET),
 	RE_IMAGE_FLASH_UNUSED = (FLASH_BASE_ADDRESS+FLASH_AREA_3_OFFSET+FLASH_AREA_3_SIZE),
 	RE_IMAGE_FLASH_SCRATCH = (FLASH_BASE_ADDRESS+FLASH_AREA_SCRATCH_OFFSET),
-	RE_IMAGE_FLASH_NV_COUNTERS = (FLASH_BASE_ADDRESS+FLASH_OTP_NV_COUNTERS_AREA_OFFSET),
+	RE_IMAGE_FLASH_NV_COUNTERS = (FLASH_BASE_ADDRESS+FLASH_NV_COUNTERS_AREA_OFFSET),
 	RE_IMAGE_FLASH_NV_PS = (FLASH_BASE_ADDRESS+FLASH_PS_AREA_OFFSET),
 	RE_IMAGE_FLASH_NV_ITS = (FLASH_BASE_ADDRESS+FLASH_ITS_AREA_OFFSET)
-}
+}
\ No newline at end of file
diff --git a/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/include/flash_layout.h b/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/include/flash_layout.h
index ba195f25c..f02175a9c 100644
--- a/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/include/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/include/flash_layout.h
@@ -31,23 +31,24 @@
  /* Flash layout (internal flash) on stm23l562e_dk with BL2 (multiple image boot):
  *
  * 0x0000_0000 BL2 - MCUBoot (72 KB)
- * 0x0000_e000 OTP / NV counters area (8 KB)
- * 0x0001_0000 Secure Storage Area (8 KB)
- * 0x0001_2000 Internal Trusted Storage Area (8 KB)
- * 0x0001_4000 Secure image     primary slot (180 KB)
- * 0x0004_1000 Non-secure image primary slot (36 KB)
- * 0x0004_a000 Secure image     secondary slot (180 KB)
- * 0x0007_7000 Non-secure image secondary slot (36 KB)
+ * 0x0000_e000 NV counters area (4 KB)
+ * 0x0000_f000 Secure Storage Area (8 KB)
+ * 0x0001_1000 Internal Trusted Storage Area (8 KB)
+ * 0x0001_3000 Secure image     primary slot (180 KB)
+ * 0x0004_0000 Non-secure image primary slot (36 KB)
+ * 0x0004_9000 Secure image     secondary slot (180 KB)
+ * 0x0007_6000 Non-secure image secondary slot (36 KB)
+ * 0x0007_F000 Unused (4 KB)
  *
  * Flash layout on  stm23l562e_dk with BL2 (multiple image boot, layout for test):
  * No Firmware update
  * 0x0000_0000 BL2 - MCUBoot (72 KB)
- * 0x0000_e000 OTP / NV counters area  area (8 KB)
- * 0x0001_0000 Secure Storage Area (8 KB)
- * 0x0001_2000 Internal Trusted Storage Area (8 KB)
- * 0x0001_4000 Secure image     primary slot (224 KB)
- * 0x0004_c000 Non-secure image primary slot (172 KB)
- * 0x0007_6000 Unused (28K)
+ * 0x0000_e000 NV counters area (4 KB)
+ * 0x0000_f000 Secure Storage Area (8 KB)
+ * 0x0001_1000 Internal Trusted Storage Area (8 KB)
+ * 0x0001_3000 Secure image     primary slot (224 KB)
+ * 0x0004_b000 Non-secure image primary slot (172 KB)
+ * 0x0007_5000 Unused (32K)
  * The size of a partition. This should be large enough to contain a S or NS
  * sw binary. Each FLASH_AREA_IMAGE contains two partitions. See Flash layout
  * above.
@@ -56,9 +57,9 @@
 /* Flash layout (internal & external flash) on stm23l562e_dk with BL2 (multiple image boot):
  *
  * Internal flash
- * 0x0000_0000 BL2 - MCUBoot (68 KB)
- * 0x0001_1000 scratch (8 KB)
- * 0x0001_3000 OTP / NV counters area (8 KB)
+ * 0x0000_0000 BL2 - MCUBoot (72 KB)
+ * 0x0001_2000 scratch (8 KB)
+ * 0x0001_4000 NV counters area (4 KB)
  * 0x0001_5000 Secure Storage Area (8 KB)
  * 0x0001_7000 Internal Trusted Storage Area (8 KB)
  * 0x0001_9000 Secure image     primary slot (240 KB)
@@ -89,7 +90,7 @@
 /* area for BL2 code protected by hdp */
 #define FLASH_AREA_BL2_OFFSET           (0x0)
 #if defined(EXTERNAL_FLASH)
-#define FLASH_AREA_BL2_SIZE             (0xF800)
+#define FLASH_AREA_BL2_SIZE             (0x10800)
 #else
 #define FLASH_AREA_BL2_SIZE             (0xd800)
 #endif /* EXTERNAL_FLASH */
@@ -108,21 +109,20 @@
 #define FLASH_AREA_SCRATCH_OFFSET       (FLASH_AREA_BL2_NOHDP_OFFSET+FLASH_AREA_BL2_NOHDP_SIZE)
 #define FLASH_AREA_SCRATCH_SIZE         (0x2000)
 /* according to test flash layout can change */
-#if defined(FLASH_LAYOUT_FOR_TEST)
+#if defined(FLASH_LAYOUT_FOR_TEST) || defined(TEST_FRAMEWORK_S) || defined(TEST_FRAMEWORK_NS)
 /* Non Volatile Counters definitions */
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE   (0x1000)
+#define FLASH_NV_COUNTERS_SECTOR_SIZE      (0x1000)
 #if defined(EXTERNAL_FLASH)
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET   (FLASH_AREA_SCRATCH_OFFSET+FLASH_AREA_SCRATCH_SIZE)
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_AREA_SCRATCH_OFFSET+FLASH_AREA_SCRATCH_SIZE)
 #else
 /* fix me with overwrite scratch is not required */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET   (FLASH_AREA_SCRATCH_OFFSET)
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_AREA_SCRATCH_OFFSET)
 #endif /* defined(EXTERNAL_FLASH) */
 
 /* fix me with test config PS and ITS in RAM */
 /* Secure Storage (PS) Service definitions */
 #define FLASH_PS_AREA_SIZE             (0x2000)
-#define FLASH_PS_AREA_OFFSET           (FLASH_OTP_NV_COUNTERS_AREA_OFFSET + \
-                                        FLASH_OTP_NV_COUNTERS_AREA_SIZE)
+#define FLASH_PS_AREA_OFFSET           (FLASH_NV_COUNTERS_AREA_OFFSET+FLASH_NV_COUNTERS_SECTOR_SIZE)
 
 /* Internal Trusted Storage (ITS) Service definitions */
 #define FLASH_ITS_AREA_OFFSET           (FLASH_PS_AREA_OFFSET+FLASH_PS_AREA_SIZE)
@@ -137,20 +137,17 @@
 #define FLASH_AREA_0_OFFSET             (FLASH_ITS_AREA_OFFSET+FLASH_ITS_AREA_SIZE)
 #define FLASH_AREA_0_SIZE               (FLASH_S_PARTITION_SIZE)
 #else
-/* OTP / Non Volatile Counters definitions */
-#define FLASH_OTP_NV_COUNTERS_SECTOR_SIZE   (0x1000)
+/* Non Volatile Counters definitions */
+#define FLASH_NV_COUNTERS_SECTOR_SIZE      (0x1000)
 #if defined(EXTERNAL_FLASH)
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET   (FLASH_AREA_SCRATCH_OFFSET + \
-                                             FLASH_AREA_SCRATCH_SIZE)
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_AREA_SCRATCH_OFFSET+FLASH_AREA_SCRATCH_SIZE)
 #else
 /* fix me with overwrite scratch is not required */
-#define FLASH_OTP_NV_COUNTERS_AREA_OFFSET   (FLASH_AREA_SCRATCH_OFFSET)
+#define FLASH_NV_COUNTERS_AREA_OFFSET   (FLASH_AREA_SCRATCH_OFFSET)
 #endif /* defined(EXTERNAL_FLASH) */
-
 /* Secure Storage (PS) Service definitions */
 #define FLASH_PS_AREA_SIZE             (0x2000)
-#define FLASH_PS_AREA_OFFSET           (FLASH_OTP_NV_COUNTERS_AREA_OFFSET + \
-                                        FLASH_OTP_NV_COUNTERS_AREA_SIZE)
+#define FLASH_PS_AREA_OFFSET           (FLASH_NV_COUNTERS_AREA_OFFSET+FLASH_NV_COUNTERS_SECTOR_SIZE)
 
 /* Internal Trusted Storage (ITS) Service definitions */
 #define FLASH_ITS_AREA_OFFSET           (FLASH_PS_AREA_OFFSET+FLASH_PS_AREA_SIZE)
@@ -203,8 +200,7 @@
 #define MCUBOOT_MAX_IMG_SECTORS           ((2 * FLASH_PARTITION_SIZE) / \
                                          FLASH_AREA_IMAGE_SECTOR_SIZE)
 
-#define FLASH_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_SECTOR_SIZE + \
-                                           FLASH_OTP_NV_COUNTERS_SECTOR_SIZE)
+#define FLASH_NV_COUNTERS_AREA_SIZE     (0x18)     /* 16 Bytes */
 
 #define SECURE_IMAGE_OFFSET             (0x0)
 #define SECURE_IMAGE_MAX_SIZE           FLASH_S_PARTITION_SIZE
@@ -226,7 +222,6 @@
   */
 
 #define FLASH_DEV_NAME TFM_Driver_FLASH0
-#define TFM_HAL_FLASH_PROGRAM_UNIT       (0x8)
 
 /* Protected Storage (PS) Service definitions
  * Note: Further documentation of these definitions can be found in the
@@ -266,12 +261,15 @@
 /* Smallest flash programmable unit in bytes */
 #define TFM_HAL_ITS_PROGRAM_UNIT       (0x8)
 
-/* OTP / NV counter definitions */
-#define TFM_OTP_NV_COUNTERS_AREA_SIZE   (FLASH_OTP_NV_COUNTERS_AREA_SIZE / 2)
-#define TFM_OTP_NV_COUNTERS_AREA_ADDR   FLASH_OTP_NV_COUNTERS_AREA_OFFSET
-#define TFM_OTP_NV_COUNTERS_SECTOR_SIZE FLASH_OTP_NV_COUNTERS_SECTOR_SIZE
-#define TFM_OTP_NV_COUNTERS_BACKUP_AREA_ADDR (TFM_OTP_NV_COUNTERS_AREA_ADDR + \
-                                              TFM_OTP_NV_COUNTERS_AREA_SIZE)
+/* NV Counters definitions */
+#define TFM_NV_COUNTERS_AREA_ADDR    FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_AREA_SIZE    (0x18)/* 24 Bytes */
+#define TFM_NV_COUNTERS_SECTOR_ADDR  FLASH_NV_COUNTERS_AREA_OFFSET
+#define TFM_NV_COUNTERS_SECTOR_SIZE  FLASH_AREA_IMAGE_SECTOR_SIZE
+
+/* BL2 NV Counters definitions  */
+#define BL2_NV_COUNTERS_AREA_ADDR    FLASH_BL2_NVCNT_AREA_OFFSET
+#define BL2_NV_COUNTERS_AREA_SIZE    FLASH_BL2_NVCNT_AREA_SIZE
 
 #define BL2_S_RAM_ALIAS_BASE  (0x30000000)
 #define BL2_NS_RAM_ALIAS_BASE (0x20000000)
diff --git a/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/readme.rst b/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/readme.rst
index 4a8704a75..7dd0e880d 100644
--- a/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/readme.rst
+++ b/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/readme.rst
@@ -11,7 +11,7 @@ and build the selected configuration as follow.
 
 ``> mkdir build && cd build``
 
-``> cmake .. -DTFM_PLATFORM=stm/stm32l562e_dk -DTFM_TOOLCHAIN_FILE=../toolchain_GNUARM.cmake -G"Unix Makefiles"``
+``> cmake .. -DTFM_PLATFORM=stm/stm32l562e-dk -DTFM_TOOLCHAIN_FILE=../toolchain_GNUARM.cmake -G"Unix Makefiles"``
 
 ``> cmake --build ./  -- install``
 
diff --git a/lib/tf-m/platform/include/tfm_attest_hal.h b/lib/tf-m/platform/include/tfm_attest_hal.h
index a15599684..0d77da044 100644
--- a/lib/tf-m/platform/include/tfm_attest_hal.h
+++ b/lib/tf-m/platform/include/tfm_attest_hal.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -25,23 +25,9 @@ enum tfm_security_lifecycle_t {
     TFM_SLC_NON_PSA_ROT_DEBUG         = 0x4000u,
     TFM_SLC_RECOVERABLE_PSA_ROT_DEBUG = 0x5000u,
     TFM_SLC_DECOMMISSIONED            = 0x6000u,
-    TFM_SLC_MAX_VALUE                 = UINT32_MAX,
+    TFM_SLC_MAX_VALUE                 = 0x60FFu,
 };
 
-/**
- * \def VERIFCATION_URL_MAX_SIZE
- *
- * \brief Maximum size of verification URL in bytes
- */
-#define VERIFCATION_URL_MAX_SIZE (32u)
-
-/**
- * \def PROFILE_DEFINITION_MAX_SIZE
- *
- * \brief Maximum size of profile definition in bytes
- */
-#define PROFILE_DEFINITION_MAX_SIZE (32u)
-
 /**
  * \brief Retrieve the security lifecycle of the device
  *
@@ -58,17 +44,13 @@ enum tfm_security_lifecycle_t tfm_attest_hal_get_security_lifecycle(void);
  * It can be a text string that can be used to locate the service or can be a
  * URL specifying the address of the service.
  *
- * \param[in/out] size  As an input value it indicates the size of the caller
- *                      allocated buffer (in bytes) to store the HW version. At
- *                      return its value is updated with the exact size of the
- *                      verification service URL.
- * \param[out]    buf   Pointer to the buffer to store the verification service
- *                      URL.
+ * \param[out]  size  Length of the string, without the termination zero byte.
  *
- * \return  Returns error code specified in \ref tfm_plat_err_t
+ * \return NULL pointer if not available otherwise the address of the
+ *         verification service string in the device memory.
  */
-enum tfm_plat_err_t
-tfm_attest_hal_get_verification_service(uint32_t *size, uint8_t *buf);
+const char *
+tfm_attest_hal_get_verification_service(uint32_t *size);
 
 /**
  * \brief Retrieve the name of the profile definition document for initial
@@ -78,16 +60,14 @@ tfm_attest_hal_get_verification_service(uint32_t *size, uint8_t *buf);
  *  being a full description of the claims, their usage, verification and
  *  token signing.
  *
- * \param[in/out] size  As an input value it indicates the size of the caller
- *                      allocated buffer (in bytes) to store the HW version. At
- *                      return its value is updated with the exact size of the
- *                      profile definition.
- * \param[out]    buf   Pointer to the buffer to store the profile definition.
+ * \param[out]  size  Length of the document name, without the termination zero
+ *                    byte.
  *
- * \return  Returns error code specified in \ref tfm_plat_err_t
+ * \return NULL pointer if not available otherwise the address of the document
+ *         name string in the device memory.
  */
-enum tfm_plat_err_t
-tfm_attest_hal_get_profile_definition(uint32_t *size, uint8_t *buf);
+const char *
+tfm_attest_hal_get_profile_definition(uint32_t *size);
 
 #ifdef __cplusplus
 }
diff --git a/lib/tf-m/platform/include/tfm_hal_isolation.h b/lib/tf-m/platform/include/tfm_hal_isolation.h
index 120cdf579..18a8c5001 100644
--- a/lib/tf-m/platform/include/tfm_hal_isolation.h
+++ b/lib/tf-m/platform/include/tfm_hal_isolation.h
@@ -10,9 +10,8 @@
 
 #include <stddef.h>
 #include <stdint.h>
+#include "fih.h"
 #include "tfm_hal_defs.h"
-#include "load/partition_defs.h"
-#include "load/asset_defs.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -27,7 +26,6 @@ extern "C" {
 #define TFM_HAL_ACCESS_NS               (1UL << 5)
 
 #ifdef TFM_FIH_PROFILE_ON
-#include "fih.h"
 /**
  * \brief  Sets up the static isolation boundaries which are constant throughout
  *         the runtime of the system, including the SPE/NSPE and partition
@@ -38,20 +36,24 @@ extern "C" {
  */
 fih_int tfm_hal_set_up_static_boundaries(void);
 
+#if TFM_LVL == 3
 /**
- * \brief  Update the isolation boundaries.
+ * \brief  Updates the partition isolation boundary for isolation level 3.
+ *         The boundary protects the private data of the running partition.
+ *         The boundary is updated with SPM switching partition in level 3.
  *
- * \param[in]   p_ldinf         Partition load information.
- * \param[in]   p_boundaries    Platform boundary handle for partition.
+ * \param[in] start     start address of the partition boundary.
+ * \param[in] end       end address of the partition boundary.
  *
- * \return TFM_HAL_SUCCESS          The isolation boundaries update succeeded.
- *         TFM_HAL_ERROR_GENERIC    Failed to update the isolation boundaries.
+ * \return TFM_HAL_SUCCESS - the isolation boundary has been set up.
+ *         TFM_HAL_ERROR_GENERIC - failed to set up the isolation boundary.
  *
  * \note   When FIH_ENABLE_DOUBLE_VARS is enabled, the return code will be
  *         wrapped and protected in \ref fih_int structure.
  */
-fih_int tfm_hal_update_boundaries(const struct partition_load_info_t *p_ldinf,
-                                  void *p_boundaries);
+fih_int tfm_hal_mpu_update_partition_boundary(uintptr_t start,
+                                              uintptr_t end);
+#endif
 #else /* TFM_FIH_PROFILE_ON */
 /**
  * \brief  Sets up the static isolation boundaries which are constant throughout
@@ -60,21 +62,30 @@ fih_int tfm_hal_update_boundaries(const struct partition_load_info_t *p_ldinf,
  *
  * \return TFM_HAL_SUCCESS - the isolation boundaries have been set up.
  *         TFM_HAL_ERROR_GENERIC - failed to set up the isolation boundaries.
+ *
+ * \note   When FIH_ENABLE_DOUBLE_VARS is enabled, the return code will be
+ *         wrapped and protected in \ref fih_int structure.
  */
 enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void);
 
+#if TFM_LVL == 3
 /**
- * \brief  Update the isolation boundaries.
+ * \brief  Updates the partition isolation boundary for isolation level 3.
+ *         The boundary protects the private data of the running partition.
+ *         The boundary is updated with SPM switching partition in level 3.
  *
- * \param[in]   p_ldinf         Partition load information.
- * \param[in]   p_boundaries    Platform boundary handle for partition.
+ * \param[in] start     start address of the partition boundary.
+ * \param[in] end       end address of the partition boundary.
  *
- * \return TFM_HAL_SUCCESS          The isolation boundaries update succeeded.
- *         TFM_HAL_ERROR_GENERIC    Failed to update the isolation boundaries.
+ * \return TFM_HAL_SUCCESS - the isolation boundary has been set up.
+ *         TFM_HAL_ERROR_GENERIC - failed to set up the isolation boundary.
+ *
+ * \note   When FIH_ENABLE_DOUBLE_VARS is enabled, the return code will be
+ *         wrapped and protected in \ref fih_int structure.
  */
-enum tfm_hal_status_t tfm_hal_update_boundaries(
-                            const struct partition_load_info_t *p_ldinf,
-                            void *p_boundaries);
+enum tfm_hal_status_t tfm_hal_mpu_update_partition_boundary(uintptr_t start,
+                                                            uintptr_t end);
+#endif
 #endif /* TFM_FIH_PROFILE_ON */
 
 /**
@@ -97,28 +108,6 @@ enum tfm_hal_status_t tfm_hal_memory_has_access(uintptr_t base,
                                                 size_t size,
                                                 uint32_t attr);
 
-/**
- * \brief  This API binds partition boundaries with the platform. The platform
- *         maintains the platform-specific settings for SPM further
- *         usage, such as update partition hardware boundaries or
- *         check resource accessibility. The platform needs to manage
- *         the settings with internal mechanism, and return a handle
- *         to SPM. SPM delivers this handle back to platform when
- *         necessary. And SPM checks this handle to decide if the
- *         platform-specific settings need to be updated. Hence
- *         multiple partitions can have the same handle if they have
- *         the same platform-specific settings, depending on isolation level.
- *
- * \param[in]   p_ldinf           Partition load information.
- * \param[in]   pp_boundaries     Pointer of the boundary handle
- *
- * \return TFM_HAL_SUCCESS          - A platform handle binding success.
- *         TFM_HAL_ERROR_GENERIC    - Error occured while binding.
- */
-enum tfm_hal_status_t tfm_hal_bind_boundaries(
-                                    const struct partition_load_info_t *p_ldinf,
-                                    void **pp_boundaries);
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/tf-m.old/platform/include/tfm_plat_crypto_dummy_nv_seed.h b/lib/tf-m/platform/include/tfm_plat_crypto_dummy_nv_seed.h
new file mode 100644
index 000000000..08bec766b
--- /dev/null
+++ b/lib/tf-m/platform/include/tfm_plat_crypto_dummy_nv_seed.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+#ifndef __TFM_PLAT_CRYPTO_DUMMY_NV_SEED_H__
+#define __TFM_PLAT_CRYPTO_DUMMY_NV_SEED_H__
+
+#include "tfm_plat_crypto_nv_seed.h"
+
+/**
+ * \brief Create a dummy entropy seed when platform doesn't provision the seed.
+ *        Do NOT call this function in production.
+ *
+ * \return Return TFM_CRYPTO_NV_SEED_SUCCESS on success,
+ *         or TFM_CRYPTO_NV_SEED_FAILED on failure.
+ */
+int tfm_plat_crypto_create_entropy_seed(void);
+
+#endif /* __TFM_PLAT_CRYPTO_DUMMY_NV_SEED_H__ */
diff --git a/lib/tf-m/platform/include/tfm_plat_crypto_nv_seed.h b/lib/tf-m/platform/include/tfm_plat_crypto_nv_seed.h
index fe296727e..9b897c83e 100644
--- a/lib/tf-m/platform/include/tfm_plat_crypto_nv_seed.h
+++ b/lib/tf-m/platform/include/tfm_plat_crypto_nv_seed.h
@@ -16,14 +16,6 @@
 #define TFM_CRYPTO_NV_SEED_SUCCESS 0
 #define TFM_CRYPTO_NV_SEED_FAILED  -1
 
-/**
- * \brief Provision Seed to NV storage. Fails if a seed is already in storage.
- *
- * \return Return TFM_CRYPTO_NV_SEED_SUCCESS on success,
- *         or TFM_CRYPTO_NV_SEED_FAILED on failure.
- */
-int tfm_plat_crypto_provision_entropy_seed(void);
-
 /**
  * \brief Read Seed from NV storage.
  *
diff --git a/lib/tf-m/platform/include/tfm_plat_nv_counters.h b/lib/tf-m/platform/include/tfm_plat_nv_counters.h
index 91a27b3da..cff9972ea 100644
--- a/lib/tf-m/platform/include/tfm_plat_nv_counters.h
+++ b/lib/tf-m/platform/include/tfm_plat_nv_counters.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -27,16 +27,13 @@
 #include "tfm_plat_defs.h"
 
 enum tfm_nv_counter_t {
-    PLAT_NV_COUNTER_PS_0 = 0,  /* Used by PS service */
-    PLAT_NV_COUNTER_PS_1,      /* Used by PS service */
-    PLAT_NV_COUNTER_PS_2,      /* Used by PS service */
-
-    PLAT_NV_COUNTER_BL2_0,     /* Used by bootloader */
-    PLAT_NV_COUNTER_BL2_1,     /* Used by bootloader */
-    PLAT_NV_COUNTER_BL2_2,     /* Used by bootloader */
-
-    PLAT_NV_COUNTER_BL1_0,     /* Used by bootloader */
-
+    PLAT_NV_COUNTER_0 = 0,  /* Used by PS service */
+    PLAT_NV_COUNTER_1,      /* Used by PS service */
+    PLAT_NV_COUNTER_2,      /* Used by PS service */
+#ifdef BL2
+    PLAT_NV_COUNTER_3,      /* Used by bootloader */
+    PLAT_NV_COUNTER_4,      /* Used by bootloader */
+#endif
     PLAT_NV_COUNTER_MAX,
     PLAT_NV_COUNTER_BOUNDARY = UINT32_MAX  /* Fix  tfm_nv_counter_t size
                                               to 4 bytes */
diff --git a/lib/tf-m/platform/include/tfm_plat_test.h b/lib/tf-m/platform/include/tfm_plat_test.h
index 8ccbe2b8f..013081d2c 100644
--- a/lib/tf-m/platform/include/tfm_plat_test.h
+++ b/lib/tf-m/platform/include/tfm_plat_test.h
@@ -10,6 +10,42 @@
 
 #include "tfm_plat_defs.h"
 
+/**
+ * \brief Busy wait until the user presses a specific button
+ */
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_CORE_TEST", "PSA-ROT")
+void tfm_plat_test_wait_user_button_pressed(void);
+
+/**
+ * \brief Busy wait until the user releases a specific button
+ */
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_CORE_TEST", "PSA-ROT")
+void tfm_plat_test_wait_user_button_released(void);
+
+/**
+ * \brief Get the status of the LEDs used by tests
+ *
+ * \return Returns the current status of LEDs
+ */
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_CORE_TEST", "PSA-ROT")
+uint32_t tfm_plat_test_get_led_status(void);
+
+/**
+ * \brief Sets the status of the LEDs used by tests
+ *
+ * \param[in]  status  The status to be set
+ */
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_CORE_TEST", "PSA-ROT")
+void tfm_plat_test_set_led_status(uint32_t status);
+
+/**
+ * \brief Get the mask of the LEDs used for testing
+ *
+ * \return Returns the mask of the LEDs used for testing
+ */
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_CORE_TEST", "PSA-ROT")
+uint32_t tfm_plat_test_get_userled_mask(void);
+
 /**
  * \brief starts Secure timer
  *
@@ -18,9 +54,9 @@
  * the timer should be long enough so that the test service can go to the state
  * where it starts waiting for the interrupt.
  */
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
 TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
-#elif defined(TEST_NS_FLIH_IRQ)
+#elif defined(TFM_ENABLE_FLIH_TEST)
 TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
 void tfm_plat_test_secure_timer_start(void);
@@ -29,9 +65,9 @@ void tfm_plat_test_secure_timer_start(void);
 /**
  * \brief Clears Secure timer interrupt
  */
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
 TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
-#elif TEST_NS_FLIH_IRQ
+#elif TFM_ENABLE_FLIH_TEST
 TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
 void tfm_plat_test_secure_timer_clear_intr(void);
@@ -39,9 +75,9 @@ void tfm_plat_test_secure_timer_clear_intr(void);
 /**
  * \brief Stops the Secure timer and clears the timer interrupt.
  */
-#ifdef TEST_NS_SLIH_IRQ
+#ifdef TFM_ENABLE_SLIH_TEST
 TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
-#elif defined(TEST_NS_FLIH_IRQ)
+#elif defined(TFM_ENABLE_FLIH_TEST)
 TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
 void tfm_plat_test_secure_timer_stop(void);
diff --git a/lib/tf-m/platform/include/tfm_spm_hal.h b/lib/tf-m/platform/include/tfm_spm_hal.h
index 3ea57aab2..91e98073f 100644
--- a/lib/tf-m/platform/include/tfm_spm_hal.h
+++ b/lib/tf-m/platform/include/tfm_spm_hal.h
@@ -322,7 +322,8 @@ void tfm_spm_hal_get_ns_access_attr(const void *p, size_t s,
  *
  * \return True if the access is granted, false otherwise.
  */
-bool tfm_spm_hal_has_access_to_region(const void *p, size_t s, int flags);
+bool tfm_spm_hal_has_access_to_region(const void *p, size_t s,
+                                              int flags);
 #endif /* !defined(__SAUREGION_PRESENT) || (__SAUREGION_PRESENT == 0) */
 
 #endif /* __TFM_SPM_HAL_H__ */
diff --git a/lib/tf-m/platform/readme.rst b/lib/tf-m/platform/readme.rst
index db5bd4b7b..4919205c9 100644
--- a/lib/tf-m/platform/readme.rst
+++ b/lib/tf-m/platform/readme.rst
@@ -18,6 +18,7 @@ database in SPM, and it is provided to the SPM HAL functions.
 
 Peripherals currently used by the services in TF-M
 --------------------------------------------------
+- ``TFM_PERIPHERAL_FPGA_IO`` - FPGA system control and I/O
 - ``TFM_PERIPHERAL_UART1``-  UART1
 
 .. Note::
diff --git a/lib/tf-m/secure_fw/include/compile_check_defs.h b/lib/tf-m/secure_fw/include/compile_check_defs.h
index 5cdbba47b..89a94b8a4 100644
--- a/lib/tf-m/secure_fw/include/compile_check_defs.h
+++ b/lib/tf-m/secure_fw/include/compile_check_defs.h
@@ -9,7 +9,7 @@
 #define __COMPILE_CHECK_DEFS_H__
 
 #include "load/spm_load_api.h"
-#include "thread.h"
+#include "tfm_thread.h"
 
 #if TO_THREAD_PRIORITY(PARTITION_PRI_HIGHEST) != THRD_PRIOR_HIGHEST ||  \
     TO_THREAD_PRIORITY(PARTITION_PRI_HIGH) != THRD_PRIOR_HIGH ||        \
diff --git a/tf-m.old/secure_fw/include/tfm/tfm_spm_services.h b/lib/tf-m/secure_fw/include/tfm/tfm_spm_services.h
new file mode 100644
index 000000000..c1f423896
--- /dev/null
+++ b/lib/tf-m/secure_fw/include/tfm/tfm_spm_services.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#ifndef __TFM_SPM_SERVICES_H__
+#define __TFM_SPM_SERVICES_H__
+
+#include "psa/service.h"
+
+enum tfm_spm_request_type_t {
+    TFM_SPM_REQUEST_RESET_VOTE,
+};
+
+/**
+ * \brief Request a vote from SPM on a system reset
+ *
+ * \return Returns 0 if request is accepted, any other value means reject
+ */
+int32_t tfm_spm_request_reset_vote(void);
+
+#ifndef TFM_PSA_API
+void tfm_enable_irq(psa_signal_t irq_signal);
+void tfm_disable_irq(psa_signal_t irq_signal);
+#endif
+
+#endif /* __TFM_SPM_SERVICES_H__ */
diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_aead.c b/lib/tf-m/secure_fw/partitions/crypto/crypto_aead.c
index 012ffcf6a..bb4349961 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_aead.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_aead.c
@@ -53,6 +53,11 @@ psa_status_t tfm_crypto_aead_encrypt(psa_invec in_vec[],
     /* Initialise ciphertext_length to zero. */
     out_vec[0].len = 0;
 
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
     if (status != PSA_SUCCESS) {
         return status;
@@ -98,6 +103,11 @@ psa_status_t tfm_crypto_aead_decrypt(psa_invec in_vec[],
     /* Initialise plaintext_length to zero. */
     out_vec[0].len = 0;
 
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
     if (status != PSA_SUCCESS) {
         return status;
diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_asymmetric.c b/lib/tf-m/secure_fw/partitions/crypto/crypto_asymmetric.c
index 6640403bb..f0bda4e54 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_asymmetric.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_asymmetric.c
@@ -42,7 +42,11 @@ psa_status_t tfm_crypto_sign_message(psa_invec in_vec[],
     uint8_t *signature = out_vec[0].base;
     size_t signature_size = out_vec[0].len;
     mbedtls_svc_key_id_t encoded_key;
-    psa_status_t status;
+
+    psa_status_t status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
 
     status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
     if (status != PSA_SUCCESS) {
@@ -77,7 +81,11 @@ psa_status_t tfm_crypto_verify_message(psa_invec in_vec[],
     const uint8_t *signature = in_vec[2].base;
     size_t signature_length = in_vec[2].len;
     mbedtls_svc_key_id_t encoded_key;
-    psa_status_t status;
+    psa_status_t status = tfm_crypto_check_handle_owner(key_id);
+
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
 
     status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
     if (status != PSA_SUCCESS) {
@@ -111,7 +119,11 @@ psa_status_t tfm_crypto_sign_hash(psa_invec in_vec[],
     uint8_t *signature = out_vec[0].base;
     size_t signature_size = out_vec[0].len;
     mbedtls_svc_key_id_t encoded_key;
-    psa_status_t status;
+
+    psa_status_t status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
 
     status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
     if (status != PSA_SUCCESS) {
@@ -146,7 +158,11 @@ psa_status_t tfm_crypto_verify_hash(psa_invec in_vec[],
     const uint8_t *signature = in_vec[2].base;
     size_t signature_length = in_vec[2].len;
     mbedtls_svc_key_id_t encoded_key;
-    psa_status_t status;
+    psa_status_t status = tfm_crypto_check_handle_owner(key_id);
+
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
 
     status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
     if (status != PSA_SUCCESS) {
@@ -188,6 +204,11 @@ psa_status_t tfm_crypto_asymmetric_encrypt(psa_invec in_vec[],
     psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
     if (status != PSA_SUCCESS) {
         return status;
@@ -241,6 +262,11 @@ psa_status_t tfm_crypto_asymmetric_decrypt(psa_invec in_vec[],
     psa_status_t status;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
     if (status != PSA_SUCCESS) {
         return status;
diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_cipher.c b/lib/tf-m/secure_fw/partitions/crypto/crypto_cipher.c
index a45d239aa..670aa48fb 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_cipher.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_cipher.c
@@ -123,6 +123,11 @@ psa_status_t tfm_crypto_cipher_encrypt_setup(psa_invec in_vec[],
     psa_algorithm_t alg = iov->alg;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     /* Allocate the operation context in the secure world */
     status = tfm_crypto_operation_alloc(TFM_CRYPTO_CIPHER_OPERATION,
                                         &handle,
@@ -175,6 +180,11 @@ psa_status_t tfm_crypto_cipher_decrypt_setup(psa_invec in_vec[],
     psa_algorithm_t alg = iov->alg;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     /* Allocate the operation context in the secure world */
     status = tfm_crypto_operation_alloc(TFM_CRYPTO_CIPHER_OPERATION,
                                         &handle,
@@ -365,6 +375,11 @@ psa_status_t tfm_crypto_cipher_encrypt(psa_invec in_vec[],
     size_t output_size = out_vec[0].len;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
     if (status != PSA_SUCCESS) {
         return status;
@@ -399,6 +414,11 @@ psa_status_t tfm_crypto_cipher_decrypt(psa_invec in_vec[],
     size_t output_size = out_vec[0].len;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
     if (status != PSA_SUCCESS) {
         return status;
diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_init.c b/lib/tf-m/secure_fw/partitions/crypto/crypto_init.c
index 0694ae673..6dd7bf28e 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_init.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_init.c
@@ -17,9 +17,9 @@
  */
 #include "mbedtls/memory_buffer_alloc.h"
 
-#ifdef CRYPTO_NV_SEED
-#include "tfm_plat_crypto_nv_seed.h"
-#endif /* CRYPTO_NV_SEED */
+#ifdef PLATFORM_DUMMY_NV_SEED
+#include "tfm_plat_crypto_dummy_nv_seed.h"
+#endif
 
 #ifndef TFM_PSA_API
 #include "tfm_secure_api.h"
@@ -276,20 +276,12 @@ static uint8_t mbedtls_mem_buf[TFM_CRYPTO_ENGINE_BUF_SIZE] = {0};
 
 static psa_status_t tfm_crypto_engine_init(void)
 {
-
-#ifdef CRYPTO_NV_SEED
-#ifdef TFM_PSA_API
-    if (tfm_plat_crypto_provision_entropy_seed() != TFM_CRYPTO_NV_SEED_SUCCESS) {
+#ifdef PLATFORM_DUMMY_NV_SEED
+    LOG_INFFMT("\033[1;34m[Crypto] Dummy Entropy NV Seed is not suitable for production!\033[0m\r\n");
+    if (tfm_plat_crypto_create_entropy_seed() != TFM_CRYPTO_NV_SEED_SUCCESS) {
         return PSA_ERROR_GENERIC_ERROR;
     }
-#else
-    LOG_INFFMT("\033[1;31m[Crypto] ");
-    LOG_INFFMT("TF-M in library mode uses a dummy NV seed. ");
-    LOG_INFFMT("This is not suitable for production! ");
-    LOG_INFFMT("This device is \033[1;1mNOT SECURE");
-    LOG_INFFMT("\033[0m\r\n");
-#endif /* TFM_PSA_API */
-#endif /* CRYPTO_NV_SEED */
+#endif
 
     /* Initialise the Mbed Crypto memory allocator to use static
      * memory allocation from the provided buffer instead of using
diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_key.c b/lib/tf-m/secure_fw/partitions/crypto/crypto_key.c
index 892ce111e..0d95ac698 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_key.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_key.c
@@ -14,10 +14,129 @@
 #include "tfm_crypto_defs.h"
 #include "tfm_crypto_private.h"
 
-#ifndef MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
-#error "MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER must be selected in Mbed TLS config file"
+#ifndef TFM_CRYPTO_KEY_MODULE_DISABLED
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
+#ifndef TFM_CRYPTO_MAX_KEY_HANDLES
+#define TFM_CRYPTO_MAX_KEY_HANDLES (32)
 #endif
 
+struct tfm_crypto_handle_owner_s {
+    int32_t owner;           /*!< Owner of the allocated handle */
+    psa_key_id_t key;        /*!< Allocated key */
+    uint8_t in_use;          /*!< Flag to indicate if this in use */
+};
+
+static struct tfm_crypto_handle_owner_s
+                                 handle_owner[TFM_CRYPTO_MAX_KEY_HANDLES] = {0};
+
+static void set_handle_owner(uint8_t idx, int32_t client_id,
+                             psa_key_id_t key_handle)
+{
+    /* Skip checking idx */
+
+    handle_owner[idx].owner = client_id;
+    handle_owner[idx].key = key_handle;
+    handle_owner[idx].in_use = TFM_CRYPTO_IN_USE;
+}
+
+static void clean_handle_owner(uint8_t idx)
+{
+    /* Skip checking idx */
+
+    handle_owner[idx].owner = TFM_INVALID_CLIENT_ID;
+    handle_owner[idx].key = (psa_key_id_t)0;
+    handle_owner[idx].in_use = TFM_CRYPTO_NOT_IN_USE;
+}
+
+static psa_status_t find_empty_handle_owner_slot(uint8_t *idx)
+{
+    uint8_t i;
+
+    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
+        if (handle_owner[i].in_use == TFM_CRYPTO_NOT_IN_USE) {
+            *idx = i;
+            return PSA_SUCCESS;
+        }
+    }
+
+    return PSA_ERROR_INSUFFICIENT_MEMORY;
+}
+
+/*
+ * Check that the requested handle belongs to the requesting partition
+ *
+ * Argument idx is optional. It points to the buffer to hold the internal
+ * index corresponding to the input handle. Valid only on PSA_SUCCESS.
+ * It is filled only if the input pointer is not NULL.
+ *
+ * Return values as described in \ref psa_status_t
+ */
+static psa_status_t check_handle_owner(psa_key_id_t key, uint8_t *idx)
+{
+    int32_t client_id = 0;
+    uint8_t i = 0;
+    psa_status_t status;
+
+    status = tfm_crypto_get_caller_id(&client_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
+        if (handle_owner[i].in_use && handle_owner[i].key == key) {
+            if (handle_owner[i].owner == client_id) {
+                if (idx) {
+                    *idx = i;
+                }
+                return PSA_SUCCESS;
+            } else {
+                return PSA_ERROR_NOT_PERMITTED;
+            }
+        }
+    }
+
+    return PSA_ERROR_INVALID_HANDLE;
+}
+
+static void encoded_key_id_make(psa_key_id_t key, uint8_t slot_idx,
+                                mbedtls_svc_key_id_t *encoded_key)
+{
+    /* Skip checking encoded_key */
+    *encoded_key = mbedtls_svc_key_id_make(handle_owner[slot_idx].owner, key);
+}
+#else /* CRYPTO_KEY_ID_ENCODES_OWNER */
+#define set_handle_owner(idx, client_id, key_handle)        do {} while (0)
+#define clean_handle_owner(idx)                             do {} while (0)
+
+static inline psa_status_t find_empty_handle_owner_slot(uint8_t *idx)
+{
+    *idx = 0;
+
+    return PSA_SUCCESS;
+}
+
+static inline psa_status_t check_handle_owner(psa_key_id_t key, uint8_t *idx)
+{
+    (void)key;
+
+    if (idx) {
+        *idx = 0;
+    }
+
+    return PSA_SUCCESS;
+}
+
+static inline void encoded_key_id_make(psa_key_id_t key, uint8_t slot_idx,
+                                       mbedtls_svc_key_id_t *encoded_key)
+{
+    (void)slot_idx;
+
+    /* Skip checking encoded_key */
+    *encoded_key = mbedtls_svc_key_id_make(TFM_INVALID_CLIENT_ID, key);
+}
+#endif /* CRYPTO_KEY_ID_ENCODES_OWNER */
+#endif /* !TFM_CRYPTO_KEY_MODULE_DISABLED */
+
 /*!
  * \defgroup public Public functions
  *
@@ -47,8 +166,12 @@ psa_status_t tfm_crypto_key_attributes_from_client(
     core->MBEDTLS_PRIVATE(bits) = client_key_attr->bits;
 
     /* Use the client key id as the key_id and its partition id as the owner */
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
     core->MBEDTLS_PRIVATE(id).MBEDTLS_PRIVATE(key_id) = client_key_attr->id;
     core->MBEDTLS_PRIVATE(id).MBEDTLS_PRIVATE(owner) = client_id;
+#else
+    core->MBEDTLS_PRIVATE(id) = client_key_attr->id;
+#endif
 
     return PSA_SUCCESS;
 }
@@ -73,11 +196,24 @@ psa_status_t tfm_crypto_key_attributes_to_client(
     client_key_attr->bits = core.MBEDTLS_PRIVATE(bits);
 
     /* Return the key_id as the client key id, do not return the owner */
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
     client_key_attr->id = core.MBEDTLS_PRIVATE(id).MBEDTLS_PRIVATE(key_id);
+#else
+    client_key_attr->id = core.MBEDTLS_PRIVATE(id);
+#endif
 
     return PSA_SUCCESS;
 }
 
+psa_status_t tfm_crypto_check_handle_owner(psa_key_id_t key)
+{
+#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
+    return PSA_ERROR_NOT_SUPPORTED;
+#else
+    return check_handle_owner(key, NULL);
+#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
+}
+
 psa_status_t tfm_crypto_encode_id_and_owner(psa_key_id_t key_id,
                                             mbedtls_svc_key_id_t *enc_key_ptr)
 {
@@ -99,6 +235,35 @@ psa_status_t tfm_crypto_encode_id_and_owner(psa_key_id_t key_id,
     return PSA_SUCCESS;
 }
 
+psa_status_t tfm_crypto_check_key_storage(uint32_t *index)
+{
+#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
+    return PSA_ERROR_NOT_SUPPORTED;
+#else
+    return find_empty_handle_owner_slot((uint8_t *)index);
+#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
+}
+
+psa_status_t tfm_crypto_set_key_storage(uint32_t index,
+                                        psa_key_id_t key_handle)
+{
+#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
+    return PSA_ERROR_NOT_SUPPORTED;
+#else
+    psa_status_t status;
+    int32_t partition_id;
+
+    status = tfm_crypto_get_caller_id(&partition_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    set_handle_owner(index, partition_id, key_handle);
+
+    return PSA_SUCCESS;
+#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
+}
+
 psa_status_t tfm_crypto_set_key_domain_parameters(psa_invec in_vec[],
                                    size_t in_len,
                                    psa_outvec out_vec[],
@@ -148,9 +313,15 @@ psa_status_t tfm_crypto_import_key(psa_invec in_vec[],
 
     psa_status_t status;
     psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+    uint8_t i = 0;
     mbedtls_svc_key_id_t encoded_key;
     int32_t partition_id = 0;
 
+    status = find_empty_handle_owner_slot(&i);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     status = tfm_crypto_get_caller_id(&partition_id);
     if (status != PSA_SUCCESS) {
         return status;
@@ -164,12 +335,16 @@ psa_status_t tfm_crypto_import_key(psa_invec in_vec[],
     }
 
     status = psa_import_key(&key_attributes, data, data_length, &encoded_key);
-    if (status != PSA_SUCCESS) {
-        return status;
-    }
-
     /* Update the imported key id */
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
     *psa_key = encoded_key.MBEDTLS_PRIVATE(key_id);
+#else
+    *psa_key = (psa_key_id_t)encoded_key;
+#endif
+
+    if (status == PSA_SUCCESS) {
+        set_handle_owner(i, partition_id, *psa_key);
+    }
 
     return status;
 #endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
@@ -196,7 +371,13 @@ psa_status_t tfm_crypto_open_key(psa_invec in_vec[],
     psa_key_id_t *key = out_vec[0].base;
     psa_status_t status;
     mbedtls_svc_key_id_t encoded_key;
-    int32_t partition_id = 0;
+    int32_t partition_id;
+    uint8_t i;
+
+    status = find_empty_handle_owner_slot(&i);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
 
     status = tfm_crypto_get_caller_id(&partition_id);
     if (status != PSA_SUCCESS) {
@@ -207,11 +388,15 @@ psa_status_t tfm_crypto_open_key(psa_invec in_vec[],
     encoded_key = mbedtls_svc_key_id_make(partition_id, client_key_id);
 
     status = psa_open_key(encoded_key, &encoded_key);
-    if (status != PSA_SUCCESS) {
-        return status;
-    }
-
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
     *key = encoded_key.MBEDTLS_PRIVATE(key_id);
+#else
+    *key = (psa_key_id_t)encoded_key;
+#endif
+
+    if (status == PSA_SUCCESS) {
+        set_handle_owner(i, partition_id, *key);
+    }
 
     return status;
 #endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
@@ -235,18 +420,23 @@ psa_status_t tfm_crypto_close_key(psa_invec in_vec[],
     const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 
     psa_key_id_t key = iov->key_id;
+    uint8_t index;
     mbedtls_svc_key_id_t encoded_key;
-    int32_t partition_id = 0;
     psa_status_t status;
 
-    status = tfm_crypto_get_caller_id(&partition_id);
+    status = check_handle_owner(key, &index);
     if (status != PSA_SUCCESS) {
         return status;
     }
 
-    encoded_key = mbedtls_svc_key_id_make(partition_id, key);
+    encoded_key_id_make(key, index, &encoded_key);
+
+    status = psa_close_key(encoded_key);
+    if (status == PSA_SUCCESS) {
+        clean_handle_owner(index);
+    }
 
-    return psa_close_key(encoded_key);
+    return status;
 #endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
 }
 
@@ -267,18 +457,23 @@ psa_status_t tfm_crypto_destroy_key(psa_invec in_vec[],
     }
     const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
     psa_key_id_t key = iov->key_id;
+    uint8_t index;
     mbedtls_svc_key_id_t encoded_key;
-    int32_t partition_id = 0;
     psa_status_t status;
 
-    status = tfm_crypto_get_caller_id(&partition_id);
+    status = check_handle_owner(key, &index);
     if (status != PSA_SUCCESS) {
         return status;
     }
 
-    encoded_key = mbedtls_svc_key_id_make(partition_id, key);
+    encoded_key_id_make(key, index, &encoded_key);
 
-    return psa_destroy_key(encoded_key);
+    status = psa_destroy_key(encoded_key);
+    if (status == PSA_SUCCESS) {
+        clean_handle_owner(index);
+    }
+
+    return status;
 #endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
 }
 
@@ -304,14 +499,14 @@ psa_status_t tfm_crypto_get_key_attributes(psa_invec in_vec[],
     psa_status_t status;
     psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
     mbedtls_svc_key_id_t encoded_key;
-    int32_t partition_id = 0;
+    uint8_t index;
 
-    status = tfm_crypto_get_caller_id(&partition_id);
+    status = check_handle_owner(key, &index);
     if (status != PSA_SUCCESS) {
         return status;
     }
 
-    encoded_key = mbedtls_svc_key_id_make(partition_id, key);
+    encoded_key_id_make(key, index, &encoded_key);
 
     status = psa_get_key_attributes(encoded_key, &key_attributes);
     if (status == PSA_SUCCESS) {
@@ -383,15 +578,15 @@ psa_status_t tfm_crypto_export_key(psa_invec in_vec[],
     uint8_t *data = out_vec[0].base;
     size_t data_size = out_vec[0].len;
     mbedtls_svc_key_id_t encoded_key;
-    int32_t partition_id = 0;
     psa_status_t status;
+    uint8_t index;
 
-    status = tfm_crypto_get_caller_id(&partition_id);
+    status = check_handle_owner(key, &index);
     if (status != PSA_SUCCESS) {
         return status;
     }
 
-    encoded_key = mbedtls_svc_key_id_make(partition_id, key);
+    encoded_key_id_make(key, index, &encoded_key);
 
     return psa_export_key(encoded_key, data, data_size,
                           &(out_vec[0].len));
@@ -417,15 +612,15 @@ psa_status_t tfm_crypto_export_public_key(psa_invec in_vec[],
     uint8_t *data = out_vec[0].base;
     size_t data_size = out_vec[0].len;
     mbedtls_svc_key_id_t encoded_key;
-    int32_t partition_id = 0;
     psa_status_t status;
+    uint8_t index;
 
-    status = tfm_crypto_get_caller_id(&partition_id);
+    status = check_handle_owner(key, &index);
     if (status != PSA_SUCCESS) {
         return status;
     }
 
-    encoded_key = mbedtls_svc_key_id_make(partition_id, key);
+    encoded_key_id_make(key, index, &encoded_key);
 
     return psa_export_public_key(encoded_key, data, data_size,
                                  &(out_vec[0].len));
@@ -450,17 +645,22 @@ psa_status_t tfm_crypto_purge_key(psa_invec in_vec[],
     const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
     psa_key_id_t key = iov->key_id;
     mbedtls_svc_key_id_t encoded_key;
-    int32_t partition_id = 0;
     psa_status_t status;
+    uint8_t index;
 
-    status = tfm_crypto_get_caller_id(&partition_id);
+    status = check_handle_owner(key, &index);
     if (status != PSA_SUCCESS) {
         return status;
     }
 
-    encoded_key = mbedtls_svc_key_id_make(partition_id, key);
+    encoded_key_id_make(key, index, &encoded_key);
 
-    return psa_purge_key(encoded_key);
+    status = psa_purge_key(encoded_key);
+    if (status == PSA_SUCCESS) {
+        clean_handle_owner(index);
+    }
+
+    return status;
 #endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
 }
 
@@ -487,10 +687,16 @@ psa_status_t tfm_crypto_copy_key(psa_invec in_vec[],
     const struct psa_client_key_attributes_s *client_key_attr = in_vec[1].base;
     psa_status_t status;
     psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+    uint8_t source_idx = 0, target_idx = 0;
     int32_t partition_id = 0;
     mbedtls_svc_key_id_t target_key;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = find_empty_handle_owner_slot(&target_idx);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     status = tfm_crypto_get_caller_id(&partition_id);
     if (status != PSA_SUCCESS) {
         return status;
@@ -503,14 +709,22 @@ psa_status_t tfm_crypto_copy_key(psa_invec in_vec[],
         return status;
     }
 
-    encoded_key = mbedtls_svc_key_id_make(partition_id, source_key_id);
-
-    status = psa_copy_key(encoded_key, &key_attributes, &target_key);
+    status = check_handle_owner(source_key_id, &source_idx);
     if (status != PSA_SUCCESS) {
         return status;
     }
 
+    encoded_key_id_make(source_key_id, source_idx, &encoded_key);
+
+    status = psa_copy_key(encoded_key, &key_attributes, &target_key);
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
     *target_key_id = target_key.MBEDTLS_PRIVATE(key_id);
+#else
+    *target_key_id = (psa_key_id_t)target_key;
+#endif
+    if (status == PSA_SUCCESS) {
+        set_handle_owner(target_idx, partition_id, *target_key_id);
+    }
 
     return status;
 #endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
@@ -536,9 +750,15 @@ psa_status_t tfm_crypto_generate_key(psa_invec in_vec[],
     const struct psa_client_key_attributes_s *client_key_attr = in_vec[1].base;
     psa_status_t status;
     psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+    uint8_t i = 0;
     int32_t partition_id = 0;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = find_empty_handle_owner_slot(&i);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     status = tfm_crypto_get_caller_id(&partition_id);
     if (status != PSA_SUCCESS) {
         return status;
@@ -552,11 +772,15 @@ psa_status_t tfm_crypto_generate_key(psa_invec in_vec[],
     }
 
     status = psa_generate_key(&key_attributes, &encoded_key);
-    if (status != PSA_SUCCESS) {
-        return status;
-    }
-
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
     *key_handle = encoded_key.MBEDTLS_PRIVATE(key_id);
+#else
+    *key_handle = (psa_key_id_t)encoded_key;
+#endif
+
+    if (status == PSA_SUCCESS) {
+        set_handle_owner(i, partition_id, *key_handle);
+    }
 
     return status;
 #endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_key_derivation.c b/lib/tf-m/secure_fw/partitions/crypto/crypto_key_derivation.c
index 1850b86a0..33996834c 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_key_derivation.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_key_derivation.c
@@ -347,6 +347,11 @@ psa_status_t tfm_crypto_key_derivation_input_key(psa_invec in_vec[],
     psa_key_derivation_operation_t *operation = NULL;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     /* Look up the corresponding operation context */
     status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
                                          handle,
@@ -389,6 +394,7 @@ psa_status_t tfm_crypto_key_derivation_output_key(psa_invec in_vec[],
     psa_key_id_t *key_handle = out_vec[0].base;
     psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
     int32_t partition_id;
+    uint32_t index;
     mbedtls_svc_key_id_t encoded_key;
 
     /* Look up the corresponding operation context */
@@ -399,6 +405,11 @@ psa_status_t tfm_crypto_key_derivation_output_key(psa_invec in_vec[],
         return status;
     }
 
+    status = tfm_crypto_check_key_storage(&index);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     status = tfm_crypto_get_caller_id(&partition_id);
     if (status != PSA_SUCCESS) {
         return status;
@@ -418,8 +429,15 @@ psa_status_t tfm_crypto_key_derivation_output_key(psa_invec in_vec[],
         status = psa_key_derivation_output_key(&key_attributes, operation,
                                                &encoded_key);
     }
-
+#ifdef MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
     *key_handle = encoded_key.MBEDTLS_PRIVATE(key_id);
+#else
+    *key_handle = (psa_key_id_t)encoded_key;
+#endif
+
+    if (status == PSA_SUCCESS) {
+        status = tfm_crypto_set_key_storage(index, *key_handle);
+    }
 
     return status;
 #endif /* TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED */
@@ -503,6 +521,11 @@ psa_status_t tfm_crypto_key_derivation_key_agreement(psa_invec in_vec[],
     psa_key_derivation_step_t step = iov->step;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = tfm_crypto_check_handle_owner(private_key);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     /* Look up the corresponding operation context */
     status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
                                          handle,
@@ -545,7 +568,12 @@ psa_status_t tfm_crypto_raw_key_agreement(psa_invec in_vec[],
     const uint8_t *peer_key = in_vec[1].base;
     size_t peer_key_length = in_vec[1].len;
     mbedtls_svc_key_id_t encoded_key;
-    psa_status_t status;
+
+    psa_status_t status = tfm_crypto_check_handle_owner(private_key);
+
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
 
     status = tfm_crypto_encode_id_and_owner(private_key, &encoded_key);
     if (status != PSA_SUCCESS) {
diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_mac.c b/lib/tf-m/secure_fw/partitions/crypto/crypto_mac.c
index 4c9ba2d28..011a3ce6e 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_mac.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_mac.c
@@ -44,6 +44,11 @@ psa_status_t tfm_crypto_mac_sign_setup(psa_invec in_vec[],
     psa_algorithm_t alg = iov->alg;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     /* Init the handle in the operation with the one passed from the iov */
     *handle_out = iov->op_handle;
 
@@ -100,6 +105,11 @@ psa_status_t tfm_crypto_mac_verify_setup(psa_invec in_vec[],
     psa_algorithm_t alg = iov->alg;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     /* Init the handle in the operation with the one passed from the iov */
     *handle_out = iov->op_handle;
 
@@ -330,6 +340,11 @@ psa_status_t tfm_crypto_mac_compute(psa_invec in_vec[],
     size_t mac_size = out_vec[0].len;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
     if (status != PSA_SUCCESS) {
         return status;
@@ -364,6 +379,11 @@ psa_status_t tfm_crypto_mac_verify(psa_invec in_vec[],
     size_t mac_length = in_vec[2].len;
     mbedtls_svc_key_id_t encoded_key;
 
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
     status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
     if (status != PSA_SUCCESS) {
         return status;
diff --git a/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto.yaml b/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto.yaml
index 980849a03..740745f0b 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto.yaml
+++ b/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto.yaml
@@ -482,6 +482,9 @@
     },
   ],
   "dependencies": [
-    "TFM_INTERNAL_TRUSTED_STORAGE_SERVICE"
+    "TFM_ITS_SET",
+    "TFM_ITS_GET",
+    "TFM_ITS_GET_INFO",
+    "TFM_ITS_REMOVE",
   ]
 }
diff --git a/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto_api.h b/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto_api.h
index cfdf7478f..ff1d17b56 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto_api.h
+++ b/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto_api.h
@@ -95,6 +95,37 @@ psa_status_t tfm_crypto_key_attributes_to_client(
                         const psa_key_attributes_t *key_attributes,
                         struct psa_client_key_attributes_s *client_key_attr);
 
+/**
+ * \brief Checks that the requested handle belongs to the requesting
+ *        partition
+ *
+ * \param[in]  key    key given as input
+ *
+ * \return Return values as described in \ref psa_status_t
+ */
+psa_status_t tfm_crypto_check_handle_owner(psa_key_id_t key);
+
+/**
+ * \brief Checks that there is enough local storage in RAM to keep another key,
+ *        and returns the index of the storage to use.
+ *
+ * \param[out] index  Index of the local storage to use
+ *
+ * \return Return values as described in \ref psa_status_t
+ */
+psa_status_t tfm_crypto_check_key_storage(uint32_t *index);
+
+/**
+ * \brief Sets the index of the local storage in use with a key requested by the
+ *        calling partition, and stores the corresponding key_handle.
+ *
+ * \param[in] index       Index of the local storage to use
+ * \param[in] key_handle  Corresponding key handle to associate
+ *
+ * \return Return values as described in \ref psa_status_t
+ */
+psa_status_t tfm_crypto_set_key_storage(uint32_t index,
+                                        psa_key_id_t key_handle);
 /**
  * \brief Allocate an operation context in the backend
  *
diff --git a/lib/tf-m/secure_fw/partitions/firmware_update/bootloader/mcuboot/tfm_mcuboot_fwu.c b/lib/tf-m/secure_fw/partitions/firmware_update/bootloader/mcuboot/tfm_mcuboot_fwu.c
index 9ef53385b..3260ec2e6 100644
--- a/lib/tf-m/secure_fw/partitions/firmware_update/bootloader/mcuboot/tfm_mcuboot_fwu.c
+++ b/lib/tf-m/secure_fw/partitions/firmware_update/bootloader/mcuboot/tfm_mcuboot_fwu.c
@@ -483,8 +483,8 @@ psa_status_t fwu_bootloader_mark_image_accepted(
     }
 #else
     (void)bootloader_image_id;
-#endif
     return PSA_SUCCESS;
+#endif
 }
 
 psa_status_t fwu_bootloader_abort(bl_image_id_t bootloader_image_id)
diff --git a/lib/tf-m/secure_fw/partitions/idle_partition/load_info_idle_sp.c b/lib/tf-m/secure_fw/partitions/idle_partition/load_info_idle_sp.c
index d87db7be7..0f9dd6f91 100644
--- a/lib/tf-m/secure_fw/partitions/idle_partition/load_info_idle_sp.c
+++ b/lib/tf-m/secure_fw/partitions/idle_partition/load_info_idle_sp.c
@@ -8,6 +8,7 @@
 #include <stdint.h>
 #include <stddef.h>
 #include "spm_ipc.h"
+#include "spm_partition_defs.h"
 #include "load/partition_defs.h"
 #include "load/service_defs.h"
 #include "load/asset_defs.h"
@@ -28,16 +29,12 @@ extern void tfm_idle_thread(void);
 uint8_t idle_sp_stack[IDLE_SP_STACK_SIZE] __attribute__((aligned(8)));
 
 /* Partition load, deps, service load data. Put to a dedicated section. */
-#if defined(__ICCARM__)
-#pragma location = ".part_load"
-__root
-#endif
 const struct partition_tfm_sp_idle_load_info_t
     tfm_sp_idle_load __attribute__((used, section(".part_load"))) = {
     .load_info = {
         .psa_ff_ver                 = 0x0101 | PARTITION_INFO_MAGIC,
         .pid                        = TFM_SP_IDLE_ID,
-        .flags                      = PARTITION_PRI_LOWEST | PARTITION_MODEL_IPC
+        .flags                      = PARTITION_PRI_LOWEST | SPM_PART_FLAG_IPC
                                       | SPM_PART_FLAG_PSA_ROT,
         .entry                      = ENTRY_TO_POSITION(tfm_idle_thread),
         .stack_size                 = IDLE_SP_STACK_SIZE,
@@ -51,9 +48,5 @@ const struct partition_tfm_sp_idle_load_info_t
 };
 
 /* Placeholder for partition runtime space. Do not reference it. */
-#if defined(__ICCARM__)
-#pragma location = ".bss.part_runtime"
-__root
-#endif
 static struct partition_t tfm_idle_partition_runtime_item
     __attribute__((used, section(".bss.part_runtime")));
diff --git a/lib/tf-m/secure_fw/partitions/initial_attestation/attest_core.c b/lib/tf-m/secure_fw/partitions/initial_attestation/attest_core.c
index 511084b45..9d7558c1c 100644
--- a/lib/tf-m/secure_fw/partitions/initial_attestation/attest_core.c
+++ b/lib/tf-m/secure_fw/partitions/initial_attestation/attest_core.c
@@ -545,19 +545,15 @@ attest_add_verification_service(struct attest_token_encode_ctx *token_ctx)
 {
     struct q_useful_buf_c service;
     uint32_t size;
-    uint8_t buf[VERIFCATION_URL_MAX_SIZE];
-    enum tfm_plat_err_t err;
 
-    err = tfm_attest_hal_get_verification_service(&size, buf);
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        return PSA_ATTEST_ERR_GENERAL;
-    }
+    service.ptr = tfm_attest_hal_get_verification_service(&size);
 
-    service.ptr = &buf;
-    service.len = size;
-    attest_token_encode_add_tstr(token_ctx,
-                                 EAT_CBOR_ARM_LABEL_ORIGINATION,
-                                 &service);
+    if (service.ptr) {
+        service.len = size;
+        attest_token_encode_add_tstr(token_ctx,
+                                     EAT_CBOR_ARM_LABEL_ORIGINATION,
+                                     &service);
+    }
 
     return PSA_ATTEST_ERR_SUCCESS;
 }
@@ -574,19 +570,15 @@ attest_add_profile_definition(struct attest_token_encode_ctx *token_ctx)
 {
     struct q_useful_buf_c profile;
     uint32_t size;
-    uint8_t buf[PROFILE_DEFINITION_MAX_SIZE];
-    enum tfm_plat_err_t err;
 
-    err = tfm_attest_hal_get_profile_definition(&size, buf);
-    if (err != TFM_PLAT_ERR_SUCCESS) {
-        return PSA_ATTEST_ERR_GENERAL;
-    }
+    profile.ptr = tfm_attest_hal_get_profile_definition(&size);
 
-    profile.ptr = &buf;
-    profile.len = size;
-    attest_token_encode_add_tstr(token_ctx,
-                                 EAT_CBOR_ARM_LABEL_PROFILE_DEFINITION,
-                                 &profile);
+    if (profile.ptr) {
+        profile.len = size;
+        attest_token_encode_add_tstr(token_ctx,
+                                     EAT_CBOR_ARM_LABEL_PROFILE_DEFINITION,
+                                     &profile);
+    }
 
     return PSA_ATTEST_ERR_SUCCESS;
 }
diff --git a/lib/tf-m/secure_fw/partitions/initial_attestation/tfm_attest_req_mngr.c b/lib/tf-m/secure_fw/partitions/initial_attestation/tfm_attest_req_mngr.c
index d33db1544..dc14e4143 100644
--- a/lib/tf-m/secure_fw/partitions/initial_attestation/tfm_attest_req_mngr.c
+++ b/lib/tf-m/secure_fw/partitions/initial_attestation/tfm_attest_req_mngr.c
@@ -16,7 +16,6 @@
 #include "psa/service.h"
 #include "psa_manifest/tfm_initial_attestation.h"
 #include "region_defs.h"
-#include "tfm_attest_defs.h"
 
 #define ECC_P256_PUBLIC_KEY_SIZE PSA_KEY_EXPORT_ECC_PUBLIC_KEY_MAX_SIZE(256)
 
@@ -109,21 +108,23 @@ static void tfm_abort(void)
         ;
 }
 
-static void attest_signal_handle(psa_signal_t signal)
+static void attest_signal_handle(psa_signal_t signal, attest_func_t pfn)
 {
     psa_msg_t msg;
     psa_status_t status;
 
     status = psa_get(signal, &msg);
     switch (msg.type) {
-    case TFM_ATTEST_GET_TOKEN:
-        status = psa_attest_get_token(&msg);
-        psa_reply(msg.handle, status);
+    case PSA_IPC_CONNECT:
+        psa_reply(msg.handle, PSA_SUCCESS);
         break;
-    case TFM_ATTEST_GET_TOKEN_SIZE:
-        status = psa_attest_get_token_size(&msg);
+    case PSA_IPC_CALL:
+        status = (psa_status_t)pfn(&msg);
         psa_reply(msg.handle, status);
         break;
+    case PSA_IPC_DISCONNECT:
+        psa_reply(msg.handle, PSA_SUCCESS);
+        break;
     default:
         tfm_abort();
     }
@@ -142,8 +143,12 @@ psa_status_t attest_partition_init(void)
 
     while (1) {
         signals = psa_wait(PSA_WAIT_ANY, PSA_BLOCK);
-        if (signals & TFM_ATTESTATION_SERVICE_SIGNAL) {
-            attest_signal_handle(TFM_ATTESTATION_SERVICE_SIGNAL);
+        if (signals & TFM_ATTEST_GET_TOKEN_SIGNAL) {
+            attest_signal_handle(TFM_ATTEST_GET_TOKEN_SIGNAL,
+                                 psa_attest_get_token);
+        } else if (signals & TFM_ATTEST_GET_TOKEN_SIZE_SIGNAL) {
+            attest_signal_handle(TFM_ATTEST_GET_TOKEN_SIZE_SIGNAL,
+                                 psa_attest_get_token_size);
         } else {
             tfm_abort();
         }
diff --git a/lib/tf-m/secure_fw/partitions/initial_attestation/tfm_attest_secure_api.c b/lib/tf-m/secure_fw/partitions/initial_attestation/tfm_attest_secure_api.c
index 1e8c64262..ab32645de 100644
--- a/lib/tf-m/secure_fw/partitions/initial_attestation/tfm_attest_secure_api.c
+++ b/lib/tf-m/secure_fw/partitions/initial_attestation/tfm_attest_secure_api.c
@@ -12,7 +12,6 @@
 #ifdef TFM_PSA_API
 #include "psa/client.h"
 #include "psa_manifest/sid.h"
-#include "tfm_attest_defs.h"
 #else
 #include "tfm_veneers.h"
 #endif
@@ -34,12 +33,18 @@ psa_initial_attest_get_token(const uint8_t *auth_challenge,
     };
 
 #ifdef TFM_PSA_API
+    psa_handle_t handle = PSA_NULL_HANDLE;
+    handle = psa_connect(TFM_ATTEST_GET_TOKEN_SID,
+                         TFM_ATTEST_GET_TOKEN_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_HANDLE_TO_ERROR(handle);
+    }
 
-    status = psa_call(TFM_ATTESTATION_SERVICE_HANDLE, TFM_ATTEST_GET_TOKEN,
+    status = psa_call(handle, PSA_IPC_CALL,
                       in_vec, IOVEC_LEN(in_vec),
                       out_vec, IOVEC_LEN(out_vec));
+    psa_close(handle);
 #else
-
     status = tfm_initial_attest_get_token_veneer(in_vec, IOVEC_LEN(in_vec),
                                                  out_vec, IOVEC_LEN(out_vec));
 #endif
@@ -63,10 +68,17 @@ psa_initial_attest_get_token_size(size_t challenge_size,
     };
 
 #ifdef TFM_PSA_API
+    psa_handle_t handle = PSA_NULL_HANDLE;
+    handle = psa_connect(TFM_ATTEST_GET_TOKEN_SIZE_SID,
+                         TFM_ATTEST_GET_TOKEN_SIZE_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_HANDLE_TO_ERROR(handle);
+    }
 
-    status = psa_call(TFM_ATTESTATION_SERVICE_HANDLE, TFM_ATTEST_GET_TOKEN_SIZE,
+    status = psa_call(handle, PSA_IPC_CALL,
                       in_vec, IOVEC_LEN(in_vec),
                       out_vec, IOVEC_LEN(out_vec));
+    psa_close(handle);
 #else
 
     status = tfm_initial_attest_get_token_size_veneer(in_vec, IOVEC_LEN(in_vec),
diff --git a/lib/tf-m/secure_fw/partitions/initial_attestation/tfm_initial_attestation.yaml b/lib/tf-m/secure_fw/partitions/initial_attestation/tfm_initial_attestation.yaml
index 9bb716db7..d50bb80ed 100644
--- a/lib/tf-m/secure_fw/partitions/initial_attestation/tfm_initial_attestation.yaml
+++ b/lib/tf-m/secure_fw/partitions/initial_attestation/tfm_initial_attestation.yaml
@@ -6,11 +6,10 @@
 #-------------------------------------------------------------------------------
 
 {
-  "psa_framework_version": 1.1,
+  "psa_framework_version": 1.0,
   "name": "TFM_SP_INITIAL_ATTESTATION",
   "type": "PSA-ROT",
   "priority": "NORMAL",
-  "model": "IPC",
   "entry_point": "attest_partition_init",
   "stack_size": "0x0A80",
   "secure_functions": [
@@ -33,14 +32,19 @@
   ],
   "services": [
     {
-      "name": "TFM_ATTESTATION_SERVICE",
+      "name": "TFM_ATTEST_GET_TOKEN",
       "sid": "0x00000020",
       "non_secure_clients": true,
-      "connection_based": false,
-      "stateless_handle": 4,
       "version": 1,
       "version_policy": "STRICT"
-    }
+    },
+    {
+      "name": "TFM_ATTEST_GET_TOKEN_SIZE",
+      "sid": "0x00000021",
+      "non_secure_clients": true,
+      "version": 1,
+      "version_policy": "STRICT"
+    },
   ],
   "dependencies": [
     "TFM_CRYPTO"
diff --git a/lib/tf-m/secure_fw/partitions/internal_trusted_storage/tfm_internal_trusted_storage.yaml b/lib/tf-m/secure_fw/partitions/internal_trusted_storage/tfm_internal_trusted_storage.yaml
index 59073700f..3af1aefb2 100644
--- a/lib/tf-m/secure_fw/partitions/internal_trusted_storage/tfm_internal_trusted_storage.yaml
+++ b/lib/tf-m/secure_fw/partitions/internal_trusted_storage/tfm_internal_trusted_storage.yaml
@@ -1,16 +1,15 @@
 #-------------------------------------------------------------------------------
-# Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+# Copyright (c) 2019-2020, Arm Limited. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
 #-------------------------------------------------------------------------------
 
 {
-  "psa_framework_version": 1.1,
+  "psa_framework_version": 1.0,
   "name": "TFM_SP_ITS",
   "type": "PSA-ROT",
   "priority": "NORMAL",
-  "model": "IPC",
   "entry_point": "tfm_its_req_mngr_init",
   "stack_size": "0x680",
   "secure_functions": [
@@ -43,15 +42,33 @@
       "version_policy": "STRICT"
     }
   ],
-  "services" : [
-    {
-      "name": "TFM_INTERNAL_TRUSTED_STORAGE_SERVICE",
-      "sid": "0x00000070",
-      "non_secure_clients": true,
-      "connection_based": false,
-      "stateless_handle": 3,
-      "version": 1,
-      "version_policy": "STRICT"
-    }
+  "services" : [{
+    "name": "TFM_ITS_SET",
+    "sid": "0x00000070",
+    "non_secure_clients": true,
+    "version": 1,
+    "version_policy": "STRICT"
+   },
+   {
+    "name": "TFM_ITS_GET",
+    "sid": "0x00000071",
+    "non_secure_clients": true,
+    "version": 1,
+    "version_policy": "STRICT"
+   },
+   {
+    "name": "TFM_ITS_GET_INFO",
+    "sid": "0x00000072",
+    "non_secure_clients": true,
+    "version": 1,
+    "version_policy": "STRICT"
+   },
+   {
+    "name": "TFM_ITS_REMOVE",
+    "sid": "0x00000073",
+    "non_secure_clients": true,
+    "version": 1,
+    "version_policy": "STRICT"
+   }
   ]
 }
diff --git a/lib/tf-m/secure_fw/partitions/internal_trusted_storage/tfm_its_req_mngr.c b/lib/tf-m/secure_fw/partitions/internal_trusted_storage/tfm_its_req_mngr.c
index 1c053317c..e844a5d1d 100644
--- a/lib/tf-m/secure_fw/partitions/internal_trusted_storage/tfm_its_req_mngr.c
+++ b/lib/tf-m/secure_fw/partitions/internal_trusted_storage/tfm_its_req_mngr.c
@@ -16,7 +16,6 @@
 #ifdef TFM_PSA_API
 #include "psa/service.h"
 #include "psa_manifest/tfm_internal_trusted_storage.h"
-#include "tfm_its_defs.h"
 #else
 #include <stdbool.h>
 #include "tfm_secure_api.h"
@@ -285,7 +284,7 @@ static psa_status_t tfm_its_remove_ipc(void)
     return tfm_its_remove(msg.client_id, uid);
 }
 
-static void its_signal_handle(psa_signal_t signal)
+static void its_signal_handle(psa_signal_t signal, its_func_t pfn)
 {
     psa_status_t status;
 
@@ -295,21 +294,15 @@ static void its_signal_handle(psa_signal_t signal)
     }
 
     switch (msg.type) {
-    case TFM_ITS_SET:
-        status = tfm_its_set_ipc();
-        psa_reply(msg.handle, status);
-        break;
-    case TFM_ITS_GET:
-        status = tfm_its_get_ipc();
-        psa_reply(msg.handle, status);
+    case PSA_IPC_CONNECT:
+        psa_reply(msg.handle, PSA_SUCCESS);
         break;
-    case TFM_ITS_GET_INFO:
-        status = tfm_its_get_info_ipc();
+    case PSA_IPC_CALL:
+        status = pfn();
         psa_reply(msg.handle, status);
         break;
-    case TFM_ITS_REMOVE:
-        status = tfm_its_remove_ipc();
-        psa_reply(msg.handle, status);
+    case PSA_IPC_DISCONNECT:
+        psa_reply(msg.handle, PSA_SUCCESS);
         break;
     default:
         psa_panic();
@@ -328,8 +321,14 @@ psa_status_t tfm_its_req_mngr_init(void)
 
     while (1) {
         signals = psa_wait(PSA_WAIT_ANY, PSA_BLOCK);
-        if (signals & TFM_INTERNAL_TRUSTED_STORAGE_SERVICE_SIGNAL) {
-            its_signal_handle(TFM_INTERNAL_TRUSTED_STORAGE_SERVICE_SIGNAL);
+        if (signals & TFM_ITS_SET_SIGNAL) {
+            its_signal_handle(TFM_ITS_SET_SIGNAL, tfm_its_set_ipc);
+        } else if (signals & TFM_ITS_GET_SIGNAL) {
+            its_signal_handle(TFM_ITS_GET_SIGNAL, tfm_its_get_ipc);
+        } else if (signals & TFM_ITS_GET_INFO_SIGNAL) {
+            its_signal_handle(TFM_ITS_GET_INFO_SIGNAL, tfm_its_get_info_ipc);
+        } else if (signals & TFM_ITS_REMOVE_SIGNAL) {
+            its_signal_handle(TFM_ITS_REMOVE_SIGNAL, tfm_its_remove_ipc);
         } else {
             psa_panic();
         }
diff --git a/lib/tf-m/secure_fw/partitions/internal_trusted_storage/tfm_its_secure_api.c b/lib/tf-m/secure_fw/partitions/internal_trusted_storage/tfm_its_secure_api.c
index cbe7270ab..491d16de2 100644
--- a/lib/tf-m/secure_fw/partitions/internal_trusted_storage/tfm_its_secure_api.c
+++ b/lib/tf-m/secure_fw/partitions/internal_trusted_storage/tfm_its_secure_api.c
@@ -12,7 +12,6 @@
 #ifdef TFM_PSA_API
 #include "psa/client.h"
 #include "psa_manifest/sid.h"
-#include "tfm_its_defs.h"
 #else
 #include "tfm_veneers.h"
 #endif
@@ -23,6 +22,9 @@ psa_status_t psa_its_set(psa_storage_uid_t uid,
                          psa_storage_create_flags_t create_flags)
 {
     psa_status_t status;
+#ifdef TFM_PSA_API
+    psa_handle_t handle;
+#endif
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) },
@@ -31,10 +33,14 @@ psa_status_t psa_its_set(psa_storage_uid_t uid,
     };
 
 #ifdef TFM_PSA_API
+    handle = psa_connect(TFM_ITS_SET_SID, TFM_ITS_SET_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
 
-    status = psa_call(TFM_INTERNAL_TRUSTED_STORAGE_SERVICE_HANDLE, TFM_ITS_SET,
-                      in_vec, IOVEC_LEN(in_vec), NULL, 0);
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), NULL, 0);
 
+    psa_close(handle);
 #else
     status = tfm_its_set_req_veneer(in_vec, IOVEC_LEN(in_vec), NULL, 0);
 
@@ -59,6 +65,9 @@ psa_status_t psa_its_get(psa_storage_uid_t uid,
                          size_t *p_data_length)
 {
     psa_status_t status;
+#ifdef TFM_PSA_API
+    psa_handle_t handle;
+#endif
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) },
@@ -74,10 +83,15 @@ psa_status_t psa_its_get(psa_storage_uid_t uid,
     }
 
 #ifdef TFM_PSA_API
+    handle = psa_connect(TFM_ITS_GET_SID, TFM_ITS_GET_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
 
-    status = psa_call(TFM_INTERNAL_TRUSTED_STORAGE_SERVICE_HANDLE, TFM_ITS_GET,
-                      in_vec, IOVEC_LEN(in_vec), out_vec, IOVEC_LEN(out_vec));
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
+                      IOVEC_LEN(out_vec));
 
+    psa_close(handle);
 #else
     status = tfm_its_get_req_veneer(in_vec, IOVEC_LEN(in_vec),
                                     out_vec, IOVEC_LEN(out_vec));
@@ -102,6 +116,9 @@ psa_status_t psa_its_get_info(psa_storage_uid_t uid,
                               struct psa_storage_info_t *p_info)
 {
     psa_status_t status;
+#ifdef TFM_PSA_API
+    psa_handle_t handle;
+#endif
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) }
@@ -112,11 +129,15 @@ psa_status_t psa_its_get_info(psa_storage_uid_t uid,
     };
 
 #ifdef TFM_PSA_API
+    handle = psa_connect(TFM_ITS_GET_INFO_SID, TFM_ITS_GET_INFO_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
 
-    status = psa_call(TFM_INTERNAL_TRUSTED_STORAGE_SERVICE_HANDLE,
-                      TFM_ITS_GET_INFO, in_vec, IOVEC_LEN(in_vec), out_vec,
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
                       IOVEC_LEN(out_vec));
 
+    psa_close(handle);
 #else
     status = tfm_its_get_info_req_veneer(in_vec, IOVEC_LEN(in_vec),
                                          out_vec, IOVEC_LEN(out_vec));
@@ -137,15 +158,23 @@ psa_status_t psa_its_get_info(psa_storage_uid_t uid,
 psa_status_t psa_its_remove(psa_storage_uid_t uid)
 {
     psa_status_t status;
+#ifdef TFM_PSA_API
+    psa_handle_t handle;
+#endif
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) }
     };
 
 #ifdef TFM_PSA_API
+    handle = psa_connect(TFM_ITS_REMOVE_SID, TFM_ITS_REMOVE_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), NULL, 0);
 
-    status = psa_call(TFM_INTERNAL_TRUSTED_STORAGE_SERVICE_HANDLE,
-                      TFM_ITS_REMOVE, in_vec, IOVEC_LEN(in_vec), NULL, 0);
+    psa_close(handle);
 
 #else
     status = tfm_its_remove_req_veneer(in_vec, IOVEC_LEN(in_vec), NULL, 0);
diff --git a/lib/tf-m/secure_fw/partitions/platform/platform_sp.c b/lib/tf-m/secure_fw/partitions/platform/platform_sp.c
index cf0010eb5..70fbf1a44 100644
--- a/lib/tf-m/secure_fw/partitions/platform/platform_sp.c
+++ b/lib/tf-m/secure_fw/partitions/platform/platform_sp.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -9,6 +9,7 @@
 
 #include "tfm_platform_system.h"
 #include "tfm_plat_nv_counters.h"
+#include "tfm/tfm_spm_services.h"
 #include "tfm_secure_api.h"
 #include "psa_manifest/pid.h"
 
@@ -17,9 +18,9 @@
 
 /* Access map using NVCOUNTER_IDX -> tfm_partition-id key-value pairs */
 static const int32_t nv_counter_access_map[NV_COUNTER_MAP_SIZE] = {
-                                          [PLAT_NV_COUNTER_PS_0] = TFM_SP_PS,
-                                          [PLAT_NV_COUNTER_PS_1] = TFM_SP_PS,
-                                          [PLAT_NV_COUNTER_PS_2] = TFM_SP_PS
+                                          [PLAT_NV_COUNTER_0] = TFM_SP_PS,
+                                          [PLAT_NV_COUNTER_1] = TFM_SP_PS,
+                                          [PLAT_NV_COUNTER_2] = TFM_SP_PS
               };
 
 #ifdef TFM_PSA_API
@@ -66,6 +67,12 @@ static bool nv_counter_access_grant(int32_t client_id,
 
 enum tfm_platform_err_t platform_sp_system_reset(void)
 {
+    /* Check if SPM allows the system reset */
+
+    if (tfm_spm_request_reset_vote() != 0) {
+        return TFM_PLATFORM_ERR_SYSTEM_ERROR;
+    }
+
     /* FIXME: The system reset functionality is only supported in isolation
      *        level 1.
      */
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.c b/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.c
index 0c9a2d7c6..1015fae2d 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.c
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.c
@@ -117,7 +117,7 @@ void ps_crypto_set_iv(const union ps_crypto_t *crypto)
     (void)tfm_memcpy(ps_crypto_iv_buf, crypto->ref.iv, PS_IV_LEN_BYTES);
 }
 
-psa_status_t ps_crypto_get_iv(union ps_crypto_t *crypto)
+void ps_crypto_get_iv(union ps_crypto_t *crypto)
 {
     /* IV characteristic is algorithm dependent.
      * For GCM it is essential that it doesn't get repeated.
@@ -150,16 +150,6 @@ psa_status_t ps_crypto_get_iv(union ps_crypto_t *crypto)
     /* If overflow, increment the MSBs */
     if (iv_l == 0) {
         iv_h++;
-
-        /* If overflow, return error. Different IV should be used. */
-        if (iv_h == 0) {
-            /* Reset iv_l and iv_h to the value before increasement. Otherwise,
-             * iv_l will start from '1' the next time this function is called.
-             */
-            iv_l--;
-            iv_h--;
-            return PSA_ERROR_GENERIC_ERROR;
-        }
     }
 
     /* Update the local buffer */
@@ -167,8 +157,6 @@ psa_status_t ps_crypto_get_iv(union ps_crypto_t *crypto)
     (void)tfm_memcpy((ps_crypto_iv_buf + sizeof(iv_l)), &iv_h, sizeof(iv_h));
     /* Update the caller buffer */
     (void)tfm_memcpy(crypto->ref.iv, ps_crypto_iv_buf, PS_IV_LEN_BYTES);
-
-    return PSA_SUCCESS;
 }
 
 psa_status_t ps_crypto_encrypt_and_tag(union ps_crypto_t *crypto,
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.h b/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.h
index a4dfd5bd9..d9fe96f96 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.h
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -20,6 +20,10 @@ extern "C" {
 #define PS_KEY_LEN_BYTES  16
 #define PS_TAG_LEN_BYTES  16
 #define PS_IV_LEN_BYTES   12
+/* The key label consists of the uid + client_id, thus the length of it is:
+ * sizeof(psa_storage_uid_t) + sizeof(int32_t).
+ */
+#define PS_KEY_LABEL_LEN_BYTES 12
 
 /* Union containing crypto policy implementations. The ref member provides the
  * reference implementation. Further members can be added to the union to
@@ -27,10 +31,9 @@ extern "C" {
  */
 union ps_crypto_t {
     struct {
+        uint8_t key_label[PS_KEY_LABEL_LEN_BYTES]; /*!< Key label value */
         uint8_t tag[PS_TAG_LEN_BYTES]; /*!< MAC value of AEAD object */
         uint8_t iv[PS_IV_LEN_BYTES];   /*!< IV value of AEAD object */
-        psa_storage_uid_t uid;         /*!< UID for key label */
-        int32_t client_id;             /*!< Owner client ID for key label */
     } ref;
 };
 
@@ -141,10 +144,8 @@ void ps_crypto_set_iv(const union ps_crypto_t *crypto);
  * \brief Gets a new IV value into the crypto union.
  *
  * \param[out] crypto  Pointer to the crypto union
- *
- * \return Returns values as described in \ref psa_status_t
  */
-psa_status_t ps_crypto_get_iv(union ps_crypto_t *crypto);
+void ps_crypto_get_iv(union ps_crypto_t *crypto);
 
 #ifdef __cplusplus
 }
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/nv_counters/ps_nv_counters.h b/lib/tf-m/secure_fw/partitions/protected_storage/nv_counters/ps_nv_counters.h
index 4e5fb59e2..df3203483 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/nv_counters/ps_nv_counters.h
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/nv_counters/ps_nv_counters.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -20,9 +20,9 @@
 #include "psa/protected_storage.h"
 #include "tfm_plat_nv_counters.h"
 
-#define TFM_PS_NV_COUNTER_1        PLAT_NV_COUNTER_PS_0
-#define TFM_PS_NV_COUNTER_2        PLAT_NV_COUNTER_PS_1
-#define TFM_PS_NV_COUNTER_3        PLAT_NV_COUNTER_PS_2
+#define TFM_PS_NV_COUNTER_1        PLAT_NV_COUNTER_0
+#define TFM_PS_NV_COUNTER_2        PLAT_NV_COUNTER_1
+#define TFM_PS_NV_COUNTER_3        PLAT_NV_COUNTER_2
 
 #define PS_NV_COUNTER_SIZE         4 /* In bytes */
 
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/ps_encrypted_object.c b/lib/tf-m/secure_fw/partitions/protected_storage/ps_encrypted_object.c
index b1e9ffb12..41a725bb4 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/ps_encrypted_object.c
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/ps_encrypted_object.c
@@ -34,23 +34,6 @@
 
 static uint8_t ps_crypto_buf[PS_CRYPTO_BUF_LEN];
 
-static psa_status_t fill_key_label(struct ps_object_t *obj, size_t *length)
-{
-    psa_storage_uid_t uid = obj->header.crypto.ref.uid;
-    int32_t client_id = obj->header.crypto.ref.client_id;
-
-    if (PS_CRYPTO_BUF_LEN < (sizeof(client_id) + sizeof(uid))) {
-        return PSA_ERROR_BUFFER_TOO_SMALL;
-    }
-
-    tfm_memcpy(ps_crypto_buf, &client_id, sizeof(client_id));
-    tfm_memcpy(ps_crypto_buf + sizeof(client_id), &uid, sizeof(uid));
-
-    *length = sizeof(client_id) + sizeof(uid);
-
-    return PSA_SUCCESS;
-}
-
 /**
  * \brief Performs authenticated decryption on object data, with the header as
  *        the associated data.
@@ -70,14 +53,10 @@ static psa_status_t ps_object_auth_decrypt(uint32_t fid,
 {
     psa_status_t err;
     uint8_t *p_obj_data = (uint8_t *)&obj->header.info;
-    size_t out_len, label_length;
-
-    err = fill_key_label(obj, &label_length);
-    if (err != PSA_SUCCESS) {
-        return err;
-    }
+    size_t out_len;
 
-    err = ps_crypto_setkey(ps_crypto_buf, label_length);
+    err = ps_crypto_setkey(obj->header.crypto.ref.key_label,
+                           sizeof(obj->header.crypto.ref.key_label));
     if (err != PSA_SUCCESS) {
         return err;
     }
@@ -122,23 +101,17 @@ static psa_status_t ps_object_auth_encrypt(uint32_t fid,
 {
     psa_status_t err;
     uint8_t *p_obj_data = (uint8_t *)&obj->header.info;
-    size_t out_len, label_length;
-
-    err = fill_key_label(obj, &label_length);
-    if (err != PSA_SUCCESS) {
-        return err;
-    }
+    size_t out_len;
 
-    err = ps_crypto_setkey(ps_crypto_buf, label_length);
+    err = ps_crypto_setkey(obj->header.crypto.ref.key_label,
+                           sizeof(obj->header.crypto.ref.key_label));
     if (err != PSA_SUCCESS) {
         return err;
     }
 
+    /* FIXME: should have an IV per object with key diversification */
     /* Get a new IV for each encryption */
-    err = ps_crypto_get_iv(&obj->header.crypto);
-    if (err != PSA_SUCCESS) {
-        return err;
-    }
+    ps_crypto_get_iv(&obj->header.crypto);
 
     /* Use File ID as a part of the associated data to authenticate
      * the object in the FS. The tag will be stored in the object table and
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_system.c b/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_system.c
index 5cdcc718c..67ef44275 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_system.c
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_system.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -188,9 +188,13 @@ psa_status_t ps_object_read(psa_storage_uid_t uid, int32_t client_id,
 
     /* Read object */
 #ifdef PS_ENCRYPTION
-    g_ps_object.header.crypto.ref.uid = uid;
-    g_ps_object.header.crypto.ref.client_id = client_id;
-
+    err = ps_utils_fill_key_label(uid,
+                                  client_id,
+                                  g_ps_object.header.crypto.ref.key_label,
+                                  sizeof(g_ps_object.header.crypto.ref.key_label));
+    if (err != PSA_SUCCESS) {
+        goto clear_data_and_return;
+    }
     err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 #else
     /* Read object header */
@@ -246,8 +250,13 @@ psa_status_t ps_object_create(psa_storage_uid_t uid, int32_t client_id,
     if (err == PSA_SUCCESS) {
 #ifdef PS_ENCRYPTION
         /* Read the object */
-        g_ps_object.header.crypto.ref.uid = uid;
-        g_ps_object.header.crypto.ref.client_id = client_id;
+        err = ps_utils_fill_key_label(uid,
+                                      client_id,
+                                      g_ps_object.header.crypto.ref.key_label,
+                                      sizeof(g_ps_object.header.crypto.ref.key_label));
+        if (err != PSA_SUCCESS) {
+            goto clear_data_and_return;
+        }
 
         err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 #else
@@ -300,8 +309,13 @@ psa_status_t ps_object_create(psa_storage_uid_t uid, int32_t client_id,
     }
 
 #ifdef PS_ENCRYPTION
-    g_ps_object.header.crypto.ref.uid = uid;
-    g_ps_object.header.crypto.ref.client_id = client_id;
+    err = ps_utils_fill_key_label(uid,
+                                  client_id,
+                                  g_ps_object.header.crypto.ref.key_label,
+                                  sizeof(g_ps_object.header.crypto.ref.key_label));
+    if (err != PSA_SUCCESS) {
+        goto clear_data_and_return;
+    }
 
     err = ps_encrypted_object_write(g_obj_tbl_info.fid, &g_ps_object);
 #else
@@ -363,8 +377,13 @@ psa_status_t ps_object_write(psa_storage_uid_t uid, int32_t client_id,
 
     /* Read the object */
 #ifdef PS_ENCRYPTION
-    g_ps_object.header.crypto.ref.uid = uid;
-    g_ps_object.header.crypto.ref.client_id = client_id;
+    err = ps_utils_fill_key_label(uid,
+                                  client_id,
+                                  g_ps_object.header.crypto.ref.key_label,
+                                  sizeof(g_ps_object.header.crypto.ref.key_label));
+    if (err != PSA_SUCCESS) {
+        goto clear_data_and_return;
+    }
 
     err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 #else
@@ -416,8 +435,13 @@ psa_status_t ps_object_write(psa_storage_uid_t uid, int32_t client_id,
     }
 
 #ifdef PS_ENCRYPTION
-    g_ps_object.header.crypto.ref.uid = uid;
-    g_ps_object.header.crypto.ref.client_id = client_id;
+    err = ps_utils_fill_key_label(uid,
+                                  client_id,
+                                  g_ps_object.header.crypto.ref.key_label,
+                                  sizeof(g_ps_object.header.crypto.ref.key_label));
+    if (err != PSA_SUCCESS) {
+        goto clear_data_and_return;
+    }
 
     err = ps_encrypted_object_write(g_obj_tbl_info.fid, &g_ps_object);
 #else
@@ -468,8 +492,13 @@ psa_status_t ps_object_get_info(psa_storage_uid_t uid, int32_t client_id,
     }
 
 #ifdef PS_ENCRYPTION
-    g_ps_object.header.crypto.ref.uid = uid;
-    g_ps_object.header.crypto.ref.client_id = client_id;
+    err = ps_utils_fill_key_label(uid,
+                                  client_id,
+                                  g_ps_object.header.crypto.ref.key_label,
+                                  sizeof(g_ps_object.header.crypto.ref.key_label));
+    if (err != PSA_SUCCESS) {
+        goto clear_data_and_return;
+    }
 
     err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 #else
@@ -504,8 +533,13 @@ psa_status_t ps_object_delete(psa_storage_uid_t uid, int32_t client_id)
     }
 
 #ifdef PS_ENCRYPTION
-    g_ps_object.header.crypto.ref.uid = uid;
-    g_ps_object.header.crypto.ref.client_id = client_id;
+    err = ps_utils_fill_key_label(uid,
+                                  client_id,
+                                  g_ps_object.header.crypto.ref.key_label,
+                                  sizeof(g_ps_object.header.crypto.ref.key_label));
+    if (err != PSA_SUCCESS) {
+        goto clear_data_and_return;
+    }
 
     err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 #else
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_table.c b/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_table.c
index 54dbf02a5..e600f9dcf 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_table.c
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_table.c
@@ -336,13 +336,9 @@ __STATIC_INLINE psa_status_t ps_object_table_nvc_generate_auth_tag(
 {
     struct ps_crypto_assoc_data_t assoc_data;
     union ps_crypto_t *crypto = &obj_table->crypto;
-    psa_status_t err;
 
     /* Get new IV */
-    err = ps_crypto_get_iv(crypto);
-    if (err != PSA_SUCCESS) {
-        return err;
-    }
+    ps_crypto_get_iv(crypto);
 
     assoc_data.nv_counter = nvc_1;
     (void)tfm_memcpy(assoc_data.obj_table_data,
@@ -464,13 +460,9 @@ __STATIC_INLINE psa_status_t ps_object_table_generate_auth_tag(
                                               struct ps_obj_table_t *obj_table)
 {
     union ps_crypto_t *crypto = &obj_table->crypto;
-    psa_status_t err;
 
     /* Get new IV */
-    err = ps_crypto_get_iv(crypto);
-    if (err != PSA_SUCCESS) {
-        return err;
-    }
+    ps_crypto_get_iv(crypto);
 
     return ps_crypto_generate_auth_tag(crypto,
                                        PS_CRYPTO_ASSOCIATED_DATA(crypto),
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.c b/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.c
index 91540e028..5f40447fe 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.c
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -27,3 +27,26 @@ psa_status_t ps_utils_check_contained_in(uint32_t superset_size,
 
     return PSA_SUCCESS;
 }
+
+#ifdef PS_ENCRYPTION
+psa_status_t ps_utils_fill_key_label(psa_storage_uid_t uid,
+                                     int32_t client_id,
+                                     uint8_t *buff,
+                                     size_t buff_len)
+{
+
+    if (buff_len < (sizeof(client_id) + sizeof(uid))) {
+        return PSA_ERROR_BUFFER_TOO_SMALL;
+    }
+
+    if (buff == NULL) {
+        return PSA_ERROR_INVALID_ARGUMENT;
+    }
+
+    tfm_memset(buff, 0x0, buff_len);
+    tfm_memcpy(buff, &client_id, sizeof(client_id));
+    tfm_memcpy(buff + sizeof(client_id), &uid, sizeof(uid));
+
+    return PSA_SUCCESS;
+}
+#endif
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.h b/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.h
index 4722ed0b4..336447886 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.h
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -62,6 +62,27 @@ psa_status_t ps_utils_check_contained_in(uint32_t superset_size,
                                          uint32_t subset_offset,
                                          uint32_t subset_size);
 
+
+#ifdef PS_ENCRYPTION
+/**
+ * \brief Fills the uint8_t buffer with the client_id and the uid
+ *
+ * \param[in]  uid            The data identifier
+ * \param[in]  client_id      Client id of the partition
+ * \param[out] buff           The output buffer
+ * \param[in]  buff_len       Length of the output buffer in bytes
+ *
+ * \retval PSA_SUCCESS                  Buffer filled successfully
+ * \retval PSA_ERROR_INVALID_ARGUMENT   The buffer pointer is NULL
+ * \retval PSA_ERROR_BUFFER_TOO_SMALL   The buffer cannot fit the client_id + uid
+ *
+ */
+psa_status_t ps_utils_fill_key_label(psa_storage_uid_t uid,
+                                     int32_t client_id,
+                                     uint8_t *buff,
+                                     size_t buff_len);
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/tfm_protected_storage.yaml b/lib/tf-m/secure_fw/partitions/protected_storage/tfm_protected_storage.yaml
index 8d71688f8..5c4e08490 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/tfm_protected_storage.yaml
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/tfm_protected_storage.yaml
@@ -1,16 +1,15 @@
 #-------------------------------------------------------------------------------
-# Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+# Copyright (c) 2018-2020, Arm Limited. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
 #-------------------------------------------------------------------------------
 
 {
-  "psa_framework_version": 1.1,
+  "psa_framework_version": 1.0,
   "name": "TFM_SP_PS",
   "type": "APPLICATION-ROT",
   "priority": "NORMAL",
-  "model": "IPC",
   "entry_point": "tfm_ps_req_mngr_init",
   "stack_size": "0x800",
   "secure_functions": [
@@ -50,20 +49,48 @@
       "version_policy": "STRICT"
     }
   ],
-  "services" : [
-    {
-      "name": "TFM_PROTECTED_STORAGE_SERVICE",
-      "sid": "0x00000060",
-      "non_secure_clients": true,
-      "connection_based": false,
-      "stateless_handle": 2,
-      "version": 1,
-      "version_policy": "STRICT"
-    }
+  "services" : [{
+    "name": "TFM_PS_SET",
+    "sid": "0x00000060",
+    "non_secure_clients": true,
+    "version": 1,
+    "version_policy": "STRICT"
+   },
+   {
+    "name": "TFM_PS_GET",
+    "sid": "0x00000061",
+    "non_secure_clients": true,
+    "version": 1,
+    "version_policy": "STRICT"
+   },
+   {
+    "name": "TFM_PS_GET_INFO",
+    "sid": "0x00000062",
+    "non_secure_clients": true,
+    "version": 1,
+    "version_policy": "STRICT"
+   },
+   {
+    "name": "TFM_PS_REMOVE",
+    "sid": "0x00000063",
+    "non_secure_clients": true,
+    "version": 1,
+    "version_policy": "STRICT"
+   },
+   {
+    "name": "TFM_PS_GET_SUPPORT",
+    "sid": "0x00000064",
+    "non_secure_clients": true,
+    "version": 1,
+    "version_policy": "STRICT"
+   }
   ],
   "dependencies": [
     "TFM_CRYPTO",
-    "TFM_INTERNAL_TRUSTED_STORAGE_SERVICE",
+    "TFM_ITS_SET",
+    "TFM_ITS_GET",
+    "TFM_ITS_GET_INFO",
+    "TFM_ITS_REMOVE",
     "TFM_SP_PLATFORM_NV_COUNTER"
   ]
 }
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/tfm_ps_req_mngr.c b/lib/tf-m/secure_fw/partitions/protected_storage/tfm_ps_req_mngr.c
index f5b20317b..5cca2807d 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/tfm_ps_req_mngr.c
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/tfm_ps_req_mngr.c
@@ -17,7 +17,6 @@
 #ifdef TFM_PSA_API
 #include "psa/service.h"
 #include "psa_manifest/tfm_protected_storage.h"
-#include "tfm_ps_defs.h"
 #endif
 
 #ifndef TFM_PSA_API
@@ -360,31 +359,21 @@ static psa_status_t tfm_ps_get_support_ipc(void)
     return PSA_SUCCESS;
 }
 
-static void ps_signal_handle(psa_signal_t signal)
+static void ps_signal_handle(psa_signal_t signal, ps_func_t pfn)
 {
     psa_status_t status;
 
     status = psa_get(signal, &msg);
     switch (msg.type) {
-    case TFM_PS_SET:
-        status = tfm_ps_set_ipc();
-        psa_reply(msg.handle, status);
-        break;
-    case TFM_PS_GET:
-        status = tfm_ps_get_ipc();
-        psa_reply(msg.handle, status);
+    case PSA_IPC_CONNECT:
+        psa_reply(msg.handle, PSA_SUCCESS);
         break;
-    case TFM_PS_GET_INFO:
-        status = tfm_ps_get_info_ipc();
+    case PSA_IPC_CALL:
+        status = pfn();
         psa_reply(msg.handle, status);
         break;
-    case TFM_PS_REMOVE:
-        status = tfm_ps_remove_ipc();
-        psa_reply(msg.handle, status);
-        break;
-    case TFM_PS_GET_SUPPORT:
-        status = tfm_ps_get_support_ipc();
-        psa_reply(msg.handle, status);
+    case PSA_IPC_DISCONNECT:
+        psa_reply(msg.handle, PSA_SUCCESS);
         break;
     default:
         psa_panic();
@@ -403,8 +392,17 @@ psa_status_t tfm_ps_req_mngr_init(void)
 
     while (1) {
         signals = psa_wait(PSA_WAIT_ANY, PSA_BLOCK);
-        if (signals & TFM_PROTECTED_STORAGE_SERVICE_SIGNAL) {
-            ps_signal_handle(TFM_PROTECTED_STORAGE_SERVICE_SIGNAL);
+        if (signals & TFM_PS_SET_SIGNAL) {
+            ps_signal_handle(TFM_PS_SET_SIGNAL, tfm_ps_set_ipc);
+        } else if (signals & TFM_PS_GET_SIGNAL) {
+            ps_signal_handle(TFM_PS_GET_SIGNAL, tfm_ps_get_ipc);
+        } else if (signals & TFM_PS_GET_INFO_SIGNAL) {
+            ps_signal_handle(TFM_PS_GET_INFO_SIGNAL, tfm_ps_get_info_ipc);
+        } else if (signals & TFM_PS_REMOVE_SIGNAL) {
+            ps_signal_handle(TFM_PS_REMOVE_SIGNAL, tfm_ps_remove_ipc);
+        } else if (signals & TFM_PS_GET_SUPPORT_SIGNAL) {
+            ps_signal_handle(TFM_PS_GET_SUPPORT_SIGNAL,
+                             tfm_ps_get_support_ipc);
         } else {
             psa_panic();
         }
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/tfm_ps_secure_api.c b/lib/tf-m/secure_fw/partitions/protected_storage/tfm_ps_secure_api.c
index bf573f5b2..0f69022cd 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/tfm_ps_secure_api.c
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/tfm_ps_secure_api.c
@@ -10,7 +10,6 @@
 #ifdef TFM_PSA_API
 #include "psa/client.h"
 #include "psa_manifest/sid.h"
-#include "tfm_ps_defs.h"
 #else
 #include "tfm_veneers.h"
 #endif
@@ -21,6 +20,9 @@ psa_status_t psa_ps_set(psa_storage_uid_t uid,
                         psa_storage_create_flags_t create_flags)
 {
     psa_status_t status;
+#ifdef TFM_PSA_API
+    psa_handle_t handle;
+#endif
 
     psa_invec in_vec[] = {
         { .base = &uid,   .len = sizeof(uid) },
@@ -29,8 +31,15 @@ psa_status_t psa_ps_set(psa_storage_uid_t uid,
     };
 
 #ifdef TFM_PSA_API
-    status = psa_call(TFM_PROTECTED_STORAGE_SERVICE_HANDLE, TFM_PS_SET, in_vec,
-                      IOVEC_LEN(in_vec), NULL, 0);
+    handle = psa_connect(TFM_PS_SET_SID, TFM_PS_SET_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec),
+                      NULL, 0);
+
+    psa_close(handle);
 
 #else
     status = tfm_ps_set_req_veneer(in_vec, IOVEC_LEN(in_vec), NULL, 0);
@@ -54,6 +63,9 @@ psa_status_t psa_ps_get(psa_storage_uid_t uid,
                         size_t *p_data_length)
 {
     psa_status_t status;
+#ifdef TFM_PSA_API
+    psa_handle_t handle;
+#endif
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) },
@@ -68,8 +80,15 @@ psa_status_t psa_ps_get(psa_storage_uid_t uid,
         return PSA_ERROR_INVALID_ARGUMENT;
     }
 #ifdef TFM_PSA_API
-    status = psa_call(TFM_PROTECTED_STORAGE_SERVICE_HANDLE, TFM_PS_GET, in_vec,
-                      IOVEC_LEN(in_vec), out_vec, IOVEC_LEN(out_vec));
+    handle = psa_connect(TFM_PS_GET_SID, TFM_PS_GET_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
+                      IOVEC_LEN(out_vec));
+
+    psa_close(handle);
 
 #else
     status = tfm_ps_get_req_veneer(in_vec, IOVEC_LEN(in_vec),
@@ -92,6 +111,9 @@ psa_status_t psa_ps_get_info(psa_storage_uid_t uid,
                              struct psa_storage_info_t *p_info)
 {
     psa_status_t status;
+#ifdef TFM_PSA_API
+    psa_handle_t handle;
+#endif
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) }
@@ -102,8 +124,15 @@ psa_status_t psa_ps_get_info(psa_storage_uid_t uid,
     };
 
 #ifdef TFM_PSA_API
-    status = psa_call(TFM_PROTECTED_STORAGE_SERVICE_HANDLE, TFM_PS_GET_INFO,
-                      in_vec, IOVEC_LEN(in_vec), out_vec, IOVEC_LEN(out_vec));
+    handle = psa_connect(TFM_PS_GET_INFO_SID, TFM_PS_GET_INFO_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
+                      IOVEC_LEN(out_vec));
+
+    psa_close(handle);
 
 #else
     status = tfm_ps_get_info_req_veneer(in_vec, IOVEC_LEN(in_vec),
@@ -119,14 +148,24 @@ psa_status_t psa_ps_get_info(psa_storage_uid_t uid,
 psa_status_t psa_ps_remove(psa_storage_uid_t uid)
 {
     psa_status_t status;
+#ifdef TFM_PSA_API
+    psa_handle_t handle;
+#endif
 
     psa_invec in_vec[] = {
         { .base = &uid, .len = sizeof(uid) }
     };
 
 #ifdef TFM_PSA_API
-    status = psa_call(TFM_PROTECTED_STORAGE_SERVICE_HANDLE, TFM_PS_REMOVE,
-                      in_vec, IOVEC_LEN(in_vec), NULL, 0);
+    handle = psa_connect(TFM_PS_REMOVE_SID, TFM_PS_REMOVE_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return PSA_ERROR_GENERIC_ERROR;
+    }
+
+    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec),
+                      NULL, 0);
+
+    psa_close(handle);
 
 #else
     status = tfm_ps_remove_req_veneer(in_vec, IOVEC_LEN(in_vec), NULL, 0);
@@ -165,6 +204,9 @@ uint32_t psa_ps_get_support(void)
      * uninitialised value in case the secure function fails.
      */
     uint32_t support_flags = 0;
+#ifdef TFM_PSA_API
+    psa_handle_t handle;
+#endif
 
     psa_outvec out_vec[] = {
         { .base = &support_flags, .len = sizeof(support_flags) }
@@ -174,8 +216,14 @@ uint32_t psa_ps_get_support(void)
      * ignored.
      */
 #ifdef TFM_PSA_API
-    (void)psa_call(TFM_PROTECTED_STORAGE_SERVICE_HANDLE, TFM_PS_GET_SUPPORT,
-                   NULL, 0, out_vec, IOVEC_LEN(out_vec));
+    handle = psa_connect(TFM_PS_GET_SUPPORT_SID, TFM_PS_GET_SUPPORT_VERSION);
+    if (!PSA_HANDLE_IS_VALID(handle)) {
+        return support_flags;
+    }
+
+    (void)psa_call(handle, PSA_IPC_CALL, NULL, 0, out_vec, IOVEC_LEN(out_vec));
+
+    psa_close(handle);
 #else
     (void)tfm_ps_get_support_req_veneer(NULL, 0, out_vec, IOVEC_LEN(out_vec));
 #endif
diff --git a/lib/tf-m/secure_fw/partitions/psa_proxy/psa_proxy.c b/lib/tf-m/secure_fw/partitions/psa_proxy/psa_proxy.c
index f175a46c3..a28afe1a4 100644
--- a/lib/tf-m/secure_fw/partitions/psa_proxy/psa_proxy.c
+++ b/lib/tf-m/secure_fw/partitions/psa_proxy/psa_proxy.c
@@ -1,6 +1,5 @@
 /*
  * Copyright (c) 2020-2021, Arm Limited. All rights reserved.
- * Copyright (c) 2021, Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -14,6 +13,7 @@
 #include "psa_manifest/sid.h"
 #include "tfm_multi_core_api.h"
 #include "tfm_ns_mailbox.h"
+#include "platform_multicore.h"
 #include "psa_proxy_shared_mem_mngr.h"
 
 #define NON_SECURE_CLIENT_ID            (-1)
@@ -43,36 +43,23 @@ static inline void deallocate_forward_handle(psa_handle_t *h)
     tfm_pool_free(forward_handle_pool, h);
 }
 
-static psa_status_t forward_message_to_secure_enclave(psa_signal_t signal,
+static psa_status_t forward_psa_call_to_secure_enclave(psa_signal_t signal,
                                                        const psa_msg_t *msg)
 {
     psa_status_t status;
     struct psa_client_params_t params;
     int32_t ret;
 
-    /* Use stateless handle for stateless services. */
-    switch (signal) {
-    case TFM_CRYPTO_SIGNAL:
+    params.psa_call_params.type = PSA_IPC_CALL;
+
+    if (signal == TFM_CRYPTO_SIGNAL) {
+        /*
+         * The TF-M crypto service has been changed to stateless service, set
+         * the params with the stateless handle.
+         */
         params.psa_call_params.handle = TFM_CRYPTO_HANDLE;
-        params.psa_call_params.type = msg->type;
-        break;
-    case TFM_PROTECTED_STORAGE_SERVICE_SIGNAL:
-        params.psa_call_params.handle = TFM_PROTECTED_STORAGE_SERVICE_HANDLE;
-        params.psa_call_params.type = msg->type;
-        break;
-    case TFM_INTERNAL_TRUSTED_STORAGE_SERVICE_SIGNAL:
-        params.psa_call_params.handle =
-                                TFM_INTERNAL_TRUSTED_STORAGE_SERVICE_HANDLE;
-        params.psa_call_params.type = msg->type;
-        break;
-    case TFM_ATTESTATION_SERVICE_SIGNAL:
-        params.psa_call_params.handle = TFM_ATTESTATION_SERVICE_HANDLE;
-        params.psa_call_params.type = msg->type;
-        break;
-    default:
+    } else {
         params.psa_call_params.handle = *((psa_handle_t *)msg->rhandle);
-        params.psa_call_params.type = PSA_IPC_CALL;
-        break;
     }
 
     status = psa_proxy_put_msg_into_shared_mem(msg, &params);
@@ -112,6 +99,34 @@ static void get_sid_and_version_for_signal(psa_signal_t signal, uint32_t *sid,
                                            uint32_t *version)
 {
     switch (signal) {
+    case TFM_CRYPTO_SIGNAL:
+        *sid = TFM_CRYPTO_SID;
+        *version = TFM_CRYPTO_VERSION;
+        break;
+    case TFM_ATTEST_GET_TOKEN_SIGNAL:
+        *sid = TFM_ATTEST_GET_TOKEN_SID;
+        *version = TFM_ATTEST_GET_TOKEN_VERSION;
+        break;
+    case TFM_ATTEST_GET_TOKEN_SIZE_SIGNAL:
+        *sid = TFM_ATTEST_GET_TOKEN_SIZE_SID;
+        *version = TFM_ATTEST_GET_TOKEN_SIZE_VERSION;
+        break;
+    case TFM_ITS_SET_SIGNAL:
+        *sid = TFM_ITS_SET_SID;
+        *version = TFM_ITS_SET_VERSION;
+        break;
+    case TFM_ITS_GET_SIGNAL:
+        *sid = TFM_ITS_GET_SID;
+        *version = TFM_ITS_GET_VERSION;
+        break;
+    case TFM_ITS_GET_INFO_SIGNAL:
+        *sid = TFM_ITS_GET_INFO_SID;
+        *version = TFM_ITS_GET_INFO_VERSION;
+        break;
+    case TFM_ITS_REMOVE_SIGNAL:
+        *sid = TFM_ITS_REMOVE_SID;
+        *version = TFM_ITS_REMOVE_VERSION;
+        break;
     case TFM_SP_PLATFORM_SYSTEM_RESET_SIGNAL:
         *sid = TFM_SP_PLATFORM_SYSTEM_RESET_SID;
         *version = TFM_SP_PLATFORM_SYSTEM_RESET_VERSION;
@@ -124,6 +139,26 @@ static void get_sid_and_version_for_signal(psa_signal_t signal, uint32_t *sid,
         *sid = TFM_SP_PLATFORM_NV_COUNTER_SID;
         *version = TFM_SP_PLATFORM_NV_COUNTER_VERSION;
         break;
+    case TFM_PS_SET_SIGNAL:
+        *sid = TFM_PS_SET_SID;
+        *version = TFM_PS_SET_VERSION;
+        break;
+    case TFM_PS_GET_SIGNAL:
+        *sid = TFM_PS_GET_SID;
+        *version = TFM_PS_GET_VERSION;
+        break;
+    case TFM_PS_GET_INFO_SIGNAL:
+        *sid = TFM_PS_GET_INFO_SID;
+        *version = TFM_PS_GET_INFO_VERSION;
+        break;
+    case TFM_PS_REMOVE_SIGNAL:
+        *sid = TFM_PS_REMOVE_SID;
+        *version = TFM_PS_REMOVE_VERSION;
+        break;
+    case TFM_PS_GET_SUPPORT_SIGNAL:
+        *sid = TFM_PS_GET_SUPPORT_SID;
+        *version = TFM_PS_GET_SUPPORT_VERSION;
+        break;
     default:
         psa_panic();
         break;
@@ -175,13 +210,16 @@ static void handle_signal(psa_signal_t signal)
         status = psa_connect_to_secure_enclave(signal, &msg);
         psa_reply(msg.handle, status);
         break;
+    case PSA_IPC_CALL:
+        status = forward_psa_call_to_secure_enclave(signal, &msg);
+        psa_reply(msg.handle, status);
+        break;
     case PSA_IPC_DISCONNECT:
         psa_disconnect_from_secure_enclave(&msg);
         psa_reply(msg.handle, PSA_SUCCESS);
         break;
     default:
-        status = forward_message_to_secure_enclave(signal, &msg);
-        psa_reply(msg.handle, status);
+        psa_panic();
         break;
     }
 }
diff --git a/lib/tf-m/secure_fw/partitions/psa_proxy/psa_proxy_shared_mem_mngr.c b/lib/tf-m/secure_fw/partitions/psa_proxy/psa_proxy_shared_mem_mngr.c
index 68eeee8c4..dc5614ed3 100644
--- a/lib/tf-m/secure_fw/partitions/psa_proxy/psa_proxy_shared_mem_mngr.c
+++ b/lib/tf-m/secure_fw/partitions/psa_proxy/psa_proxy_shared_mem_mngr.c
@@ -1,12 +1,12 @@
 /*
  * Copyright (c) 2020, Arm Limited. All rights reserved.
- * Copyright (c) 2021, Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
  */
 
 #include "psa_proxy_shared_mem_mngr.h"
+#include "platform_multicore.h"
 #include "region_defs.h"
 #include "psa/service.h"
 #ifdef PSA_PROXY_ADDR_TRANSLATION
diff --git a/lib/tf-m/secure_fw/partitions/psa_proxy/tfm_psa_proxy.yaml b/lib/tf-m/secure_fw/partitions/psa_proxy/tfm_psa_proxy.yaml
index 7429ed66f..cf46e3870 100644
--- a/lib/tf-m/secure_fw/partitions/psa_proxy/tfm_psa_proxy.yaml
+++ b/lib/tf-m/secure_fw/partitions/psa_proxy/tfm_psa_proxy.yaml
@@ -24,20 +24,50 @@
       "version_policy": "STRICT"
     },
     {
-      "name": "TFM_ATTESTATION_SERVICE",
+      "name": "TFM_ATTEST_GET_TOKEN",
       "sid": "0x00000020",
       "non_secure_clients": true,
-      "connection_based": false,
-      "stateless_handle": 4,
+      "connection_based": true,
+      "version": 1,
+      "version_policy": "STRICT"
+    },
+    {
+      "name": "TFM_ATTEST_GET_TOKEN_SIZE",
+      "sid": "0x00000021",
+      "non_secure_clients": true,
+      "connection_based": true,
       "version": 1,
       "version_policy": "STRICT"
     },
     {
-      "name": "TFM_INTERNAL_TRUSTED_STORAGE_SERVICE",
+      "name": "TFM_ITS_SET",
       "sid": "0x00000070",
       "non_secure_clients": true,
-      "connection_based": false,
-      "stateless_handle": 3,
+      "connection_based": true,
+      "version": 1,
+      "version_policy": "STRICT"
+    },
+    {
+      "name": "TFM_ITS_GET",
+      "sid": "0x00000071",
+      "non_secure_clients": true,
+      "connection_based": true,
+      "version": 1,
+      "version_policy": "STRICT"
+    },
+    {
+      "name": "TFM_ITS_GET_INFO",
+      "sid": "0x00000072",
+      "non_secure_clients": true,
+      "connection_based": true,
+      "version": 1,
+      "version_policy": "STRICT"
+    },
+    {
+      "name": "TFM_ITS_REMOVE",
+      "sid": "0x00000073",
+      "non_secure_clients": true,
+      "connection_based": true,
       "version": 1,
       "version_policy": "STRICT"
     },
@@ -66,13 +96,44 @@
       "version_policy": "STRICT"
     },
     {
-      "name": "TFM_PROTECTED_STORAGE_SERVICE",
+      "name": "TFM_PS_SET",
       "sid": "0x00000060",
       "non_secure_clients": true,
-      "connection_based": false,
-      "stateless_handle": 2,
+      "connection_based": true,
+      "version": 1,
+      "version_policy": "STRICT"
+     },
+     {
+      "name": "TFM_PS_GET",
+      "sid": "0x00000061",
+      "non_secure_clients": true,
+      "connection_based": true,
+      "version": 1,
+      "version_policy": "STRICT"
+     },
+     {
+      "name": "TFM_PS_GET_INFO",
+      "sid": "0x00000062",
+      "non_secure_clients": true,
+      "connection_based": true,
+      "version": 1,
+      "version_policy": "STRICT"
+     },
+     {
+      "name": "TFM_PS_REMOVE",
+      "sid": "0x00000063",
+      "non_secure_clients": true,
+      "connection_based": true,
+      "version": 1,
+      "version_policy": "STRICT"
+     },
+     {
+      "name": "TFM_PS_GET_SUPPORT",
+      "sid": "0x00000064",
+      "non_secure_clients": true,
+      "connection_based": true,
       "version": 1,
       "version_policy": "STRICT"
-    }
+     }
   ]
 }
diff --git a/tf-m.old/secure_fw/partitions/tfm_ffm11_partition/tfm_ffm11_partition.c b/lib/tf-m/secure_fw/partitions/tfm_ffm11_partition/tfm_ffm11_partition.c
new file mode 100644
index 000000000..d7f5be067
--- /dev/null
+++ b/lib/tf-m/secure_fw/partitions/tfm_ffm11_partition/tfm_ffm11_partition.c
@@ -0,0 +1,73 @@
+
+/*
+ * Copyright (c) 2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#include <stdint.h>
+#include "psa/service.h"
+#include "psa_manifest/tfm_ffm11_partition.h"
+#include "tfm/tfm_spm_services.h"
+#include "tfm_sp_log.h"
+
+/**
+ * \brief An example service implementation that prints out a message.
+ */
+static void tfm_ffm11_service1(void)
+{
+    psa_status_t status;
+    uint32_t arg;
+    psa_msg_t msg;
+    size_t num;
+
+    /* Retrieve the message corresponding to the example service signal */
+    status = psa_get(TFM_FFM11_SERVICE1_SIGNAL, &msg);
+    if (status != PSA_SUCCESS) {
+        return;
+    }
+
+    /* Decode the message */
+    switch (msg.type) {
+    case PSA_IPC_CALL:
+        if (msg.in_size[0] != sizeof(arg)) {
+            status = PSA_ERROR_PROGRAMMER_ERROR;
+            break;
+        }
+        /* Print arg from client */
+        num = psa_read(msg.handle, 0, &arg, sizeof(arg));
+        if (num != msg.in_size[0]) {
+            status = PSA_ERROR_PROGRAMMER_ERROR;
+            break;
+        }
+        LOG_INFFMT("[Example FFM11 partition] Service called! arg=%x\r\n", arg);
+        status = PSA_SUCCESS;
+        break;
+    default:
+        /* Invalid message type */
+        status = PSA_ERROR_PROGRAMMER_ERROR;
+        break;
+    }
+    /* Reply with the message result status to unblock the client */
+    psa_reply(msg.handle, status);
+}
+
+/**
+ * \brief The example FFM-1.1 partition's entry function.
+ */
+void tfm_ffm11_partition_main(void)
+{
+    psa_signal_t signals;
+
+    while (1) {
+        signals = psa_wait(PSA_WAIT_ANY, PSA_BLOCK);
+        if (signals & TFM_FFM11_SERVICE1_SIGNAL) {
+            tfm_ffm11_service1();
+        }
+        /*
+         * The other services are created in yaml for testing manifest tool,
+         * but not handled here. They are reserved for future use.
+         */
+    }
+}
diff --git a/tf-m.old/secure_fw/partitions/tfm_ffm11_partition/tfm_ffm11_partition.yaml b/lib/tf-m/secure_fw/partitions/tfm_ffm11_partition/tfm_ffm11_partition.yaml
new file mode 100644
index 000000000..9efdd7cb0
--- /dev/null
+++ b/lib/tf-m/secure_fw/partitions/tfm_ffm11_partition/tfm_ffm11_partition.yaml
@@ -0,0 +1,45 @@
+#-------------------------------------------------------------------------------
+# Copyright (c) 2021, Arm Limited. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+#-------------------------------------------------------------------------------
+
+{
+  "psa_framework_version": 1.1,
+  "name": "TFM_SP_FFM11",
+  "type": "APPLICATION-ROT",
+  "priority": "NORMAL",
+  "model": "IPC",
+  "entry_point": "tfm_ffm11_partition_main",
+  "stack_size": "0x200",
+  "services": [
+    {
+      "name": "TFM_FFM11_SERVICE1",
+      "sid": "0x0000F120",
+      "non_secure_clients": true,
+      "connection_based": false,
+      "stateless_handle": 4,
+      "version": 1,
+      "version_policy": "RELAXED"
+    },
+    {
+      "name": "TFM_FFM11_SERVICE2",
+      "sid": "0x0000F121",
+      "non_secure_clients": true,
+      "connection_based": false,
+      "stateless_handle": "auto",
+      "version": 1,
+      "version_policy": "RELAXED"
+    },
+    {
+      "name": "TFM_FFM11_SERVICE3",
+      "sid": "0x0000F122",
+      "non_secure_clients": true,
+      "connection_based": false,
+      "stateless_handle": 3,
+      "version": 1,
+      "version_policy": "RELAXED"
+    }
+  ],
+}
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/arch.c b/lib/tf-m/secure_fw/spm/cmsis_func/arch.c
index 39446c0de..bf637daba 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/arch.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/arch.c
@@ -9,6 +9,7 @@
 #include "compiler_ext_defs.h"
 #include "exception_info.h"
 #include "tfm_secure_api.h"
+#include "tfm/tfm_spm_services.h"
 
 #if defined(__ICCARM__)
 uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t *psp, uint32_t exc_return);
@@ -25,6 +26,20 @@ void jump_to_ns_code(void)
     tfm_core_panic();
 }
 
+__attribute__((naked))
+static int32_t tfm_spm_request(int32_t request_type)
+{
+    __ASM volatile(
+        "SVC    %0\n"
+        "BX     lr\n"
+        : : "I" (TFM_SVC_SPM_REQUEST));
+}
+
+int32_t tfm_spm_request_reset_vote(void)
+{
+    return tfm_spm_request((int32_t)TFM_SPM_REQUEST_RESET_VOTE);
+}
+
 __attribute__((naked))
 void tfm_enable_irq(psa_signal_t irq_signal)
 {
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/include/spm_func.h b/lib/tf-m/secure_fw/spm/cmsis_func/include/spm_func.h
index 72fa86016..568b456c7 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/include/spm_func.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/include/spm_func.h
@@ -373,6 +373,12 @@ enum spm_err_t tfm_spm_db_init(void);
  */
 uint32_t tfm_spm_partition_get_privileged_mode(uint32_t partition_flags);
 
+/**
+ * \brief                   Handle an SPM request by a secure service
+ * \param[in] svc_ctx       The stacked SVC context
+ */
+void tfm_spm_request_handler(const struct tfm_state_context_t *svc_ctx);
+
 /**
  * \brief                   Function to seal the PSP stacks for Function mode.
  */
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/include/tfm_core_svc.h b/lib/tf-m/secure_fw/spm/cmsis_func/include/tfm_core_svc.h
index 6314f9efb..ce4eed857 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/include/tfm_core_svc.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/include/tfm_core_svc.h
@@ -8,19 +8,22 @@
 #ifndef __TFM_CORE_SVC_H__
 #define __TFM_CORE_SVC_H__
 
+#include "tfm_spm_log.h"
+
 /* SVC numbers */
 #define TFM_SVC_PSA_WAIT                (0x0)
 #define TFM_SVC_PSA_EOI                 (0x1)
 #define TFM_SVC_SFN_REQUEST             (0x2)
 #define TFM_SVC_SFN_RETURN              (0x3)
 #define TFM_SVC_SFN_COMPLETION          (0x4)
-#define TFM_SVC_GET_BOOT_DATA           (0x5)
-#define TFM_SVC_DEPRIV_REQ              (0x6)
-#define TFM_SVC_DEPRIV_RET              (0x7)
-#define TFM_SVC_ENABLE_IRQ              (0x8)
-#define TFM_SVC_DISABLE_IRQ             (0x9)
-#if TFM_SP_LOG_RAW_ENABLED
-#define TFM_SVC_OUTPUT_UNPRIV_STRING    (0xA)
+#define TFM_SVC_SPM_REQUEST             (0x5)
+#define TFM_SVC_GET_BOOT_DATA           (0x6)
+#define TFM_SVC_DEPRIV_REQ              (0x7)
+#define TFM_SVC_DEPRIV_RET              (0x8)
+#define TFM_SVC_ENABLE_IRQ              (0x9)
+#define TFM_SVC_DISABLE_IRQ             (0xA)
+#if (TFM_SPM_LOG_LEVEL > TFM_SPM_LOG_LEVEL_SILENCE)
+#define TFM_SVC_OUTPUT_UNPRIV_STRING    (0xB)
 #endif
 
 #endif /* __TFM_CORE_SVC_H__ */
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/main.c b/lib/tf-m/secure_fw/spm/cmsis_func/main.c
index d8dadbc31..db9bea43c 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/main.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/main.c
@@ -18,8 +18,6 @@
 #include "tfm_spm_hal.h"
 #include "tfm_spm_log.h"
 #include "tfm_version.h"
-#include "tfm_plat_otp.h"
-#include "tfm_plat_provisioning.h"
 
 /*
  * Avoids the semihosting issue
@@ -35,9 +33,7 @@ __asm("  .global __ARM_use_no_argv\n");
 #error Only TFM_LVL 1 is supported for library model!
 #endif
 
-REGION_DECLARE(Image$$, ARM_LIB_STACK,  $$ZI$$Base);
-REGION_DECLARE(Image$$, ARM_LIB_STACK,  $$ZI$$Limit)[];
-REGION_DECLARE(Image$$, ER_INITIAL_PSP,  $$ZI$$Limit)[];
+REGION_DECLARE(Image$$, ARM_LIB_STACK_MSP,  $$ZI$$Base);
 
 static fih_int tfm_core_init(void)
 {
@@ -96,21 +92,6 @@ static fih_int tfm_core_init(void)
         FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
     }
 
-    plat_err = tfm_plat_otp_init();
-    if (plat_err != TFM_PLAT_ERR_SUCCESS) {
-            FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
-    }
-
-    /* Perform provisioning. */
-    if (tfm_plat_provisioning_is_required()) {
-        plat_err = tfm_plat_provisioning_perform();
-        if (plat_err != TFM_PLAT_ERR_SUCCESS) {
-            FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
-        }
-    } else {
-        tfm_plat_provisioning_check_for_dummy_keys();
-    }
-
     /* Configures architecture */
     tfm_arch_config_extensions();
 
@@ -153,35 +134,14 @@ static fih_int tfm_core_init(void)
     FIH_RET(fih_int_encode(TFM_SUCCESS));
 }
 
-__attribute__((naked))
 int main(void)
-{
-    __ASM volatile(
-#if !defined(__ICCARM__)
-        ".syntax unified                               \n"
-#endif
-        "msr     msp, %0                               \n"
-        "msr     psp, %1                               \n"
-        "mrs     r0, control                           \n"
-        "movs    r1, #2                                \n"
-        "orrs    r0, r0, r1                            \n" /* Switch to PSP */
-        "msr     control, r0                           \n"
-        "bl      c_main                                \n"
-        :
-        : "r" (REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit)),
-          "r" (REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Limit))
-        : "r0", "memory"
-    );
-}
-
-int c_main(void)
 {
     enum spm_err_t spm_err = SPM_ERR_GENERIC_ERR;
     fih_int fih_rc = FIH_FAILURE;
 
     /* set Main Stack Pointer limit */
     tfm_arch_init_secure_msp((uint32_t)&REGION_NAME(Image$$,
-                                                    ARM_LIB_STACK,
+                                                    ARM_LIB_STACK_MSP,
                                                     $$ZI$$Base));
 
     /* Seal the PSP stacks viz ARM_LIB_STACK and TFM_SECURE_STACK */
@@ -207,9 +167,9 @@ int c_main(void)
 
     tfm_spm_partition_set_state(TFM_SP_CORE_ID, SPM_PARTITION_STATE_RUNNING);
 
-    REGION_DECLARE(Image$$, ER_INITIAL_PSP, $$ZI$$Base)[];
+    REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Base)[];
     uint32_t psp_stack_bottom =
-                      (uint32_t)REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
+                      (uint32_t)REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base);
 
     tfm_arch_set_psplim(psp_stack_bottom);
 
@@ -244,8 +204,11 @@ int c_main(void)
     /* Jumps to non-secure code */
     SPMLOG_DBGMSG("\033[1;34mJumping to non-secure code...\033[0m\r\n");
 #endif
+    
+    /* enable reset from non secure code */
+    struct sse300_sysctrl_t *p = (struct sse300_sysctrl_t*)SSE300_SYSCTRL_BASE_S;
+    p->reset_mask = 0xFFFFFFFF;
+    SCB->AIRCR = 0x05FA4000;
 
     jump_to_ns_code();
-
-    return 0;
 }
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/spm_func.c b/lib/tf-m/secure_fw/spm/cmsis_func/spm_func.c
index 5326f944c..252716e48 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/spm_func.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/spm_func.c
@@ -26,7 +26,7 @@
 #include "region.h"
 #include "spm_partition_defs.h"
 #include "psa_manifest/pid.h"
-#include "tfm_spm_services.h"
+#include "tfm/tfm_spm_services.h"
 #include "tfm_spm_db_func.inc"
 
 /* Structure to temporarily save iovec parameters from PSA client */
@@ -56,7 +56,7 @@ REGION_DECLARE_T(Image$$, TFM_SECURE_STACK, $$ZI$$Limit, struct iovec_args_t)[];
 static uint32_t *tfm_secure_stack_seal =
     ((uint32_t *)&REGION_NAME(Image$$, TFM_SECURE_STACK, $$ZI$$Limit)[-1]) - 2;
 
-REGION_DECLARE_T(Image$$, ER_INITIAL_PSP_SEAL, $$ZI$$Base, uint32_t)[];
+REGION_DECLARE_T(Image$$, ARM_LIB_STACK_SEAL, $$ZI$$Base, uint32_t)[];
 
 /*
  * Function to seal the psp stacks for Function model of TF-M.
@@ -84,11 +84,11 @@ void tfm_spm_seal_psp_stacks(void)
     *(tfm_secure_stack_seal + 1) = TFM_STACK_SEAL_VALUE;
 
     /*
-     * Seal the ER_INITIAL_PSP by writing the seal value to the reserved
+     * Seal the ARM_LIB_STACK by writing the seal value to the reserved
      * region.
      */
     uint32_t *arm_lib_stck_seal_base =
-        ((uint32_t *)&REGION_NAME(Image$$, ER_INITIAL_PSP_SEAL, $$ZI$$Base)[-1]) - 2;
+        ((uint32_t *)&REGION_NAME(Image$$, ARM_LIB_STACK_SEAL, $$ZI$$Base)[-1]) - 2;
 
     *(arm_lib_stck_seal_base) = TFM_STACK_SEAL_VALUE;
     *(arm_lib_stck_seal_base + 1) = TFM_STACK_SEAL_VALUE;
@@ -652,9 +652,9 @@ static enum tfm_status_e tfm_return_from_partition(uint32_t *excReturn)
             (struct tfm_state_context_t *)ret_part_data->stack_ptr);
         *excReturn = ret_part_data->lr;
         __set_PSP(ret_part_data->stack_ptr);
-        REGION_DECLARE_T(Image$$, ER_INITIAL_PSP, $$ZI$$Base, uint32_t)[];
+        REGION_DECLARE_T(Image$$, ARM_LIB_STACK, $$ZI$$Base, uint32_t)[];
         uint32_t psp_stack_bottom =
-            (uint32_t)REGION_NAME(Image$$, ER_INITIAL_PSP, $$ZI$$Base);
+            (uint32_t)REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Base);
         tfm_arch_set_psplim(psp_stack_bottom);
 
         iovec_args = &REGION_NAME(Image$$, TFM_SECURE_STACK, $$ZI$$Limit)[-1];
@@ -1372,6 +1372,39 @@ void tfm_spm_partition_cleanup_context(uint32_t partition_idx)
     partition->runtime_data.orig_outvec = 0;
 }
 
+void tfm_spm_request_handler(const struct tfm_state_context_t *svc_ctx)
+{
+    uint32_t *res_ptr = (uint32_t *)&svc_ctx->r0;
+    uint32_t running_partition_flags = 0;
+    uint32_t running_partition_idx;
+
+    /* Check permissions on request type basis */
+
+    switch (svc_ctx->r0) {
+    case TFM_SPM_REQUEST_RESET_VOTE:
+        running_partition_idx =
+            tfm_spm_partition_get_running_partition_idx();
+        running_partition_flags = tfm_spm_partition_get_flags(
+                                                         running_partition_idx);
+
+        /* Currently only PSA Root of Trust services are allowed to make Reset
+         * vote request
+         */
+        if ((running_partition_flags & SPM_PART_FLAG_PSA_ROT) == 0) {
+            *res_ptr = (uint32_t)TFM_ERROR_GENERIC;
+        }
+
+        /* FixMe: this is a placeholder for checks to be performed before
+         * allowing execution of reset
+         */
+        *res_ptr = (uint32_t)TFM_SUCCESS;
+
+        break;
+    default:
+        *res_ptr = (uint32_t)TFM_ERROR_INVALID_PARAMETER;
+    }
+}
+
 enum spm_err_t tfm_spm_db_init(void)
 {
     uint32_t i;
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/tfm_core_svcalls_func.c b/lib/tf-m/secure_fw/spm/cmsis_func/tfm_core_svcalls_func.c
index d05ef5d84..e6412a519 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/tfm_core_svcalls_func.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/tfm_core_svcalls_func.c
@@ -68,6 +68,9 @@ uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t *psp, uint32_t exc_return)
     case TFM_SVC_SFN_COMPLETION:
         tfm_spm_partition_completion_handler(svc_args[0], svc_args[1], msp);
         break;
+    case TFM_SVC_SPM_REQUEST:
+        tfm_spm_request_handler((struct tfm_state_context_t *)svc_args);
+        break;
     case TFM_SVC_DEPRIV_REQ:
         retval = tfm_spm_depriv_req_handler(svc_args, exc_return);
         break;
@@ -89,7 +92,7 @@ uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t *psp, uint32_t exc_return)
     case TFM_SVC_GET_BOOT_DATA:
         tfm_core_get_boot_data_handler(svc_args);
         break;
-#if TFM_SP_LOG_RAW_ENABLED
+#if (TFM_SPM_LOG_LEVEL > TFM_SPM_LOG_LEVEL_SILENCE)
     case TFM_SVC_OUTPUT_UNPRIV_STRING:
         svc_args[0] = tfm_hal_output_spm_log((const char *)svc_args[0],
                                              svc_args[1]);
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch.c b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch.c
index 823e293f9..34b347de2 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch.c
@@ -5,80 +5,57 @@
  *
  */
 
+#include "svc_num.h"
 #include "tfm_arch.h"
 #include "tfm_core_utils.h"
-#include "utilities.h"
+#include "tfm/tfm_spm_services.h"
 
-__attribute__((naked)) void tfm_arch_free_msp_and_exc_ret(uint32_t exc_return)
+__attribute__((naked))
+static int32_t tfm_spm_request(int32_t request_type)
 {
     __ASM volatile(
-#if !defined(__ICCARM__)
-        ".syntax unified                  \n"
-#endif
-        "MOV     lr, r0                   \n"
-        "LDR     r0, ="M2S(VTOR_BASE)"    \n" /* VTOR */
-        "LDR     r0, [r0]                 \n" /* MSP address */
-        "LDR     r0, [r0]                 \n" /* MSP */
-        "SUBS    r0, #8                   \n" /* Exclude stack seal */
-        "MSR     msp, r0                  \n" /* Free Main Stack space */
-        "BX      lr                       \n"
-    );
+        "SVC    %0\n"
+        "BX     lr\n"
+        : : "I" (TFM_SVC_SPM_REQUEST));
 }
 
-void tfm_arch_set_context_ret_code(void *p_ctx_ctrl, uintptr_t ret_code)
+int32_t tfm_spm_request_reset_vote(void)
 {
-    ((struct full_context_t *)(((struct context_ctrl_t *)p_ctx_ctrl)->sp))
-                                                       ->stat_ctx.r0 = ret_code;
+    return tfm_spm_request((int32_t)TFM_SPM_REQUEST_RESET_VOTE);
 }
 
-/*
- * Initializes the State Context. The Context is used to do Except Return to
- * Thread Mode to start a function.
- *
- * p_sctx[out] - pointer to the State Context to be initialized.
- * param [in]  - The parameter for the function to start
- * pfn   [in]  - Pointer to the function to excute
- * pfnlr [in]  - The Link Register of the State Context - the return address of
- *               the function
- */
-static void tfm_arch_init_state_context(struct tfm_state_context_t *p_sctx,
-                                        void *param,
-                                        uintptr_t pfn, uintptr_t pfnlr)
+static void tfm_arch_init_state_ctx(struct tfm_state_context_t *p_stat_ctx,
+                                    void *param, uintptr_t pfn)
 {
-    p_sctx->r0 = (uint32_t)param;
-    p_sctx->ra = (uint32_t)pfn;
-    p_sctx->lr = (uint32_t)pfnlr;
-    p_sctx->xpsr = XPSR_T32;
+    p_stat_ctx->r0 = (uint32_t)param;
+    p_stat_ctx->ra = (uint32_t)pfn;
+    /*
+     * Prevent thread exits:
+     * Only T32 is supported, so bit[0] must be 1. Clear the bit[0] of LR to
+     * trigger a fault.
+     */
+    p_stat_ctx->lr = ((uint32_t)pfn) & (~1UL);
+    p_stat_ctx->xpsr = XPSR_T32;
 }
 
-void tfm_arch_init_context(void *p_ctx_ctrl,
-                           uintptr_t pfn, void *param, uintptr_t pfnlr,
-                           uintptr_t sp_limit, uintptr_t sp)
+void tfm_arch_init_context(struct tfm_arch_ctx_t *p_actx,
+                           void *param, uintptr_t pfn,
+                           uintptr_t stk_btm, uintptr_t stk_top)
 {
-    struct full_context_t *p_tctx =
-            (struct full_context_t *)arch_seal_thread_stack(sp);
-
-    p_tctx--;
-
-    spm_memset(p_tctx, 0, sizeof(*p_tctx));
-
-    tfm_arch_init_state_context(&p_tctx->stat_ctx, param, pfn, pfnlr);
-
-    ((struct context_ctrl_t *)p_ctx_ctrl)->exc_ret  = EXC_RETURN_THREAD_S_PSP;
-    ((struct context_ctrl_t *)p_ctx_ctrl)->sp_limit = sp_limit;
-    ((struct context_ctrl_t *)p_ctx_ctrl)->sp       = (uintptr_t)p_tctx;
-}
-
-uint32_t tfm_arch_refresh_hardware_context(void *p_ctx_ctrl)
-{
-    struct context_ctrl_t *ctx_ctrl;
-    struct tfm_state_context_t *sc;
-
-    ctx_ctrl  = (struct context_ctrl_t *)p_ctx_ctrl;
-    sc = &(((struct full_context_t *)(ctx_ctrl->sp))->stat_ctx);
-
-    tfm_arch_set_psplim(ctx_ctrl->sp_limit);
-    __set_PSP((uintptr_t)sc);
-
-    return ctx_ctrl->exc_ret;
+    struct tfm_state_context_t *p_stat_ctx =
+            (struct tfm_state_context_t *)tfm_arch_seal_thread_stack(stk_top);
+
+    /*
+     * Shift back SP to leave space for holding common state context
+     * since thread is kicked off through exception return.
+     */
+    p_stat_ctx--;
+
+    /* First the common state context - ZERO it before usage. */
+    spm_memset(p_stat_ctx, 0, sizeof(*p_stat_ctx));
+    tfm_arch_init_state_ctx(p_stat_ctx, param, pfn);
+
+    /* Then the architecture-specific context. */
+    spm_memset(p_actx, 0, sizeof(*p_actx));
+    tfm_arch_init_actx(p_actx, (uint32_t)p_stat_ctx, (uint32_t)stk_btm);
 }
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.c b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.c
index b8760496c..c63e3ccf9 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.c
@@ -6,10 +6,8 @@
  */
 
 #include <inttypes.h>
-#include "tfm_core_utils.h"
 #include "tfm_hal_device_header.h"
 #include "tfm_arch.h"
-#include "spm_ipc.h"
 #include "svc_num.h"
 #include "exception_info.h"
 
@@ -20,50 +18,74 @@
 
 extern uint32_t SVCHandler_main(uint32_t *svc_args, uint32_t lr);
 
+/*
+ * Stack status at PendSV entry:
+ *
+ *                                            [ R0 - R3  ]<- PSP
+ *                                            [ R12      ]
+ *                                            [ LR_of_RA ]
+ *                       MSP->[ ........ ]    [ RA       ]
+ *                            [ ........ ]    [ XPSR     ]
+ *                                            [ ........ ]
+ *                                            [ ........ ]
+ *
+ * Stack status before calling tfm_pendsv_do_schedule():
+ *
+ *                       MSP->[ R8 - R9  ]
+ *                            [ R4 - R7  ]
+ *                            [ PSP      ]--->[ R0 - R3  ]
+ *                            [ LR       ]    [ R12      ]
+ *                            [ ........ ]    [ LR_of_RA ]
+ *                            [ ........ ]    [ RA       ]
+ *                                            [ XPSR     ]
+ *                                            [ ........ ]
+ *                                            [ ........ ]
+ *
+ * tfm_pendsv_do_schedule() updates stacked context into current thread and
+ * replace stacked context with context of next thread.
+ *
+ * Scheduler does not support handler mode thread so take PSP as thread SP.
+ */
 #if defined(__ICCARM__)
-#pragma required = do_schedule
+extern void tfm_pendsv_do_schedule(void);
+#pragma required = tfm_pendsv_do_schedule
 #endif
 
 __attribute__((naked)) void PendSV_Handler(void)
 {
     __ASM volatile(
-#if !defined(__ICCARM__)
-        ".syntax unified                    \n"
-#endif
-        "   push    {r0, lr}                \n"
-        "   bl      do_schedule             \n"
-        "   pop     {r2, r3}                \n"
-        "   mov     lr, r3                  \n"
-        "   cmp     r0, r1                  \n" /* ctx of curr and next thrd */
-        "   beq     v6v7_pendsv_exit        \n" /* No schedule if curr = next */
-        "   mrs     r2, psp                 \n"
-        "   subs    r2, #32                 \n" /* Make room for r4-r11 */
-        "   stm     r2!, {r4-r7}            \n" /* Save callee registers */
-        "   mov     r4, r8                  \n"
-        "   mov     r5, r9                  \n"
-        "   mov     r6, r10                 \n"
-        "   mov     r7, r11                 \n"
-        "   stm     r2!, {r4-r7}            \n"
-        "   mov     r5, lr                  \n"
-        "   subs    r2, #32                 \n" /* reset r2(SP) to top */
-        "   stm     r0!, {r2, r3, r4, r5}   \n" /* Save struct context_ctrl_t */
-        "   ldm     r1!, {r2, r3, r4, r5}   \n" /* Load ctx of next thread */
-        "   mov     lr, r5                  \n"
-        "   adds    r2, #16                 \n" /* Start of popping r4-r11 */
-        "   ldm     r2!, {r4-r7}            \n"
-        "   mov     r8, r4                  \n"
-        "   mov     r9, r5                  \n"
-        "   mov     r10, r6                 \n"
-        "   mov     r11, r7                 \n"
-        "   subs    r2, #32                 \n"
-        "   ldm     r2!, {r4-r7}            \n"
-        "   adds    r2, #16                 \n" /* End of popping r4-r11 */
-        "   msr     psp, r2                 \n"
-        "v6v7_pendsv_exit:                  \n"
-        "   bx      lr                      \n"
+        "MRS     r0, psp                    \n"
+        "PUSH    {r0, lr}                   \n"
+        "PUSH    {r4-r7}                    \n"
+        "MOV     r4, r8                     \n"
+        "MOV     r5, r9                     \n"
+        "MOV     r6, r10                    \n"
+        "MOV     r7, r11                    \n"
+        "PUSH    {r4-r7}                    \n"
+        "MOV     r0, sp                     \n"
+        "BL      tfm_pendsv_do_schedule     \n"
+        "POP     {r4-r7}                    \n"
+        "MOV     r8, r4                     \n"
+        "MOV     r9, r5                     \n"
+        "MOV     r10, r6                    \n"
+        "MOV     r11, r7                    \n"
+        "POP     {r4-r7}                    \n"
+        "POP     {r0, r1}                   \n"
+        "MOV     lr, r1                     \n"
+        "MSR     psp, r0                    \n"
+        "BX      lr                         \n"
     );
 }
 
+void tfm_arch_init_actx(struct tfm_arch_ctx_t *p_actx,
+                        uint32_t sp, uint32_t sp_limit)
+{
+    (void)sp_limit;
+
+    p_actx->sp = sp;
+    p_actx->lr = EXC_RETURN_THREAD_S_PSP;
+}
+
 #if defined(__ICCARM__)
 uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t exc_return,
                               uint32_t *psp);
@@ -79,6 +101,7 @@ __attribute__((naked)) void SVC_Handler(void)
     "MRS     r0, MSP                        \n"
     "MOV     r1, lr                         \n"
     "MRS     r2, PSP                        \n"
+    "SUB     sp, #8                         \n" /* For FLIH PID and signal */
     "PUSH    {r1, r2}                       \n" /* Orig_exc_return, PSP */
     "BL      tfm_core_svc_handler           \n"
     "MOV     lr, r0                         \n"
@@ -89,7 +112,7 @@ __attribute__((naked)) void SVC_Handler(void)
     "SUBS    r0, r1                         \n" /* Compare EXC_RETURN values */
     "BGT     to_flih_func                   \n"
     "BLT     from_flih_func                 \n"
-    "POP     {r1, r2}                       \n" /* Orig_exc_return, PSP */
+    "ADD     sp, #16                        \n"
     "BX      lr                             \n"
     "to_flih_func:                          \n"
     "PUSH    {r4-r7}                        \n"
@@ -109,15 +132,14 @@ __attribute__((naked)) void SVC_Handler(void)
     "PUSH    {r4, r5}                       \n" /* Seal stack before EXC_RET */
     "BX      lr                             \n"
     "from_flih_func:                        \n"
-    "POP     {r1, r2}                       \n" /* Orig_exc_return, PSP */
-    "POP     {r4, r5}                       \n" /* Seal stack */
+    "ADD     sp, #24                        \n"
     "POP     {r4-r7}                        \n"
     "MOV     r8, r4                         \n"
     "MOV     r9, r5                         \n"
     "MOV     r10, r6                        \n"
     "MOV     r11, r7                        \n"
     "POP     {r4-r7}                        \n"
-    "POP     {r1, r2}                       \n" /* Orig_exc_return, PSP */
+    "ADD     sp, #16                        \n"
     "BX      lr                             \n"
     );
 }
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.h b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.h
index daae0a735..5058dd805 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.h
@@ -30,12 +30,18 @@
 /* processor mode for return: 0=Handler mode 1=Thread mod. */
 #define EXC_RETURN_MODE     (1UL << 3)
 
-/* Exception numbers */
-#define EXC_NUM_THREAD_MODE                     (0)
-#define EXC_NUM_SVCALL                          (11)
-#define EXC_NUM_PENDSV                          (14)
-
-#define VTOR_BASE                       (0xE000ED08)
+struct tfm_arch_ctx_t {
+    uint32_t    r8;
+    uint32_t    r9;
+    uint32_t    r10;
+    uint32_t    r11;
+    uint32_t    r4;
+    uint32_t    r5;
+    uint32_t    r6;
+    uint32_t    r7;
+    uint32_t    sp;
+    uint32_t    lr;
+};
 
 /**
  * \brief Check whether Secure or Non-secure stack is used to restore stack
@@ -99,30 +105,36 @@ __STATIC_INLINE void tfm_arch_set_psplim(uint32_t psplim)
 }
 
 /**
- * \brief Set MSP limit value.
+ * \brief Seal the thread stack.
  *
- * \param[in] msplim        MSP limit value to be written.
+ * \param[in] stk        Thread stack address.
+ *
+ * \retval stack         Updated thread stack address.
  */
-__STATIC_INLINE void tfm_arch_set_msplim(uint32_t msplim)
+__STATIC_INLINE uintptr_t tfm_arch_seal_thread_stack(uintptr_t stk)
 {
-    /*
-     * Defined as an empty function now.
-     * The MSP limit value can be used in more strict memory check.
-     */
-    (void)msplim;
+    TFM_CORE_ASSERT((stk & 0x7) == 0);
+    return stk;
 }
 
 /**
- * \brief Seal the thread stack.
+ * \brief Get architecture context value into context struct
  *
- * \param[in] stk        Thread stack address.
+ * \param[in] p_actx        Pointer of context data
+ */
+__STATIC_INLINE void tfm_arch_get_ctx(struct tfm_arch_ctx_t *p_actx)
+{
+    p_actx->sp = __get_PSP();
+}
+
+/**
+ * \brief Update architecture context value into hardware
  *
- * \retval stack         Updated thread stack address.
+ * \param[in] p_actx        Pointer of context data
  */
-__STATIC_INLINE uintptr_t arch_seal_thread_stack(uintptr_t stk)
+__STATIC_INLINE void tfm_arch_set_ctx(struct tfm_arch_ctx_t *p_actx)
 {
-    TFM_CORE_ASSERT((stk & 0x7) == 0);
-    return stk;
+    __set_PSP(p_actx->sp);
 }
 
 /**
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_base.c b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_base.c
index c073eb6e5..015ae7331 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_base.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_base.c
@@ -9,67 +9,91 @@
 #include "spm_ipc.h"
 #include "tfm_hal_device_header.h"
 #include "tfm_arch.h"
-#include "tfm_core_utils.h"
 #include "exception_info.h"
 #include "tfm_secure_api.h"
-#include "spm_ipc.h"
 #include "svc_num.h"
-#include "utilities.h"
 
 #if !defined(__ARM_ARCH_8M_BASE__)
 #error "Unsupported ARM Architecture."
 #endif
 
+/*
+ * Stack status at PendSV entry:
+ *
+ *                                            [ R0 - R3  ]<- PSP
+ *                                            [ R12      ]
+ *                                            [ LR_of_RA ]
+ *                       MSP->[ ........ ]    [ RA       ]
+ *                            [ ........ ]    [ XPSR     ]
+ *                                            [ ........ ]
+ *                                            [ ........ ]
+ *
+ * Stack status before calling pendsv_do_schedule():
+ *
+ *                       MSP->[ R4 - R11 ]
+ *                            [ PSP      ]--->[ R0 - R3  ]
+ *                            [ PSP Limit]    [ R12      ]
+ *                            [ R2(dummy)]    [ LR_of_RA ]
+ *                            [ LR       ]    [ RA       ]
+ *                            [ ........ ]    [ XPSR     ]
+ *                            [ ........ ]    [ ........ ]
+ *                                            [ ........ ]
+ *
+ * tfm_pendsv_do_schedule() updates stacked context into current thread and
+ * replace stacked context with context of next thread.
+ *
+ * Scheduler does not support handler mode thread so take PSP/PSP_LIMIT as
+ * thread SP/SP_LIMIT. R2 holds dummy data due to stack operation is 8 bytes
+ * aligned.
+ */
 #if defined(__ICCARM__)
-#pragma required = do_schedule
+#pragma required = tfm_pendsv_do_schedule
 #endif
 
 __attribute__((naked)) void PendSV_Handler(void)
 {
     __ASM volatile(
-#if !defined(__ICCARM__)
+#ifndef __ICCARM__
         ".syntax unified                    \n"
 #endif
-        "   movs    r0, #0x40               \n"
-        "   mov     r1, lr                  \n"
-        "   tst     r0, r1                  \n" /* Was NS interrupted by S? */
-        "   beq     v8b_pendsv_exit         \n" /* Yes, do not schedule */
-        "   push    {r0, lr}                \n" /* Save dummy R0, LR */
-        "   bl      do_schedule             \n"
-        "   pop     {r2, r3}                \n"
-        "   mov     lr, r3                  \n"
-        "   cmp     r0, r1                  \n" /* ctx of curr and next thrd */
-        "   beq     v8b_pendsv_exit         \n" /* No schedule if curr = next */
-        "   mrs     r2, psp                 \n"
-        "   mrs     r3, psplim              \n"
-        "   subs    r2, #32                 \n" /* Make room for r4-r7 */
-        "   stm     r2!, {r4-r7}            \n" /* Save callee registers */
-        "   mov     r4, r8                  \n"
-        "   mov     r5, r9                  \n"
-        "   mov     r6, r10                 \n"
-        "   mov     r7, r11                 \n"
-        "   stm     r2!, {r4-r7}            \n"
-        "   mov     r5, lr                  \n"
-        "   subs    r2, #32                 \n" /* reset r2(SP) to top */
-        "   stm     r0!, {r2, r3, r4, r5}   \n" /* Save struct context_ctrl_t */
-        "   ldm     r1!, {r2, r3, r4, r5}   \n" /* Load ctx of next thread */
-        "   mov     lr, r5                  \n"
-        "   adds    r2, #16                 \n" /* Start of popping r4-r11 */
-        "   ldm     r2!, {r4-r7}            \n"
-        "   mov     r8, r4                  \n"
-        "   mov     r9, r5                  \n"
-        "   mov     r10, r6                 \n"
-        "   mov     r11, r7                 \n"
-        "   subs    r2, #32                 \n"
-        "   ldm     r2!, {r4-r7}            \n"
-        "   adds    r2, #16                 \n" /* End of popping r4-r11 */
-        "   msr     psp, r2                 \n"
-        "   msr     psplim, r3              \n"
-        "v8b_pendsv_exit:                   \n"
-        "   bx      lr                      \n"
+        "movs    r0, #0x40                  \n"
+        "mov     r1, lr                     \n"
+        "tst     r0, r1                     \n" /* Was NS interrupted by S? */
+        "beq     exc_return                 \n" /* Yes, do not schedule */
+        "mrs     r0, psp                    \n"
+        "mrs     r1, psplim                 \n"
+        "push    {r0, r1, r2, lr}           \n"
+        "push    {r4-r7}                    \n"
+        "mov     r4, r8                     \n"
+        "mov     r5, r9                     \n"
+        "mov     r6, r10                    \n"
+        "mov     r7, r11                    \n"
+        "push    {r4-r7}                    \n"
+        "mov     r0, sp                     \n"
+        "bl      tfm_pendsv_do_schedule     \n"
+        "pop     {r4-r7}                    \n"
+        "mov     r8, r4                     \n"
+        "mov     r9, r5                     \n"
+        "mov     r10, r6                    \n"
+        "mov     r11, r7                    \n"
+        "pop     {r4-r7}                    \n"
+        "pop     {r0-r3}                    \n"
+        "mov     lr, r3                     \n"
+        "msr     psp, r0                    \n"
+        "msr     psplim, r1                 \n"
+        "exc_return:                        \n"
+        "bx      lr                         \n"
     );
 }
 
+void tfm_arch_init_actx(struct tfm_arch_ctx_t *p_actx,
+                        uint32_t sp, uint32_t sp_limit)
+{
+    p_actx->sp = sp;
+    p_actx->sp_limit = sp_limit;
+    p_actx->lr = EXC_RETURN_THREAD_S_PSP;
+}
+
 /**
  * \brief Overwrites default Hard fault handler.
  *
@@ -108,6 +132,7 @@ __attribute__((naked)) void SVC_Handler(void)
     "MRS     r0, MSP                        \n"
     "MOV     r1, lr                         \n"
     "MRS     r2, PSP                        \n"
+    "SUB     sp, #8                         \n" /* For FLIH PID and signal */
     "PUSH    {r1, r2}                       \n" /* Orig_exc_return, PSP */
     "BL      tfm_core_svc_handler           \n"
     "MOV     lr, r0                         \n"
@@ -118,7 +143,7 @@ __attribute__((naked)) void SVC_Handler(void)
     "SUBS    r0, r1                         \n" /* Compare EXC_RETURN values */
     "BGT     to_flih_func                   \n"
     "BLT     from_flih_func                 \n"
-    "POP     {r1, r2}                       \n" /* Orig_exc_return, PSP */
+    "ADD     sp, #16                        \n"
     "BX      lr                             \n"
     "to_flih_func:                          \n"
     "PUSH    {r4-r7}                        \n"
@@ -138,15 +163,14 @@ __attribute__((naked)) void SVC_Handler(void)
     "PUSH    {r4, r5}                       \n" /* Seal stack before EXC_RET */
     "BX      lr                             \n"
     "from_flih_func:                        \n"
-    "POP     {r1, r2}                       \n" /* Orig_exc_return, PSP */
-    "POP     {r4, r5}                       \n" /* Seal stack */
+    "ADD     sp, #24                        \n"
     "POP     {r4-r7}                        \n"
     "MOV     r8, r4                         \n"
     "MOV     r9, r5                         \n"
     "MOV     r10, r6                        \n"
     "MOV     r11, r7                        \n"
     "POP     {r4-r7}                        \n"
-    "POP     {r1, r2}                       \n" /* Orig_exc_return, PSP */
+    "ADD     sp, #16                        \n"
     "BX      lr                             \n"
     );
 }
@@ -180,10 +204,9 @@ void tfm_arch_set_secure_exception_priorities(void)
      * When AIRCR.PRIS is set, the Non-Secure execution can act on
      * FAULTMASK_NS, PRIMASK_NS or BASEPRI_NS register to boost its priority
      * number up to the value 0x80.
-     * For this reason, set the priority of the PendSV interrupt to the next
-     * priority level configurable on the platform, just below 0x80.
+     * For this reason, set the priority of the PendSV interrupt to 0x80.
      */
-    NVIC_SetPriority(PendSV_IRQn, (1 << (__NVIC_PRIO_BITS - 1)) - 1);
+    NVIC_SetPriority(PendSV_IRQn, 1 << (__NVIC_PRIO_BITS - 1));
 #endif
 }
 
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_main.c b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_main.c
index 8ba02ac06..9ae72a981 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_main.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_main.c
@@ -15,39 +15,89 @@
 #include "tfm_secure_api.h"
 #include "spm_ipc.h"
 #include "svc_num.h"
-#include "utilities.h"
 
 #if !defined(__ARM_ARCH_8M_MAIN__) && !defined(__ARM_ARCH_8_1M_MAIN__)
 #error "Unsupported ARM Architecture."
 #endif
 
+/*
+ * Stack status at PendSV entry:
+ *
+ *                                            [ R0 - R3  ]<- PSP
+ *                                            [ R12      ]
+ *                                            [ LR_of_RA ]
+ *                       MSP->[ ........ ]    [ RA       ]
+ *                            [ ........ ]    [ XPSR     ]
+ *                                            [ ........ ]
+ *                                            [ ........ ]
+ *
+ * Stack status before calling pendsv_do_schedule():
+ *
+ *                       MSP->[ R4 - R11 ]
+ *                            [ PSP      ]--->[ R0 - R3  ]
+ *                            [ PSP Limit]    [ R12      ]
+ *                            [ R2(dummy)]    [ LR_of_RA ]
+ *                            [ LR       ]    [ RA       ]
+ *                            [ ........ ]    [ XPSR     ]
+ *                            [ ........ ]    [ ........ ]
+ *                                            [ ........ ]
+ *
+ * tfm_pendsv_do_schedule() updates stacked context into current thread and
+ * replace stacked context with context of next thread.
+ *
+ * Scheduler does not support handler mode thread so take PSP/PSP_LIMIT as
+ * thread SP/SP_LIMIT. R2 holds dummy data due to stack operation is 8 bytes
+ * aligned.
+ */
 #if defined(__ICCARM__)
-#pragma required = do_schedule
+#pragma required = tfm_pendsv_do_schedule
 #endif
 
 __attribute__((naked)) void PendSV_Handler(void)
 {
     __ASM volatile(
-        "   tst     lr, #0x40               \n" /* Was NS interrupted by S? */
-        "   beq     v8m_pendsv_exit         \n" /* Yes, do not schedule */
-        "   push    {r0, lr}                \n" /* Save dummy R0, LR */
-        "   bl      do_schedule             \n"
-        "   pop     {r2, lr}                \n"
-        "   cmp     r0, r1                  \n" /* ctx of curr and next thrd */
-        "   beq     v8m_pendsv_exit         \n" /* No schedule if curr = next */
-        "   mrs     r2, psp                 \n"
-        "   mrs     r3, psplim              \n"
-        "   stmdb   r2!, {r4-r11}           \n" /* Save callee registers */
-        "   stmia   r0, {r2, r3, r4, lr}    \n" /* Save struct context_ctrl_t */
-        "   ldmia   r1, {r2, r3, r4, lr}    \n" /* Load ctx of next thread */
-        "   ldmia   r2!, {r4-r11}           \n" /* Restore callee registers */
-        "   msr     psp, r2                 \n"
-        "   msr     psplim, r3              \n"
-        "v8m_pendsv_exit:                   \n"
-        "   bx      lr                      \n"
+        "tst     lr, #0x40                  \n" /* Was NS interrupted by S? */
+        "it      eq                         \n"
+        "bxeq    lr                         \n" /* Yes, do not schedule */
+        "mrs     r0, psp                    \n"
+        "mrs     r1, psplim                 \n"
+#if (TFM_SYSTEM_FP >= 1)
+        "tst     lr, #0x10                  \n" /* Current thread uses FPU? */
+        "bne     non_fp                     \n"
+        "ldr     r2, =0xE000EF34            \n"
+        "ldr     r3, [r2]                   \n"
+        "tst     r3, #0x40000000            \n" /* Lazy stacking enabled? */
+        "beq     non_fp                     \n"
+        "tst     r3, #0x1                   \n" /* Lazy stacking active? */
+        "beq     non_fp                     \n"
+        "vmov    s0, s0                     \n" /* Trigger lazy stacking */
+#if (TFM_LVL != 1)
+        "ldr     r3, =0xE000EF38            \n"
+        "mov     r1, 0                      \n"
+        "str     r1, [r3]                   \n" /* Clear FP context address */
+#endif /* TFM_LVL != 1 */
+        "non_fp:                            \n"
+#endif /* TFM_SYSTEM_FP >= 1 */        
+        "push    {r0, r1, r2, lr}           \n"
+        "push    {r4-r11}                   \n"
+        "mov     r0, sp                     \n"
+        "bl      tfm_pendsv_do_schedule     \n"
+        "pop     {r4-r11}                   \n"
+        "pop     {r0, r1, r2, lr}           \n"
+        "msr     psp, r0                    \n"
+        "msr     psplim, r1                 \n"
+        "bx      lr                         \n"
     );
 }
 
+void tfm_arch_init_actx(struct tfm_arch_ctx_t *p_actx,
+                        uint32_t sp, uint32_t sp_limit)
+{
+    p_actx->sp = sp;
+    p_actx->sp_limit = sp_limit;
+    p_actx->lr = EXC_RETURN_THREAD_S_PSP;
+}
+
 /**
  * \brief Overwrites default Secure fault handler.
  */
@@ -75,18 +125,19 @@ __attribute__((naked)) void SVC_Handler(void)
     "MRS     r0, MSP                        \n"
     "MOV     r1, lr                         \n"
     "MRS     r2, PSP                        \n"
+    "SUB     sp, #8                         \n" /* For FLIH PID and signal */
     "PUSH    {r1, r2}                       \n" /* Orig_exc_return, PSP */
-    "BL      tfm_core_svc_handler           \n"
+    "BL      tfm_core_svc_handler           \n" /* New EXC_RET returned */
     "MOV     lr, r0                         \n"
-    "POP     {r1, r2}                       \n" /* Orig_exc_return, PSP */
+    "LDR     r1, [sp]                       \n" /* Original EXC_RETURN */
     "AND     r0, #8                         \n" /* Mode bit */
-    "AND     r3, r1, #8                     \n"
-    "SUBS    r0, r3                         \n" /* Compare EXC_RETURN values */
+    "AND     r1, #8                         \n"
+    "SUBS    r0, r1                         \n" /* Compare EXC_RETURN values */
     "BGT     to_flih_func                   \n"
     "BLT     from_flih_func                 \n"
+    "ADD     sp, #16                        \n"
     "BX      lr                             \n"
     "to_flih_func:                          \n"
-    "PUSH    {r1, r2}                       \n" /* Orig_exc_return, PSP */
     "PUSH    {r4-r11}                       \n"
     "LDR     r4, =0xFEF5EDA5                \n" /* clear r4-r11 */
     "MOV     r5, r4                         \n"
@@ -99,9 +150,9 @@ __attribute__((naked)) void SVC_Handler(void)
     "PUSH    {r4, r5}                       \n" /* Seal stack before EXC_RET */
     "BX      lr                             \n"
     "from_flih_func:                        \n"
-    "POP     {r4, r5}                       \n" /* Seal stack */
+    "ADD     sp, #24                        \n"
     "POP     {r4-r11}                       \n"
-    "POP     {r1, r2}                       \n" /* Orig_exc_return, PSP */
+    "ADD     sp, #16                        \n"
     "BX      lr                             \n"
     );
 }
@@ -185,10 +236,9 @@ void tfm_arch_set_secure_exception_priorities(void)
      * When AIRCR.PRIS is set, the Non-Secure execution can act on
      * FAULTMASK_NS, PRIMASK_NS or BASEPRI_NS register to boost its priority
      * number up to the value 0x80.
-     * For this reason, set the priority of the PendSV interrupt to the next
-     * priority level configurable on the platform, just below 0x80.
+     * For this reason, set the priority of the PendSV interrupt to 0x80.
      */
-    NVIC_SetPriority(PendSV_IRQn, (1 << (__NVIC_PRIO_BITS - 1)) - 1);
+    NVIC_SetPriority(PendSV_IRQn, 1 << (__NVIC_PRIO_BITS - 1));
 #endif
 }
 
@@ -200,10 +250,19 @@ void tfm_arch_config_extensions(void)
      * latency when the FPU is not used by the SPE.
      */
 #if defined(__FPU_USED) && (__FPU_USED == 1U)
+/* For secure uses FPU only */
+#if (TFM_SYSTEM_FP >= 1)
     /* Enable Secure privileged and unprivilged access to the FP Extension */
     SCB->CPACR |= (3U << 10U*2U)     /* enable CP10 full access */
                   | (3U << 11U*2U);  /* enable CP11 full access */
 
+#ifdef TFM_LAZY_FP
+    /* Enable lazy stacking */
+    FPU->FPCCR |= FPU_FPCCR_LSPEN_Msk;
+#else
+    /* Disable lazy stacking */
+    FPU->FPCCR &= ~FPU_FPCCR_LSPEN_Msk;
+#endif
     /* If the SPE will ever use the floating-point registers for sensitive data,
      * then FPCCR.TS, FPCCR.CLRONRET and FPCCR.CLRONRETS must be set at
      * initialisation and not changed again afterwards.
@@ -211,14 +270,33 @@ void tfm_arch_config_extensions(void)
     FPU->FPCCR |= FPU_FPCCR_TS_Msk
                   | FPU_FPCCR_CLRONRET_Msk
                   | FPU_FPCCR_CLRONRETS_Msk;
+#if (TFM_SYSTEM_FP_NS == 0)
+    /* If FPU is used by secure only, prevent non-secure from modifying FPU’s
+     * power setting.
+     */
+    SCnSCB->CPPWR |= SCnSCB_CPPWR_SUS11_Msk | SCnSCB_CPPWR_SUS10_Msk;
 #endif
+#endif /* TFM_SYSTEM_FP >= 1 */
+
+#endif /* __FPU_USED */
+#endif /* __FPU_PRESENT */
+
+#if (TFM_SYSTEM_FP_NS >= 1)
 
     /* Permit Non-secure access to the Floating-point Extension.
      * Note: It is still necessary to set CPACR_NS to enable the FP Extension in
      * the NSPE. This configuration is left to NS privileged software.
      */
     SCB->NSACR |= SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk;
+
+#if (TFM_SYSTEM_FP == 0) && (TFM_LAZY_FP_NS == 0)
+    /* If only non-secure uses FPU with lazy stacking disabled, enable FPU on
+     * secure side as well.
+     */
+    SCB->CPACR |= (3U << 10U*2U)     /* enable CP10 full access */
+                  | (3U << 11U*2U);  /* enable CP11 full access */
 #endif
+#endif /* TFM_SYSTEM_FP_NS >= 1 */
 
 #if defined(__ARM_ARCH_8_1M_MAIN__)
     SCB->CCR |= SCB_CCR_TRD_Msk;
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/main.c b/lib/tf-m/secure_fw/spm/cmsis_psa/main.c
index b8e4ccc98..7ce7f1f2e 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/main.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/main.c
@@ -16,8 +16,6 @@
 #include "tfm_spm_hal.h"
 #include "tfm_spm_log.h"
 #include "tfm_version.h"
-#include "tfm_plat_otp.h"
-#include "tfm_plat_provisioning.h"
 
 /*
  * Avoids the semihosting issue
@@ -33,7 +31,7 @@ __asm("  .global __ARM_use_no_argv\n");
 #error Invalid TFM_LVL value. Only TFM_LVL 1, 2 and 3 are supported in IPC model!
 #endif
 
-REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Base);
+REGION_DECLARE(Image$$, ARM_LIB_STACK_MSP,  $$ZI$$Base);
 
 static fih_int tfm_core_init(void)
 {
@@ -97,21 +95,6 @@ static fih_int tfm_core_init(void)
         FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
     }
 
-    plat_err = tfm_plat_otp_init();
-    if (plat_err != TFM_PLAT_ERR_SUCCESS) {
-            FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
-    }
-
-    /* Perform provisioning. */
-    if (tfm_plat_provisioning_is_required()) {
-        plat_err = tfm_plat_provisioning_perform();
-        if (plat_err != TFM_PLAT_ERR_SUCCESS) {
-            FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
-        }
-    } else {
-        tfm_plat_provisioning_check_for_dummy_keys();
-    }
-
     /* Configures architecture */
     tfm_arch_config_extensions();
 
@@ -119,6 +102,24 @@ static fih_int tfm_core_init(void)
 
     SPMLOG_DBGMSGVAL("TF-M isolation level is: ", TFM_LVL);
 
+#if (TFM_SYSTEM_FP == 0)
+    SPMLOG_INFMSG("\033[1;33mTF-M FPU mode: Software\033[0m\r\n");
+#elif (TFM_SYSTEM_FP == 1)
+    SPMLOG_INFMSG("\033[1;33mTF-M FPU mode: Hybird\033[0m\r\n");
+#elif (TFM_SYSTEM_FP == 2)
+    SPMLOG_INFMSG("\033[1;33mTF-M FPU mode: Hardware\033[0m\r\n");
+#endif
+
+#if (TFM_SYSTEM_FP >= 1)
+#ifdef TFM_LAZY_FP
+    SPMLOG_INFMSG("\033[1;33mLazy stacking(S) enabled\033[0m\r\n");
+#elif defined TFM_LAZY_FP_NS
+    SPMLOG_INFMSG("\033[1;33mLazy stacking(NS) enabled\033[0m\r\n");
+#else
+    SPMLOG_INFMSG("\033[1;33mLazy stacking disabled\033[0m\r\n");
+#endif
+#endif
+
     tfm_core_validate_boot_data();
 
     configure_ns_code();
@@ -140,24 +141,13 @@ static fih_int tfm_core_init(void)
     FIH_RET(fih_int_encode(TFM_SUCCESS));
 }
 
-__attribute__((naked))
 int main(void)
-{
-    __ASM volatile(
-        "ldr    r0, =0xFEF5EDA5     \n" /* Seal Main Stack before using */
-        "ldr    r1, =0xFEF5EDA5     \n"
-        "push   {r0, r1}            \n"
-        "bl     c_main              \n"
-    );
-}
-
-int c_main(void)
 {
     fih_int fih_rc = FIH_FAILURE;
 
     /* set Main Stack Pointer limit */
-    tfm_arch_set_msplim((uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK,
-                                                                   $$ZI$$Base));
+    tfm_arch_init_secure_msp((uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK_MSP,
+                                               $$ZI$$Base));
 
     fih_delay_init();
 
@@ -178,8 +168,8 @@ int c_main(void)
      */
     tfm_arch_set_secure_exception_priorities();
 
+    tfm_arch_clear_fp_status();
+
     /* Move to handler mode for further SPM initialization. */
     tfm_core_handler_mode();
-
-    return 0;
 }
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.c b/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.c
index 729374d20..2db3dce6b 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.c
@@ -11,41 +11,47 @@
 #include "fih.h"
 #include "psa/client.h"
 #include "psa/service.h"
-#include "thread.h"
+#include "tfm_thread.h"
+#include "tfm_wait.h"
 #include "internal_errors.h"
 #include "tfm_spm_hal.h"
 #include "tfm_api.h"
 #include "tfm_secure_api.h"
 #include "tfm_memory_utils.h"
 #include "tfm_hal_defs.h"
-#include "tfm_hal_interrupt.h"
 #include "tfm_hal_isolation.h"
 #include "spm_ipc.h"
 #include "tfm_peripherals_def.h"
 #include "tfm_core_utils.h"
-#include "tfm_nspm.h"
 #include "tfm_rpc.h"
 #include "tfm_core_trustzone.h"
 #include "lists.h"
 #include "tfm_pools.h"
-#include "region.h"
+#include "spm_partition_defs.h"
 #include "psa_manifest/pid.h"
+#include "tfm/tfm_spm_services.h"
 #include "load/partition_defs.h"
 #include "load/service_defs.h"
 #include "load/asset_defs.h"
 #include "load/spm_load_api.h"
+#include "load/irq_defs.h"
 
 /* Partition and service runtime data list head/runtime data table */
 static struct partition_head_t partitions_listhead;
 static struct service_head_t services_listhead;
 struct service_t *stateless_services_ref_tbl[STATIC_HANDLE_NUM_LIMIT];
 
-struct thread_t *pth_curr;
-
 /* Pools */
 TFM_POOL_DECLARE(conn_handle_pool, sizeof(struct tfm_conn_handle_t),
                  TFM_CONN_HANDLE_MAX_NUM);
 
+void spm_interrupt_handler(struct partition_load_info_t *p_ldinf,
+                           psa_signal_t signal,
+                           uint32_t irq_line,
+                           psa_flih_func flih_func);
+
+#include "tfm_secure_irq_handlers_ipc.inc"
+
 /*********************** Connection handle conversion APIs *******************/
 
 #define CONVERSION_FACTOR_BITOFFSET    3
@@ -256,6 +262,34 @@ struct tfm_msg_body_t *tfm_spm_get_msg_by_signal(struct partition_t *partition,
     return msg;
 }
 
+#if TFM_LVL != 1
+/**
+ * \brief Change the privilege mode for partition thread mode.
+ *
+ * \param[in] privileged        Privileged mode,
+ *                                \ref TFM_PARTITION_PRIVILEGED_MODE
+ *                                and \ref TFM_PARTITION_UNPRIVILEGED_MODE
+ *
+ * \note Barrier instructions are not called by this function, and if
+ *       it is called in thread mode, it might be necessary to call
+ *       them after this function returns.
+ */
+static void tfm_spm_partition_change_privilege(uint32_t privileged)
+{
+    CONTROL_Type ctrl;
+
+    ctrl.w = __get_CONTROL();
+
+    if (privileged == TFM_PARTITION_PRIVILEGED_MODE) {
+        ctrl.b.nPRIV = 0;
+    } else {
+        ctrl.b.nPRIV = 1;
+    }
+
+    __set_CONTROL(ctrl.w);
+}
+#endif /* if(TFM_LVL != 1) */
+
 uint32_t tfm_spm_partition_get_privileged_mode(uint32_t partition_flags)
 {
 #if TFM_LVL == 1
@@ -271,12 +305,11 @@ uint32_t tfm_spm_partition_get_privileged_mode(uint32_t partition_flags)
 
 struct service_t *tfm_spm_get_service_by_sid(uint32_t sid)
 {
-    struct service_t *p_prev, *p_curr;
+    struct service_t *p_serv;
 
-    UNI_LIST_FOR_EACH_PREV(p_prev, p_curr, &services_listhead) {
-        if (p_curr->p_ldinf->sid == sid) {
-            UNI_LIST_MOVE_AFTER(&services_listhead, p_prev, p_curr);
-            return p_curr;
+    UNI_LIST_FOR_EACH(p_serv, &services_listhead) {
+        if (p_serv->p_ldinf->sid == sid) {
+            return p_serv;
         }
     }
 
@@ -307,7 +340,12 @@ struct partition_t *tfm_spm_get_partition_by_id(int32_t partition_id)
 
 struct partition_t *tfm_spm_get_running_partition(void)
 {
-    return TO_CONTAINER(pth_curr, struct partition_t, thrd);
+    struct tfm_core_thread_t *pth = tfm_core_thrd_get_curr();
+    struct partition_t *partition;
+
+    partition = TO_CONTAINER(pth, struct partition_t, sp_thread);
+
+    return partition;
 }
 
 int32_t tfm_spm_check_client_version(struct service_t *service,
@@ -380,9 +418,9 @@ struct tfm_msg_body_t *tfm_spm_get_msg_from_handle(psa_handle_t msg_handle)
      * Check the conditions above
      */
     struct tfm_msg_body_t *p_msg;
-    int32_t partition_id;
+    uint32_t partition_id;
     struct tfm_conn_handle_t *p_conn_handle =
-                                    tfm_spm_to_handle_instance(msg_handle);
+                                     tfm_spm_to_handle_instance(msg_handle);
 
     if (is_valid_chunk_data_in_pool(
         conn_handle_pool, (uint8_t *)p_conn_handle) != 1) {
@@ -438,7 +476,7 @@ void tfm_spm_fill_msg(struct tfm_msg_body_t *msg,
     /* Clear message buffer before using it */
     spm_memset(msg, 0, sizeof(struct tfm_msg_body_t));
 
-    THRD_SYNC_INIT(&msg->ack_evnt);
+    tfm_event_init(&msg->ack_evnt);
     msg->magic = TFM_MSG_MAGIC;
     msg->service = service;
     msg->caller_outvec = caller_outvec;
@@ -494,8 +532,8 @@ void tfm_spm_send_event(struct service_t *service,
     partition->signals_asserted |= signal;
 
     if (partition->signals_waiting & signal) {
-        thrd_wake_up(
-                    &partition->waitobj,
+        tfm_event_wake(
+                    &partition->event,
                     (partition->signals_asserted & partition->signals_waiting));
         partition->signals_waiting &= ~signal;
     }
@@ -505,11 +543,11 @@ void tfm_spm_send_event(struct service_t *service,
      * thread.
      */
     if (!is_tfm_rpc_msg(msg)) {
-        thrd_wait_on(&msg->ack_evnt, pth_curr);
+        tfm_event_wait(&msg->ack_evnt);
     }
 }
 
-int32_t tfm_spm_partition_get_running_partition_id(void)
+uint32_t tfm_spm_partition_get_running_partition_id(void)
 {
     struct partition_t *partition;
 
@@ -566,67 +604,15 @@ int32_t tfm_memory_check(const void *buffer, size_t len, bool ns_caller,
     return SPM_ERROR_MEMORY_CHECK;
 }
 
-bool tfm_spm_is_ns_caller(void)
-{
-#if defined(TFM_MULTI_CORE_TOPOLOGY) || defined(FORWARD_PROT_MSG)
-    /* Multi-core NS PSA API request is processed by pendSV. */
-    return (__get_active_exc_num() == EXC_NUM_PENDSV);
-#else
-    struct partition_t *partition = tfm_spm_get_running_partition();
-
-    if (!partition) {
-        tfm_core_panic();
-    }
-
-    return (partition->p_ldinf->pid == TFM_SP_NON_SECURE_ID);
-#endif
-}
-
-uint32_t tfm_spm_get_caller_privilege_mode(void)
-{
-    struct partition_t *partition;
-
-#if defined(TFM_MULTI_CORE_TOPOLOGY) || defined(FORWARD_PROT_MSG)
-    /*
-     * In multi-core topology, if PSA request is from mailbox, the client
-     * is unprivileged.
-     */
-    if (__get_active_exc_num() == EXC_NUM_PENDSV) {
-        return TFM_PARTITION_UNPRIVILEGED_MODE;
-    }
-#endif
-    partition = tfm_spm_get_running_partition();
-    if (!partition) {
-        tfm_core_panic();
-    }
-
-    return tfm_spm_partition_get_privileged_mode(partition->p_ldinf->flags);
-}
-
-int32_t tfm_spm_get_client_id(bool ns_caller)
-{
-    int32_t client_id;
-
-    if (ns_caller) {
-        client_id = tfm_nspm_get_current_client_id();
-    } else {
-        client_id = tfm_spm_partition_get_running_partition_id();
-    }
-
-    if (ns_caller != (client_id < 0)) {
-        /* NS client ID must be negative and Secure ID must >= 0 */
-        tfm_core_panic();
-    }
-
-    return client_id;
-}
-
 uint32_t tfm_spm_init(void)
 {
+    uint32_t i;
+    bool privileged;
     struct partition_t *partition;
+    struct tfm_core_thread_t *pth, *p_ns_entry_thread = NULL;
+    const struct platform_data_t *platform_data_p;
     const struct partition_load_info_t *p_ldinf;
-    void *p_param, *p_boundaries = NULL;
-
+    struct asset_desc_t *p_asset_load;
 #ifdef TFM_FIH_PROFILE_ON
     fih_int fih_rc = FIH_FAILURE;
 #endif
@@ -641,7 +627,7 @@ uint32_t tfm_spm_init(void)
 
     while (1) {
         partition = load_a_partition_assuredly(&partitions_listhead);
-        if (partition == NO_MORE_PARTITION) {
+        if (partition == NULL) {
             break;
         }
 
@@ -657,86 +643,176 @@ uint32_t tfm_spm_init(void)
             load_irqs_assuredly(partition);
         }
 
-        /* Bind the partition with plaform. */
-#if TFM_FIH_PROFILE_ON
-        FIH_CALL(tfm_hal_bind_boundaries, fih_rc, partition->p_ldinf,
-                 &p_boundaries);
-        if (fih_not_eq(fih_rc, fih_int_encode(TFM_HAL_SUCCESS))) {
-            tfm_core_panic();
+        /* Init mmio assets */
+        if (p_ldinf->nassets > 0) {
+            if (tfm_spm_partition_get_privileged_mode(p_ldinf->flags) ==
+                TFM_PARTITION_PRIVILEGED_MODE) {
+                privileged = true;
+            } else {
+                privileged = false;
+            }
         }
+
+        p_asset_load = (struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
+        for (i = 0; i < p_ldinf->nassets; i++) {
+            /* Skip the memory-based asset */
+            if (!(p_asset_load[i].attr & ASSET_DEV_REF_BIT)) {
+                continue;
+            }
+
+            platform_data_p = REFERENCE_TO_PTR(p_asset_load[i].dev.addr_ref,
+                                               struct platform_data_t *);
+
+            /*
+             * TODO: some partitions declare MMIO not exist on specific
+             * platforms, and the platform defines a dummy NULL reference
+             * for these MMIO items, which cause 'nassets' to contain several
+             * NULL items. Skip these NULL items initialization temporarily to
+             * avoid HAL API panic.
+             * Eventually, these platform-specific partitions need to be moved
+             * into a platform-specific folder. Then this workaround can be
+             * removed.
+             */
+            if (!platform_data_p) {
+                continue;
+            }
+
+#ifdef TFM_FIH_PROFILE_ON
+            FIH_CALL(tfm_spm_hal_configure_default_isolation, fih_rc,
+                     privileged, platform_data_p);
+            if (fih_not_eq(fih_rc, fih_int_encode(TFM_PLAT_ERR_SUCCESS))) {
+                tfm_core_panic();
+            }
 #else /* TFM_FIH_PROFILE_ON */
-        if (tfm_hal_bind_boundaries(partition->p_ldinf,
-                                    &p_boundaries) != TFM_HAL_SUCCESS) {
-            tfm_core_panic();
-        }
+            if (tfm_spm_hal_configure_default_isolation(privileged,
+                platform_data_p) != TFM_PLAT_ERR_SUCCESS) {
+                tfm_core_panic();
+            }
 #endif /* TFM_FIH_PROFILE_ON */
+        }
 
-        partition->p_boundaries = p_boundaries;
         partition->signals_allowed |= PSA_DOORBELL;
 
-        THRD_SYNC_INIT(&partition->waitobj);
+        tfm_event_init(&partition->event);
         BI_LIST_INIT_NODE(&partition->msg_list);
 
-        THRD_INIT(&partition->thrd, &partition->ctx_ctrl,
-                  TO_THREAD_PRIORITY(PARTITION_PRIORITY(p_ldinf->flags)));
+        pth = &partition->sp_thread;
+        if (!pth) {
+            tfm_core_panic();
+        }
+
+        /* Extendable partition load info is right after p_ldinf. */
+        tfm_core_thrd_init(
+                    pth,
+                    POSITION_TO_ENTRY(p_ldinf->entry, tfm_core_thrd_entry_t),
+                    NULL,
+                    LOAD_ALLOCED_STACK_ADDR(p_ldinf) + p_ldinf->stack_size,
+                    LOAD_ALLOCED_STACK_ADDR(p_ldinf));
+
+        pth->prior = TO_THREAD_PRIORITY(PARTITION_PRIORITY(p_ldinf->flags));
 
-        p_param = NULL;
         if (p_ldinf->pid == TFM_SP_NON_SECURE_ID) {
-            p_param = (void *)tfm_spm_hal_get_ns_entry_point();
+            p_ns_entry_thread = pth;
+            pth->param = (void *)tfm_spm_hal_get_ns_entry_point();
         }
 
-        thrd_start(&partition->thrd,
-                   POSITION_TO_ENTRY(p_ldinf->entry, thrd_fn_t), p_param,
-                   LOAD_ALLOCED_STACK_ADDR(p_ldinf),
-                   LOAD_ALLOCED_STACK_ADDR(p_ldinf) + p_ldinf->stack_size);
+        /* Kick off */
+        if (tfm_core_thrd_start(pth) != THRD_SUCCESS) {
+            tfm_core_panic();
+        }
     }
 
-    return thrd_start_scheduler(&pth_curr);
-}
+    /*
+     * All threads initialized, start the scheduler.
+     *
+     * NOTE:
+     * It is worthy to give the thread object to scheduler if the background
+     * context belongs to one of the threads. Here the background thread is the
+     * initialization thread who calls SPM SVC, which re-uses the non-secure
+     * entry thread's stack. After SPM initialization is done, this stack is
+     * cleaned up and the background context is never going to return. Tell
+     * the scheduler that the current thread is non-secure entry thread.
+     */
+    tfm_core_thrd_start_scheduler(p_ns_entry_thread);
 
-/*
- * Return both current and next context to assembly via AAPCS trick:
- *   - Returning a 64 bit integer by 32-bit R0 and R1.
- *
- * This is architecture-specific, hence the scheduler entry and this
- * 'do_schedule' MAY be different on another architecture.
- */
-union returning_contexts_t {
-    struct {
-        uint32_t curr;
-        uint32_t next;
-    } ctx;
+    return p_ns_entry_thread->arch_ctx.lr;
+}
 
-    uint64_t curr_next_ctxs;
-};
+#if TFM_LVL != 1
+static void set_up_boundary(const struct partition_load_info_t *p_ldinf)
+{
+#if TFM_LVL == 3
+#if defined(TFM_FIH_PROFILE_ON) && (TFM_LVL == 3)
+    fih_int fih_rc = FIH_FAILURE;
+#endif
+    /*
+     * FIXME: To implement isolations among partitions in isolation level 3,
+     * each partition needs to run in unprivileged mode. Currently some
+     * PRoTs cannot work in unprivileged mode, make them privileged now.
+     */
+    if (!(p_ldinf->flags & SPM_PART_FLAG_PSA_ROT)) {
+        struct asset_desc_t *p_asset =
+            (struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
+        /* Partition must have private data as the first asset in LVL3 */
+        if (p_ldinf->nassets == 0) {
+            tfm_core_panic();
+        }
+        if (p_asset->attr & ASSET_DEV_REF_BIT) {
+            tfm_core_panic();
+        }
+        /* FIXME: only MPU-based implementations are supported currently */
+#ifdef TFM_FIH_PROFILE_ON
+        FIH_CALL(tfm_hal_mpu_update_partition_boundary, fih_rc,
+                    p_asset->mem.addr_x, p_asset->mem.addr_y);
+        if (fih_not_eq(fih_rc, fih_int_encode(TFM_HAL_SUCCESS))) {
+            tfm_core_panic();
+        }
+#else /* TFM_FIH_PROFILE_ON */
+        if (tfm_hal_mpu_update_partition_boundary(p_asset->mem.addr_x,
+                                                  p_asset->mem.addr_y)
+                                                           != TFM_HAL_SUCCESS) {
+            tfm_core_panic();
+        }
+#endif /* TFM_FIH_PROFILE_ON */
+    }
+#else /* TFM_LVL == 3 */
+    (void)p_ldinf;
+#endif /* TFM_LVL == 3 */
+}
+#endif /* TFM_LVL != 1 */
 
-uint64_t do_schedule(void)
+void tfm_set_up_isolation_boundary(const struct partition_t *partition)
 {
-    union returning_contexts_t ret;
-    struct partition_t *p_part_curr, *p_part_next;
-    struct thread_t *pth_next = thrd_next();
+#if TFM_LVL != 1
+    const struct partition_load_info_t *p_ldinf;
+    uint32_t is_privileged;
 
-    p_part_curr = TO_CONTAINER(pth_curr, struct partition_t, thrd);
-    p_part_next = TO_CONTAINER(pth_next, struct partition_t, thrd);
+    p_ldinf = partition->p_ldinf;
+    is_privileged = p_ldinf->flags & SPM_PART_FLAG_PSA_ROT ?
+                                                TFM_PARTITION_PRIVILEGED_MODE :
+                                                TFM_PARTITION_UNPRIVILEGED_MODE;
 
-    if (pth_next != NULL && p_part_curr != p_part_next) {
-        /* Check if there is enough room on stack to save more context */
-        if ((p_part_curr->ctx_ctrl.sp_limit +
-             sizeof(struct tfm_additional_context_t)) > __get_PSP()) {
-            tfm_core_panic();
-        }
+    tfm_spm_partition_change_privilege(is_privileged);
 
-        /*
-         * If required, let the platform update boundary based on its
-         * implementation. Change privilege, MPU or other configurations.
-         */
-        if (p_part_curr->p_boundaries != p_part_next->p_boundaries) {
-            if (tfm_hal_update_boundaries(p_part_next->p_ldinf,
-                                          p_part_next->p_boundaries)
-                                                        != TFM_HAL_SUCCESS) {
-                tfm_core_panic();
-            }
-        }
+    set_up_boundary(p_ldinf);
+#else /* TFM_LVL != 1 */
+    (void)partition;
+#endif /* TFM_LVL != 1 */
+}
+
+void tfm_pendsv_do_schedule(struct tfm_arch_ctx_t *p_actx)
+{
+    struct partition_t *p_next_partition;
+    struct tfm_core_thread_t *pth_next = tfm_core_thrd_get_next();
+    struct tfm_core_thread_t *pth_curr = tfm_core_thrd_get_curr();
+
+    if (pth_next != NULL && pth_curr != pth_next) {
+        p_next_partition = TO_CONTAINER(pth_next,
+                                        struct partition_t,
+                                        sp_thread);
+        tfm_set_up_isolation_boundary(p_next_partition);
+
+        tfm_core_thrd_switch_context(p_actx, pth_curr, pth_next);
     }
 
     /*
@@ -744,13 +820,6 @@ uint64_t do_schedule(void)
      * Empty operation on single Armv8-M platform.
      */
     tfm_rpc_client_call_handler();
-
-    ret.ctx.curr = (uint32_t)pth_curr->p_context_ctrl;
-    ret.ctx.next = (uint32_t)pth_next->p_context_ctrl;
-
-    pth_curr = pth_next;
-
-    return ret.curr_next_ctxs;
 }
 
 void update_caller_outvec_len(struct tfm_msg_body_t *msg)
@@ -777,10 +846,24 @@ void update_caller_outvec_len(struct tfm_msg_body_t *msg)
     }
 }
 
-void spm_assert_signal(void *p_pt, psa_signal_t signal)
+void notify_with_signal(int32_t partition_id, psa_signal_t signal)
 {
-    struct partition_t *partition = (struct partition_t *)p_pt;
+    struct partition_t *partition = NULL;
 
+    /*
+     * The value of partition_id must be greater than zero as the target of
+     * notification must be a Secure Partition, providing a Non-secure
+     * Partition ID is a fatal error.
+     */
+    if (!TFM_CLIENT_ID_IS_S(partition_id)) {
+        tfm_core_panic();
+    }
+
+    /*
+     * It is a fatal error if partition_id does not correspond to a Secure
+     * Partition.
+     */
+    partition = tfm_spm_get_partition_by_id(partition_id);
     if (!partition) {
         tfm_core_panic();
     }
@@ -788,58 +871,59 @@ void spm_assert_signal(void *p_pt, psa_signal_t signal)
     partition->signals_asserted |= signal;
 
     if (partition->signals_waiting & signal) {
-        thrd_wake_up(&partition->waitobj,
-                     partition->signals_asserted & partition->signals_waiting);
+        tfm_event_wake(
+                      &partition->event,
+                      partition->signals_asserted & partition->signals_waiting);
         partition->signals_waiting &= ~signal;
     }
 }
 
 __attribute__((naked))
-static psa_flih_result_t tfm_flih_deprivileged_handling(void *p_pt,
-                                                        uintptr_t fn_flih,
-                                                        void *p_context_ctrl)
+static void tfm_flih_deprivileged_handling(uint32_t p_ldinf,
+                                           psa_flih_func flih_func,
+                                           psa_signal_t signal)
 {
     __ASM volatile("SVC %0           \n"
                    "BX LR            \n"
                    : : "I" (TFM_SVC_PREPARE_DEPRIV_FLIH));
 }
 
-void spm_handle_interrupt(void *p_pt, struct irq_load_info_t *p_ildi)
+void spm_interrupt_handler(struct partition_load_info_t *p_ldinf,
+                           psa_signal_t signal,
+                           uint32_t irq_line,
+                           psa_flih_func flih_func)
 {
+    uint32_t pid;
     psa_flih_result_t flih_result;
-    struct partition_t *p_part;
-
-    if (!p_pt || !p_ildi) {
-        tfm_core_panic();
-    }
 
-    p_part = (struct partition_t *)p_pt;
+    pid = p_ldinf->pid;
 
-    if (p_ildi->pid != p_part->p_ldinf->pid) {
-        tfm_core_panic();
+    if (flih_func == NULL) {
+        /* SLIH Model Handling */
+        __disable_irq();
+        tfm_spm_hal_disable_irq(irq_line);
+        notify_with_signal(pid, signal);
+        __enable_irq();
+        return;
     }
 
-    if (p_ildi->flih_func == NULL) {
-        /* SLIH Model Handling */
-        tfm_hal_irq_disable(p_ildi->source);
-        flih_result = PSA_FLIH_SIGNAL;
-    } else {
-        /* FLIH Model Handling */
-        if (tfm_spm_partition_get_privileged_mode(p_part->p_ldinf->flags) ==
+    /* FLIH Model Handling */
+    if (tfm_spm_partition_get_privileged_mode(p_ldinf->flags) ==
                                                 TFM_PARTITION_PRIVILEGED_MODE) {
-            flih_result = p_ildi->flih_func();
-        } else {
-            flih_result = tfm_flih_deprivileged_handling(
-                                                   p_part,
-                                                   (uintptr_t)p_ildi->flih_func,
-                                                   pth_curr->p_context_ctrl);
+        flih_result = flih_func();
+        if (flih_result == PSA_FLIH_SIGNAL) {
+            __disable_irq();
+            notify_with_signal(pid, signal);
+            __enable_irq();
+        } else if (flih_result != PSA_FLIH_NO_SIGNAL) {
+            /*
+             * Nothing needed to do for PSA_FLIH_NO_SIGNAL
+             * But if the flih_result is invalid, should panic.
+             */
+            tfm_core_panic();
         }
-    }
-
-    if (flih_result == PSA_FLIH_SIGNAL) {
-        __disable_irq();
-        spm_assert_signal(p_pt, p_ildi->signal);
-        __enable_irq();
+    } else {
+        tfm_flih_deprivileged_handling((uint32_t)p_ldinf, flih_func, signal);
     }
 }
 
@@ -863,3 +947,80 @@ struct irq_load_info_t *get_irq_info_for_signal(
 
     return NULL;
 }
+
+#if !defined(__ARM_ARCH_8_1M_MAIN__)
+void tfm_spm_validate_caller(struct partition_t *p_cur_sp, uint32_t *p_ctx,
+                             uint32_t exc_return, bool ns_caller)
+{
+    uintptr_t stacked_ctx_pos;
+
+    if (ns_caller) {
+        /*
+         * The background IRQ can't be supported, since if SP is executing,
+         * the preempted context of SP can be different with the one who
+         * preempts veneer.
+         */
+        if (p_cur_sp->p_ldinf->pid != TFM_SP_NON_SECURE_ID) {
+            tfm_core_panic();
+        }
+
+        /*
+         * It is non-secure caller, check if veneer stack contains
+         * multiple contexts.
+         */
+        stacked_ctx_pos = (uintptr_t)p_ctx +
+                          sizeof(struct tfm_state_context_t) +
+                          TFM_STACK_SEALED_SIZE;
+
+        if (is_stack_alloc_fp_space(exc_return)) {
+#if defined(__FPU_USED) && (__FPU_USED == 1U)
+            if (FPU->FPCCR & FPU_FPCCR_TS_Msk) {
+                stacked_ctx_pos += TFM_ADDTIONAL_FP_CONTEXT_WORDS *
+                                   sizeof(uint32_t);
+            }
+#endif
+            stacked_ctx_pos += TFM_BASIC_FP_CONTEXT_WORDS * sizeof(uint32_t);
+        }
+
+        if (stacked_ctx_pos != p_cur_sp->sp_thread.stk_top) {
+            tfm_core_panic();
+        }
+    } else if (p_cur_sp->p_ldinf->pid <= 0) {
+        tfm_core_panic();
+    }
+}
+#endif
+
+void tfm_spm_request_handler(const struct tfm_state_context_t *svc_ctx)
+{
+    uint32_t *res_ptr = (uint32_t *)&svc_ctx->r0;
+    uint32_t running_partition_flags = 0;
+    const struct partition_t *partition = NULL;
+
+    /* Check permissions on request type basis */
+
+    switch (svc_ctx->r0) {
+    case TFM_SPM_REQUEST_RESET_VOTE:
+        partition = tfm_spm_get_running_partition();
+        if (!partition) {
+            tfm_core_panic();
+        }
+        running_partition_flags = partition->p_ldinf->flags;
+
+        /* Currently only PSA Root of Trust services are allowed to make Reset
+         * vote request
+         */
+        if ((running_partition_flags & SPM_PART_FLAG_PSA_ROT) == 0) {
+            *res_ptr = (uint32_t)TFM_ERROR_GENERIC;
+        }
+
+        /* FixMe: this is a placeholder for checks to be performed before
+         * allowing execution of reset
+         */
+        *res_ptr = (uint32_t)TFM_SUCCESS;
+
+        break;
+    default:
+        *res_ptr = (uint32_t)TFM_ERROR_INVALID_PARAMETER;
+    }
+}
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.h b/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.h
index 7cc0553ad..43b836b88 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.h
@@ -9,12 +9,13 @@
 #define __SPM_IPC_H__
 
 #include <stdint.h>
+#include "spm_partition_defs.h"
 #include "tfm_arch.h"
 #include "lists.h"
+#include "tfm_wait.h"
 #include "tfm_secure_api.h"
-#include "thread.h"
+#include "tfm_thread.h"
 #include "psa/service.h"
-#include "load/interrupt_defs.h"
 
 #define TFM_HANDLE_STATUS_IDLE          0
 #define TFM_HANDLE_STATUS_ACTIVE        1
@@ -59,7 +60,7 @@
 struct tfm_msg_body_t {
     int32_t magic;
     struct service_t *service;         /* RoT service pointer            */
-    struct sync_obj_t ack_evnt;        /* Event for ack response         */
+    struct tfm_event_t ack_evnt;       /* Event for ack response         */
     psa_msg_t msg;                     /* PSA message body               */
     psa_invec invec[PSA_MAX_IOVEC];    /* Put in/out vectors in msg body */
     psa_outvec outvec[PSA_MAX_IOVEC];
@@ -77,20 +78,22 @@ struct tfm_msg_body_t {
     struct bi_list_node_t msg_node;    /* For list operators             */
 };
 
-/* Partition runtime type */
+/**
+ * Holds the fields that define a partition for SPM. The fields are further
+ * divided to structures, to keep the related fields close to each other.
+ */
 struct partition_t {
     const struct partition_load_info_t *p_ldinf;
-    void                               *p_boundaries;
-    void                               *p_interrupts;
-    void                               *p_metadata;
-    struct thread_t                    thrd;
-    struct sync_obj_t                  waitobj;
-    struct context_ctrl_t              ctx_ctrl;
-    struct bi_list_node_t              msg_list;
-    uint32_t                           signals_allowed;
-    uint32_t                           signals_waiting;
-    uint32_t                           signals_asserted;
-    struct partition_t                 *next;
+    void *p_platform;
+    void *p_interrupts;
+    void *p_metadata;
+    struct tfm_core_thread_t sp_thread;
+    struct tfm_event_t event;
+    struct bi_list_node_t msg_list;
+    uint32_t signals_allowed;
+    uint32_t signals_waiting;
+    uint32_t signals_asserted;
+    struct partition_t *next;
 };
 
 /* RoT Service data */
@@ -137,12 +140,18 @@ enum tfm_memory_access_e {
  */
 uint32_t tfm_spm_partition_get_privileged_mode(uint32_t partition_flags);
 
+/**
+ * \brief                   Handle an SPM request by a secure service
+ * \param[in] svc_ctx       The stacked SVC context
+ */
+void tfm_spm_request_handler(const struct tfm_state_context_t *svc_ctx);
+
 /**
  * \brief   Get the running partition ID.
  *
  * \return  Returns the partition ID
  */
-int32_t tfm_spm_partition_get_running_partition_id(void);
+uint32_t tfm_spm_partition_get_running_partition_id(void);
 
 /******************** Service handle management functions ********************/
 
@@ -346,31 +355,11 @@ int32_t tfm_memory_check(const void *buffer, size_t len, bool ns_caller,
                          uint32_t privileged);
 
 /**
- * \brief                       Get the ns_caller info from runtime context.
- *
- * \retval                      - true: the PSA API caller is from non-secure
- *                              - false: the PSA API caller is from secure
- */
-bool tfm_spm_is_ns_caller(void);
-
-/**
- * \brief                       Get the privilege mode of service caller.
- *
- * \retval                      Privilege mode of the service caller
- *                              \ref TFM_PARTITION_UNPRIVILEGED_MODE
- *                              \ref TFM_PARTITION_PRIVILEGED_MODE
- */
-uint32_t tfm_spm_get_caller_privilege_mode(void);
-
-/**
- * \brief               Get ID of current RoT Service client.
- *                      This API ensures the caller gets a valid ID.
- *
- * \param[in] ns_caller If the client is Non-Secure or not.
+ * \brief               Set up the isolation boundary of the given partition.
  *
- * \retval              The client ID
+ * \param[in] partition The partition of which the boundary is set up.
  */
-int32_t tfm_spm_get_client_id(bool ns_caller);
+void tfm_set_up_isolation_boundary(const struct partition_t *partition);
 
 /*
  * PendSV specified function.
@@ -378,13 +367,11 @@ int32_t tfm_spm_get_client_id(bool ns_caller);
  * Parameters :
  *  p_actx        -    Architecture context storage pointer
  *
- * Return:
- *  Pointers to context control (sp, splimit, dummy, lr) of the current and
- *  the next thread.
- *  Each takes 32 bits. The context control is used by PendSV_Handler to do
- *  context switch.
+ * Notes:
+ *  This is a staging API. Scheduler should be called in SPM finally and
+ *  this function will be obsoleted later.
  */
-uint64_t do_schedule(void);
+void tfm_pendsv_do_schedule(struct tfm_arch_ctx_t *p_actx);
 
 /**
  * \brief                      SPM initialization implementation
@@ -396,6 +383,41 @@ uint64_t do_schedule(void);
  */
 uint32_t tfm_spm_init(void);
 
+#if !defined(__ARM_ARCH_8_1M_MAIN__)
+/**
+ * \brief Validate the whether NS caller re-enter.
+ *
+ * \param[in] p_cur_sp          Pointer to current partition.
+ * \param[in] p_ctx             Pointer to current stack context.
+ * \param[in] exc_return        EXC_RETURN value.
+ * \param[in] ns_caller         If 'true', call from non-secure client.
+ *                              Or from secure client.
+ *
+ * \retval void                 Success.
+ *
+ * Notes:
+ *  For architecture v8.1m and later, will use hardware re-entrant detection.
+ *  Otherwise will use the software solution to validate the caller.
+ */
+void tfm_spm_validate_caller(struct partition_t *p_cur_sp, uint32_t *p_ctx,
+                             uint32_t exc_return, bool ns_caller);
+#else
+/**
+ * In v8.1 mainline, will use hardware re-entrant detection instead.
+ */
+__STATIC_INLINE
+void tfm_spm_validate_caller(struct partition_t *p_cur_sp, uint32_t *p_ctx,
+                             uint32_t exc_return, bool ns_caller)
+{
+    (void)p_cur_sp;
+    (void)p_ctx;
+    (void)exc_return;
+    (void)ns_caller;
+    return;
+}
+#endif
+
+
 /**
  * \brief Converts a handle instance into a corresponded user handle.
  */
@@ -429,12 +451,17 @@ int32_t tfm_spm_set_rhandle(struct service_t *service,
 
 void update_caller_outvec_len(struct tfm_msg_body_t *msg);
 
-/*
- * Set partition signal.
+/**
+ * \brief   notify the partition with the signal.
  *
- * Assert a signal to given partition.
+ * \param[in] partition_id      The ID of the partition to be notified.
+ * \param[in] signal            The signal that the partition is to be notified
+ *                              with.
+ *
+ * \retval void                 Success.
+ * \retval "Does not return"    If partition_id is invalid.
  */
-void spm_assert_signal(void *p_pt, psa_signal_t signal);
+void notify_with_signal(int32_t partition_id, psa_signal_t signal);
 
 /**
  * \brief Return the IRQ load info context pointer associated with a signal
@@ -453,17 +480,4 @@ struct irq_load_info_t *get_irq_info_for_signal(
                                     const struct partition_load_info_t *p_ldinf,
                                     psa_signal_t signal);
 
-/**
- * \brief Entry of Secure interrupt handler. Platforms can call this function to
- *        handle individual interrupts.
- *
- * \param[in] p_pt         The owner Partition of the interrupt to handle
- * \param[in] p_ildi       The irq_load_info_t struct of the interrupt to handle
- *
- * Note:
- *  The input parameters are maintained by platforms and they must be init-ed
- *  in the interrupt init functions.
- */
-void spm_handle_interrupt(void *p_pt, struct irq_load_info_t *p_ildi);
-
 #endif /* __SPM_IPC_H__ */
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/static_load.c b/lib/tf-m/secure_fw/spm/cmsis_psa/static_load.c
index acd20c5eb..c178fe121 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/static_load.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/static_load.c
@@ -10,7 +10,6 @@
 #include "region.h"
 #include "region_defs.h"
 #include "spm_ipc.h"
-#include "tfm_hal_interrupt.h"
 #include "tfm_plat_defs.h"
 #include "tfm_spm_hal.h"
 #include "utilities.h"
@@ -77,7 +76,7 @@ struct partition_t *load_a_partition_assuredly(struct partition_head_t *head)
 
     if ((UINTPTR_MAX - ldinf_sa < sizeof(struct partition_load_info_t)) ||
         (ldinf_sa + sizeof(struct partition_load_info_t) >= ldinf_ea)) {
-        return NO_MORE_PARTITION;
+        return NULL;
     }
 
     p_ptldinf = (struct partition_load_info_t *)ldinf_sa;
@@ -98,12 +97,7 @@ struct partition_t *load_a_partition_assuredly(struct partition_head_t *head)
         tfm_core_panic();
     }
 
-    if (!(p_ptldinf->flags & PARTITION_MODEL_IPC)) {
-        tfm_core_panic();
-    }
-
-    if (p_ptldinf->pid < 0) {
-        /* 0 is the internal NS Agent, besides the normal positive PIDs */
+    if (!(p_ptldinf->flags & SPM_PART_FLAG_IPC)) {
         tfm_core_panic();
     }
 
@@ -186,15 +180,22 @@ void load_irqs_assuredly(struct partition_t *p_partition)
     for (i = 0; i < p_ldinf->nirqs; i++) {
         p_partition->signals_allowed |= p_irq_info[i].signal;
 
-        if (p_irq_info[i].init(p_partition, p_irq_info) != TFM_HAL_SUCCESS) {
+        if (tfm_spm_hal_set_secure_irq_priority(p_irq_info[i].source)
+                                                      != TFM_PLAT_ERR_SUCCESS) {
+            tfm_core_panic();
+        }
+
+        if (tfm_spm_hal_set_irq_target_state(p_irq_info[i].source,
+                                             TFM_IRQ_TARGET_STATE_SECURE)
+                                               != TFM_IRQ_TARGET_STATE_SECURE) {
             tfm_core_panic();
         }
 
         if ((p_ldinf->psa_ff_ver & PARTITION_INFO_VERSION_MASK) == 0x0100) {
-            tfm_hal_irq_enable(p_irq_info[i].source);
+            tfm_spm_hal_enable_irq(p_irq_info[i].source);
         } else if ((p_ldinf->psa_ff_ver & PARTITION_INFO_VERSION_MASK)
                                                                     == 0x0101) {
-            tfm_hal_irq_disable(p_irq_info[i].source);
+            tfm_spm_hal_disable_irq(p_irq_info[i].source);
         }
         p_irq_info++;
     }
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_core_svcalls_ipc.c b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_core_svcalls_ipc.c
index d43981fcb..b0a498d52 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_core_svcalls_ipc.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_core_svcalls_ipc.c
@@ -6,96 +6,125 @@
  */
 
 #include <string.h>
+#include "load/partition_defs.h"
 #include "region.h"
 #include "spm_ipc.h"
-#include "svc_num.h"
 #include "tfm_api.h"
 #include "tfm_arch.h"
 #include "tfm_core_trustzone.h"
 #include "tfm_core_utils.h"
 #include "tfm_svcalls.h"
 #include "utilities.h"
-#include "load/spm_load_api.h"
+#include "svc_num.h"
 #include "ffm/tfm_boot_data.h"
-#include "ffm/psa_api.h"
-#include "tfm_hal_isolation.h"
+#include "ffm/psa_client_service_apis.h"
 #include "tfm_hal_spm_logdev.h"
-#include "load/partition_defs.h"
-#include "psa/client.h"
+
+/* The section names come from the scatter file */
+REGION_DECLARE(Image$$, TFM_UNPRIV_CODE, $$RO$$Base);
+REGION_DECLARE(Image$$, TFM_UNPRIV_CODE, $$RO$$Limit);
 
 /* MSP bottom (higher address) */
-REGION_DECLARE(Image$$, ARM_LIB_STACK, $$ZI$$Limit);
+REGION_DECLARE(Image$$, ARM_LIB_STACK_MSP, $$ZI$$Limit);
 
 #ifdef PLATFORM_SVC_HANDLERS
 extern int32_t platform_svc_handlers(uint8_t svc_num,
                                      uint32_t *ctx, uint32_t lr);
 #endif
 
-extern struct thread_t *pth_curr;
+struct tfm_svc_flih_ctx_t {
+    uint32_t exc_ret;                      /* EXC_RETURN payload at SVC entry */
+    uint32_t psp;                          /* PSP value at SVC entry */
+    const struct partition_load_info_t *p_ldinf;/* Load info of IRQ Partition */
+    uint32_t signal;                       /* The IRQ signal */
+};
 
 static int32_t SVC_Handler_IPC(uint8_t svc_num, uint32_t *ctx,
                                uint32_t lr)
 {
+    bool ns_caller = false;
+    struct partition_t *partition = NULL;
+    uint32_t veneer_base =
+        (uint32_t)&REGION_NAME(Image$$, TFM_UNPRIV_CODE, $$RO$$Base);
+    uint32_t veneer_limit =
+        (uint32_t)&REGION_NAME(Image$$, TFM_UNPRIV_CODE, $$RO$$Limit);
+
+    /*
+     * The caller security attribute detection bases on LR of state context.
+     * However, if SP calls PSA APIs based on its customized SVC, the LR may be
+     * occupied by general purpose value while calling SVC.
+     * Check if caller comes from non-secure: return address (ctx[6]) is belongs
+     * to veneer section, and the bit0 of LR (ctx[5]) is zero.
+     */
+    if (ctx[6] >= veneer_base && ctx[6] < veneer_limit &&
+        !(ctx[5] & TFM_VENEER_LR_BIT0_MASK)) {
+        ns_caller = true;
+    }
+
+    partition = tfm_spm_get_running_partition();
+    if (!partition) {
+        tfm_core_panic();
+    }
+
+    tfm_spm_validate_caller(partition, ctx, lr, ns_caller);
+
     switch (svc_num) {
     case TFM_SVC_PSA_FRAMEWORK_VERSION:
-        return tfm_spm_client_psa_framework_version();
+        return tfm_spm_psa_framework_version();
     case TFM_SVC_PSA_VERSION:
-        return tfm_spm_client_psa_version(ctx[0]);
+        return tfm_spm_psa_version(ctx, ns_caller);
     case TFM_SVC_PSA_CONNECT:
-        return tfm_spm_client_psa_connect(ctx[0], ctx[1]);
+        return tfm_spm_psa_connect(ctx, ns_caller);
     case TFM_SVC_PSA_CALL:
-        return tfm_spm_client_psa_call((psa_handle_t)ctx[0], ctx[1],
-                                       (const psa_invec *)ctx[2],
-                                       (psa_outvec *)ctx[3]);
+        return tfm_spm_psa_call(ctx, ns_caller, lr);
     case TFM_SVC_PSA_CLOSE:
-        tfm_spm_client_psa_close((psa_handle_t)ctx[0]);
+        tfm_spm_psa_close(ctx, ns_caller);
         break;
     case TFM_SVC_PSA_WAIT:
-        return tfm_spm_partition_psa_wait((psa_signal_t)ctx[0], ctx[1]);
+        return tfm_spm_psa_wait(ctx);
     case TFM_SVC_PSA_GET:
-        return tfm_spm_partition_psa_get((psa_signal_t)ctx[0],
-                                         (psa_msg_t *)ctx[1]);
+        return tfm_spm_psa_get(ctx);
     case TFM_SVC_PSA_SET_RHANDLE:
-        tfm_spm_partition_psa_set_rhandle((psa_handle_t)ctx[0], (void *)ctx[1]);
+        tfm_spm_psa_set_rhandle(ctx);
         break;
     case TFM_SVC_PSA_READ:
-        return tfm_spm_partition_psa_read((psa_handle_t)ctx[0], ctx[1],
-                                          (void *)ctx[2], (size_t)ctx[3]);
+        return tfm_spm_psa_read(ctx);
     case TFM_SVC_PSA_SKIP:
-        return tfm_spm_partition_psa_skip((psa_handle_t)ctx[0], ctx[1],
-                                          (size_t)ctx[2]);
+        return tfm_spm_psa_skip(ctx);
     case TFM_SVC_PSA_WRITE:
-        tfm_spm_partition_psa_write((psa_handle_t)ctx[0], ctx[1],
-                                    (void *)ctx[2], (size_t)ctx[3]);
+        tfm_spm_psa_write(ctx);
         break;
     case TFM_SVC_PSA_REPLY:
-        tfm_spm_partition_psa_reply((psa_handle_t)ctx[0], (psa_status_t)ctx[1]);
+        tfm_spm_psa_reply(ctx);
         break;
     case TFM_SVC_PSA_NOTIFY:
-        tfm_spm_partition_psa_notify((int32_t)ctx[0]);
+        tfm_spm_psa_notify(ctx);
         break;
     case TFM_SVC_PSA_CLEAR:
-        tfm_spm_partition_psa_clear();
+        tfm_spm_psa_clear();
         break;
     case TFM_SVC_PSA_EOI:
-        tfm_spm_partition_psa_eoi((psa_signal_t)ctx[0]);
+        tfm_spm_psa_eoi(ctx);
         break;
     case TFM_SVC_PSA_PANIC:
-        tfm_spm_partition_psa_panic();
+        tfm_spm_psa_panic();
+        break;
+    case TFM_SVC_SPM_REQUEST:
+        tfm_spm_request_handler((const struct tfm_state_context_t *)ctx);
         break;
     case TFM_SVC_PSA_LIFECYCLE:
         return tfm_spm_get_lifecycle_state();
-#if TFM_SP_LOG_RAW_ENABLED
+#if (TFM_SPM_LOG_LEVEL > TFM_SPM_LOG_LEVEL_SILENCE)
     case TFM_SVC_OUTPUT_UNPRIV_STRING:
         return tfm_hal_output_spm_log((const char *)ctx[0], ctx[1]);
 #endif
     case TFM_SVC_PSA_IRQ_ENABLE:
-        tfm_spm_partition_irq_enable((psa_signal_t)ctx[0]);
+        tfm_spm_irq_enable(ctx);
         break;
     case TFM_SVC_PSA_IRQ_DISABLE:
-        return tfm_spm_partition_irq_disable((psa_signal_t)ctx[0]);
+        return tfm_spm_irq_disable(ctx);
     case TFM_SVC_PSA_RESET_SIGNAL:
-        tfm_spm_partition_psa_reset_signal((psa_signal_t)ctx[0]);
+        tfm_spm_psa_reset_signal(ctx);
         break;
     default:
 #ifdef PLATFORM_SVC_HANDLERS
@@ -112,83 +141,102 @@ extern void tfm_flih_func_return(psa_flih_result_t result);
 
 /*
  * Prepare execution context for deprivileged FLIH functions
- * svc_args: IRQ owner partition_t pointer, flih_func, current thread data
+ * svc_args: IRQ owner Partition load info, flih_func, signal
  */
-uint32_t tfm_flih_prepare_depriv_flih(uint32_t *svc_args)
+uint32_t tfm_flih_prepare_depriv_flih(uintptr_t ctx, uint32_t *svc_args)
 {
-    struct partition_t *p_curr_sp;
-    struct partition_t *p_owner_sp = (struct partition_t *)svc_args[0];
-    uintptr_t sp_limit, stack;
-    struct context_ctrl_t flih_ctx_ctrl;
+    struct tfm_core_thread_t *irq_sp_thread;
+    struct partition_t *irq_sp, *curr_sp;
+    struct tfm_state_context_t *p_stat_ctx;
+    struct tfm_svc_flih_ctx_t *flih_ctx;
+
+    irq_sp = tfm_spm_get_partition_by_id(
+                            ((struct partition_load_info_t *)svc_args[0])->pid);
 
-    /* Come too early before runtime setup, should not happen. */
-    if (!pth_curr) {
+    if (!irq_sp) {
         tfm_core_panic();
     }
+    irq_sp_thread = &irq_sp->sp_thread;
 
-    p_curr_sp = TO_CONTAINER(pth_curr->p_context_ctrl,
-                             struct partition_t,
-                             ctx_ctrl);
-
-    sp_limit =
-           ((struct context_ctrl_t *)p_owner_sp->thrd.p_context_ctrl)->sp_limit;
-
-    if (p_owner_sp == p_curr_sp) {
-        stack = (uintptr_t)__get_PSP();
-    } else {
-        stack = ((struct context_ctrl_t *)p_owner_sp->thrd.p_context_ctrl)->sp;
+    curr_sp = TO_CONTAINER(tfm_core_thrd_get_curr(),
+                           struct partition_t,
+                           sp_thread);
 
-        if (p_owner_sp->p_boundaries != p_curr_sp->p_boundaries) {
-            tfm_hal_update_boundaries(p_owner_sp->p_ldinf,
-                                      p_owner_sp->p_boundaries);
-        }
+    flih_ctx = (struct tfm_svc_flih_ctx_t *)ctx;
+    flih_ctx->signal = svc_args[2];
+    flih_ctx->p_ldinf = curr_sp->p_ldinf;
 
+    if (curr_sp == irq_sp) {
         /*
-         * pth_curr->p_context_ctrl is the svc_args[2] on MSP, safe to update
-         * it. It is only used to track the owner of the thread data, i.e. the
-         * Partition that has been interrupted.
+         * Either the Partition Thread or FLIH Function within the same
+         * Partition was preempted.
          */
-        pth_curr->p_context_ctrl = &(p_owner_sp->ctx_ctrl);
+        p_stat_ctx = (struct tfm_state_context_t *)flih_ctx->psp;
+    } else {
+        p_stat_ctx = (struct tfm_state_context_t *)irq_sp_thread->arch_ctx.sp;
+        tfm_core_thrd_set_curr(irq_sp_thread);
+        tfm_set_up_isolation_boundary(irq_sp);
+        tfm_arch_set_psplim(irq_sp_thread->stk_btm);
     }
 
-    tfm_arch_init_context(&flih_ctx_ctrl,
-                          (uintptr_t)svc_args[1], NULL,
-                          (uintptr_t)tfm_flih_func_return,
-                          sp_limit, stack);
+    p_stat_ctx--;
+    if ((uintptr_t)p_stat_ctx < irq_sp_thread->stk_btm) {
+        tfm_core_panic();
+    }
+    spm_memset(p_stat_ctx, 0, sizeof(struct tfm_state_context_t));
 
-    (void)tfm_arch_refresh_hardware_context(&flih_ctx_ctrl);
+    p_stat_ctx->ra = (uint32_t)svc_args[1];
+    p_stat_ctx->lr = (uint32_t)tfm_flih_func_return;
+    p_stat_ctx->xpsr = XPSR_T32;
 
-    return flih_ctx_ctrl.exc_ret;
+    __set_PSP((uint32_t)p_stat_ctx);
+
+    return EXC_RETURN_THREAD_S_PSP;
 }
 
 /* Go back to ISR from FLIH functions */
-uint32_t tfm_flih_return_to_isr(psa_flih_result_t result, uint32_t *msp)
+uint32_t tfm_flih_return_to_isr(uintptr_t ctx, psa_flih_result_t result)
 {
-    struct partition_t *p_prev_sp, *p_owner_sp;
-    struct context_flih_ret_t *p_ctx_flih_ret =
-                                               (struct context_flih_ret_t *)msp;
-
-    p_prev_sp = TO_CONTAINER(p_ctx_flih_ret->state_ctx.r2,
-                                                  struct partition_t, ctx_ctrl);
-    p_owner_sp = TO_CONTAINER(pth_curr->p_context_ctrl,
-                              struct partition_t, ctx_ctrl);
-
-    if (p_owner_sp->p_boundaries != p_prev_sp->p_boundaries) {
-        tfm_hal_update_boundaries(p_prev_sp->p_ldinf,
-                                  p_prev_sp->p_boundaries);
+    struct partition_t *curr_sp, *prev_sp;
+    struct tfm_svc_flih_ctx_t *flih_ctx;
+    uint32_t msp_top =
+                (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK_MSP, $$ZI$$Limit);
+
+    /* Skip one tfm_svc_flih_ctx_t + 8 words (R4- R11) + seals (2 words) */
+    flih_ctx = (struct tfm_svc_flih_ctx_t *)
+              (ctx + sizeof(struct tfm_svc_flih_ctx_t) + 10 * sizeof(uint32_t));
+    if ((uint32_t)flih_ctx > msp_top - TFM_STACK_SEALED_SIZE) {
+        tfm_core_panic();
+    }
+
+    curr_sp = TO_CONTAINER(tfm_core_thrd_get_curr(),
+                           struct partition_t,
+                           sp_thread);
+
+    prev_sp = tfm_spm_get_partition_by_id(flih_ctx->p_ldinf->pid);
+    if (!prev_sp) {
+        tfm_core_panic();
     }
 
-    /* Restore context pointer */
-    pth_curr->p_context_ctrl = (void *)p_ctx_flih_ret->state_ctx.r2;
+    if (curr_sp != prev_sp) {
+        tfm_set_up_isolation_boundary(prev_sp);
+        tfm_core_thrd_set_curr(&(prev_sp->sp_thread));
+        tfm_arch_set_psplim(prev_sp->sp_thread.stk_btm);
+    }
 
-    tfm_arch_set_psplim(
-                 ((struct context_ctrl_t *)pth_curr->p_context_ctrl)->sp_limit);
-    __set_PSP(p_ctx_flih_ret->psp);
+    __set_PSP(flih_ctx->psp);
 
-    /* Set FLIH result to the ISR */
-    p_ctx_flih_ret->state_ctx.r0 = (uint32_t)result;
+    if (result == PSA_FLIH_SIGNAL) {
+        notify_with_signal(curr_sp->p_ldinf->pid, flih_ctx->signal);
+    } else if (result != PSA_FLIH_NO_SIGNAL) {
+        /*
+         * Nothing needed to do for PSA_FLIH_NO_SIGNAL
+         * But if the flih_result is invalid, should panic.
+         */
+        tfm_core_panic();
+    }
 
-    return p_ctx_flih_ret->exc_ret;
+    return flih_ctx->exc_ret;
 }
 
 uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t exc_return,
@@ -196,10 +244,14 @@ uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t exc_return,
 {
     uint8_t svc_number = TFM_SVC_PSA_FRAMEWORK_VERSION;
     uint32_t *svc_args = msp;
+    uintptr_t flih_ctx =
+                 (uintptr_t)((uint32_t)msp - sizeof(struct tfm_svc_flih_ctx_t));
 
     if ((exc_return & EXC_RETURN_MODE) && (exc_return & EXC_RETURN_SPSEL)) {
         /* Use PSP when both EXC_RETURN.MODE and EXC_RETURN.SPSEL are set */
         svc_args = psp;
+    } else {
+        svc_args = msp;
     }
 
     /*
@@ -227,22 +279,19 @@ uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t exc_return,
 
     switch (svc_number) {
     case TFM_SVC_SPM_INIT:
-        tfm_arch_clear_fp_status();
         exc_return = tfm_spm_init();
-        /* The following call does not return */
-        tfm_arch_free_msp_and_exc_ret(exc_return);
         break;
     case TFM_SVC_GET_BOOT_DATA:
         tfm_core_get_boot_data_handler(svc_args);
         break;
     case TFM_SVC_PREPARE_DEPRIV_FLIH:
-        exc_return = tfm_flih_prepare_depriv_flih(svc_args);
+        exc_return = tfm_flih_prepare_depriv_flih(flih_ctx, svc_args);
         break;
     case TFM_SVC_FLIH_FUNC_RETURN:
-        exc_return = tfm_flih_return_to_isr(svc_args[0], msp);
+        exc_return = tfm_flih_return_to_isr(flih_ctx, svc_args[0]);
         break;
     default:
-        if (((uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK, $$ZI$$Limit)
+        if (((uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK_MSP, $$ZI$$Limit)
                                      - (uint32_t)msp) > TFM_STACK_SEALED_SIZE) {
             /* The Main Stack has contents, not calling from Partition thread */
             tfm_core_panic();
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_multi_core.c b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_multi_core.c
index 54b5da20e..03a1afe6a 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_multi_core.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_multi_core.c
@@ -1,14 +1,14 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
 #include "tfm_arch.h"
 #include "tfm_assert.h"
+#include "tfm_spe_mailbox.h"
 #include "tfm_spm_hal.h"
 #include "tfm_spm_log.h"
-#include "tfm_multi_core.h"
 
 #define DEFAULT_NS_CLIENT_ID            (-1)
 
@@ -27,7 +27,7 @@ void tfm_nspm_thread_entry(void)
     tfm_spm_hal_boot_ns_cpu(tfm_spm_hal_get_ns_VTOR());
     tfm_spm_hal_wait_for_ns_cpu_ready();
 
-    tfm_inter_core_comm_init();
+    tfm_mailbox_init();
 
     /*
      * TODO
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_multi_core.h b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_multi_core.h
index 87c8bc7b9..0cf4ba21a 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_multi_core.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_multi_core.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -89,12 +89,4 @@ void tfm_get_ns_mem_region_attr(const void *p, size_t s,
  */
 int32_t tfm_has_access_to_region(const void *p, size_t s, uint32_t attr);
 
-/**
- * \brief Initialization of the multi core communication.
- *
- * \retval 0                    Operation succeeded.
- * \retval Other return code    Operation failed with an error code.
- */
-int32_t tfm_inter_core_comm_init(void);
-
 #endif /* __TFM_MULTI_CORE_H__ */
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_pools.c b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_pools.c
index 0caaf6db8..5bd07f1c7 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_pools.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_pools.c
@@ -7,7 +7,8 @@
 #include <inttypes.h>
 #include <stdbool.h>
 #include <stdlib.h>
-#include "thread.h"
+#include "tfm_thread.h"
+#include "tfm_wait.h"
 #include "psa/client.h"
 #include "psa/service.h"
 #include "internal_errors.h"
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_psa_api_veneers.c b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_psa_api_veneers.c
index 12b11f82b..a3328cde0 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_psa_api_veneers.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_psa_api_veneers.c
@@ -7,80 +7,45 @@
 
 #include <stdbool.h>
 #include <stdio.h>
-#include "security_defs.h"
+#include "psa/client.h"
+#include "psa/service.h"
 #include "tfm_arch.h"
 #include "tfm_secure_api.h"
 #include "tfm_api.h"
 #include "tfm_svcalls.h"
-#include "utilities.h"
+
+/* Veneer implementation */
 
 /*
- * Use assembly to:
- * - Explicit stack usage to perform re-entrant detection.
- * - SVC here to take hardware context management advantages.
+ * SVC to core directly before touch stack due to:
+ * - Re-entrant detection bases on stack information.
+ * - SVC here stores the current xPSR into stack and recover it back while
+ *   exception returns, no leakage of secure state information and no
+ *   interference between two sides.
  */
 
 __tfm_psa_secure_gateway_attributes__
 uint32_t tfm_psa_framework_version_veneer(void)
 {
-    __ASM volatile(
-#if !defined(__ARM_ARCH_8_1M_MAIN__)
-            "   ldr    r2, [sp]                        \n"
-            "   ldr    r3, ="M2S(STACK_SEAL_PATTERN)"  \n"
-            "   cmp    r2, r3                          \n"
-            "   bne    reent_panic1                    \n"
-#endif
-            "   svc    %0                              \n"
-            "   bxns   lr                              \n"
-#if !defined(__ARM_ARCH_8_1M_MAIN__)
-            "reent_panic1:                             \n"
-            "   svc    %1                              \n"
-            "   b      .                               \n"
-#endif
-            : : "I" (TFM_SVC_PSA_FRAMEWORK_VERSION),
-                "I" (TFM_SVC_PSA_PANIC));
+    __ASM volatile("SVC %0           \n"
+                   "BXNS LR          \n"
+                    : : "I" (TFM_SVC_PSA_FRAMEWORK_VERSION));
 }
 
 __tfm_psa_secure_gateway_attributes__
 uint32_t tfm_psa_version_veneer(uint32_t sid)
 {
-    __ASM volatile(
-#if !defined(__ARM_ARCH_8_1M_MAIN__)
-            "   ldr    r2, [sp]                        \n"
-            "   ldr    r3, ="M2S(STACK_SEAL_PATTERN)"  \n"
-            "   cmp    r2, r3                          \n"
-            "   bne    reent_panic2                    \n"
-#endif
-            "   svc    %0                              \n"
-            "   bxns   lr                              \n"
-#if !defined(__ARM_ARCH_8_1M_MAIN__)
-            "reent_panic2:                             \n"
-            "   svc    %1                              \n"
-            "   b      .                               \n"
-#endif
-            : : "I" (TFM_SVC_PSA_VERSION),
-                "I" (TFM_SVC_PSA_PANIC));
+    __ASM volatile("SVC %0           \n"
+                   "BXNS LR          \n"
+                    : : "I" (TFM_SVC_PSA_VERSION));
 }
 
 __tfm_psa_secure_gateway_attributes__
 psa_handle_t tfm_psa_connect_veneer(uint32_t sid, uint32_t version)
 {
-    __ASM volatile(
-#if !defined(__ARM_ARCH_8_1M_MAIN__)
-            "   ldr    r2, [sp]                        \n"
-            "   ldr    r3, ="M2S(STACK_SEAL_PATTERN)"  \n"
-            "   cmp    r2, r3                          \n"
-            "   bne    reent_panic3                    \n"
-#endif
-            "   svc    %0                              \n"
-            "   bxns   lr                              \n"
-#if !defined(__ARM_ARCH_8_1M_MAIN__)
-            "reent_panic3:                             \n"
-            "   svc    %1                              \n"
-            "   b      .                               \n"
-#endif
-            : : "I" (TFM_SVC_PSA_CONNECT),
-                "I" (TFM_SVC_PSA_PANIC));
+    __ASM volatile("SVC %0           \n"
+                   "BXNS LR          \n"
+                    : : "I" (TFM_SVC_PSA_CONNECT));
 }
 
 __tfm_psa_secure_gateway_attributes__
@@ -89,43 +54,15 @@ psa_status_t tfm_psa_call_veneer(psa_handle_t handle,
                                  const psa_invec *in_vec,
                                  psa_outvec *out_vec)
 {
-    __ASM volatile(
-#if !defined(__ARM_ARCH_8_1M_MAIN__)
-            "   push   {r2, r3}                        \n"
-            "   ldr    r2, [sp, #8]                    \n"
-            "   ldr    r3, ="M2S(STACK_SEAL_PATTERN)"  \n"
-            "   cmp    r2, r3                          \n"
-            "   bne    reent_panic4                    \n"
-            "   pop    {r2, r3}                        \n"
-#endif
-            "   svc    %0                              \n"
-            "   bxns   lr                              \n"
-#if !defined(__ARM_ARCH_8_1M_MAIN__)
-            "reent_panic4:                             \n"
-            "   svc    %1                              \n"
-            "   b      .                               \n"
-#endif
-            : : "I" (TFM_SVC_PSA_CALL),
-                "I" (TFM_SVC_PSA_PANIC));
+    __ASM volatile("SVC %0           \n"
+                   "BXNS LR          \n"
+                    : : "I" (TFM_SVC_PSA_CALL));
 }
 
 __tfm_psa_secure_gateway_attributes__
 void tfm_psa_close_veneer(psa_handle_t handle)
 {
-    __ASM volatile(
-#if !defined(__ARM_ARCH_8_1M_MAIN__)
-            "   ldr    r2, [sp]                        \n"
-            "   ldr    r3, ="M2S(STACK_SEAL_PATTERN)"  \n"
-            "   cmp    r2, r3                          \n"
-            "   bne    reent_panic5                    \n"
-#endif
-            "   svc    %0                              \n"
-            "   bxns   lr                              \n"
-#if !defined(__ARM_ARCH_8_1M_MAIN__)
-            "reent_panic5:                             \n"
-            "   svc    %1                              \n"
-            "   b      .                               \n"
-#endif
-            : : "I" (TFM_SVC_PSA_CLOSE),
-                "I" (TFM_SVC_PSA_PANIC));
+    __ASM volatile("SVC %0           \n"
+                   "BXNS LR          \n"
+                    : : "I" (TFM_SVC_PSA_CLOSE));
 }
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_rpc.c b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_rpc.c
index 9fc1ced41..a4fbc0c36 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_rpc.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_rpc.c
@@ -6,11 +6,10 @@
  */
 
 #include "spm_ipc.h"
-#include "ffm/psa_api.h"
+#include "ffm/spm_psa_client_call.h"
 #include "tfm_rpc.h"
 #include "utilities.h"
 #include "load/partition_defs.h"
-#include "tfm_psa_call_param.h"
 
 static void default_handle_req(void)
 {
@@ -40,36 +39,39 @@ uint32_t tfm_rpc_psa_framework_version(void)
     return tfm_spm_client_psa_framework_version();
 }
 
-uint32_t tfm_rpc_psa_version(const struct client_call_params_t *params)
+uint32_t tfm_rpc_psa_version(const struct client_call_params_t *params,
+                             bool ns_caller)
 {
     TFM_CORE_ASSERT(params != NULL);
 
-    return tfm_spm_client_psa_version(params->sid);
+    return tfm_spm_client_psa_version(params->sid, ns_caller);
 }
 
-psa_status_t tfm_rpc_psa_connect(const struct client_call_params_t *params)
+psa_status_t tfm_rpc_psa_connect(const struct client_call_params_t *params,
+                                 bool ns_caller)
 {
     TFM_CORE_ASSERT(params != NULL);
 
-    return tfm_spm_client_psa_connect(params->sid, params->version);
+    return tfm_spm_client_psa_connect(params->sid, params->version, ns_caller);
 }
 
-psa_status_t tfm_rpc_psa_call(const struct client_call_params_t *params)
+psa_status_t tfm_rpc_psa_call(const struct client_call_params_t *params,
+                              bool ns_caller)
 {
     TFM_CORE_ASSERT(params != NULL);
 
-    return tfm_spm_client_psa_call(params->handle,
-                                   PARAM_PACK(params->type,
-                                              params->in_len,
-                                              params->out_len),
-                                   params->in_vec, params->out_vec);
+    return tfm_spm_client_psa_call(params->handle, params->type,
+                                   params->in_vec, params->in_len,
+                                   params->out_vec, params->out_len, ns_caller,
+                                   TFM_PARTITION_UNPRIVILEGED_MODE);
 }
 
-void tfm_rpc_psa_close(const struct client_call_params_t *params)
+void tfm_rpc_psa_close(const struct client_call_params_t *params,
+                       bool ns_caller)
 {
     TFM_CORE_ASSERT(params != NULL);
 
-    tfm_spm_client_psa_close(params->handle);
+    tfm_spm_client_psa_close(params->handle, ns_caller);
 }
 
 int32_t tfm_rpc_register_ops(const struct tfm_rpc_ops_t *ops_ptr)
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_rpc.h b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_rpc.h
index e1942e0e7..c07ac8218 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_rpc.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_rpc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -20,7 +20,8 @@
 #include "cmsis_compiler.h"
 #include "psa/client.h"
 #include "psa/service.h"
-#include "thread.h"
+#include "tfm_thread.h"
+#include "tfm_wait.h"
 #include "spm_ipc.h"
 
 #define TFM_RPC_SUCCESS             (0)
@@ -71,17 +72,20 @@ uint32_t tfm_rpc_psa_framework_version(void);
  * \brief RPC handler for \ref psa_version.
  *
  * \param[in] params            Base address of parameters
+ * \param[in] ns_caller         If 'true', indicate the non-secure caller
  *
  * \retval PSA_VERSION_NONE     The RoT Service is not implemented, or the
  *                              caller is not permitted to access the service.
  * \retval > 0                  The version of the implemented RoT Service.
  */
-uint32_t tfm_rpc_psa_version(const struct client_call_params_t *params);
+uint32_t tfm_rpc_psa_version(const struct client_call_params_t *params,
+                             bool ns_caller);
 
 /**
  * \brief RPC handler for \ref psa_connect.
  *
  * \param[in] params            Base address of parameters
+ * \param[in] ns_caller         If 'true', indicate the non-secure caller
  *
  * \retval PSA_SUCCESS          Success.
  * \retval PSA_CONNECTION_BUSY  The SPM cannot make the connection
@@ -90,12 +94,14 @@ uint32_t tfm_rpc_psa_version(const struct client_call_params_t *params);
  *                              supported, or the caller is not permitted to
  *                              access the service.
  */
-psa_status_t tfm_rpc_psa_connect(const struct client_call_params_t *params);
+psa_status_t tfm_rpc_psa_connect(const struct client_call_params_t *params,
+                                 bool ns_caller);
 
 /**
  * \brief RPC handler for \ref psa_call.
  *
  * \param[in] params            Base address of parameters
+ * \param[in] ns_caller         If 'true', indicate the non-secure caller
  *
  * \retval PSA_SUCCESS          Success.
  * \retval "Does not return"    The call is invalid, one or more of the
@@ -107,12 +113,14 @@ psa_status_t tfm_rpc_psa_connect(const struct client_call_params_t *params);
  * \arg                           The message is unrecognized or
  *                                incorrectly formatted.
  */
-psa_status_t tfm_rpc_psa_call(const struct client_call_params_t *params);
+psa_status_t tfm_rpc_psa_call(const struct client_call_params_t *params,
+                              bool ns_caller);
 
 /**
  * \brief RPC handler for \ref psa_close.
  *
  * \param[in] params            Base address of parameters
+ * \param[in] ns_caller         If 'true', indicate the non-secure caller
  *
  * \retval void                 Success.
  * \retval "Does not return"    The call is invalid, one or more of the
@@ -120,7 +128,8 @@ psa_status_t tfm_rpc_psa_call(const struct client_call_params_t *params);
  * \arg                           An invalid handle was provided that is not
  *                                the null handle..
  */
-void tfm_rpc_psa_close(const struct client_call_params_t *params);
+void tfm_rpc_psa_close(const struct client_call_params_t *params,
+                       bool ns_caller);
 
 /**
  * \brief Register underlying mailbox communication operations.
diff --git a/tf-m.old/secure_fw/spm/cmsis_psa/tfm_secure_irq_handlers_ipc.inc.template b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_secure_irq_handlers_ipc.inc.template
new file mode 100644
index 000000000..d7b9fdefe
--- /dev/null
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_secure_irq_handlers_ipc.inc.template
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+{{utilities.donotedit_warning}}
+
+/* Definitions of privileged IRQ handlers (if any) */
+{% for partition in partitions %}
+    {% if partition.manifest.irqs %}
+        {% if partition.attr.conditional %}
+#ifdef {{partition.attr.conditional}}
+        {% endif %}
+#include "{{partition.header_file}}"
+extern struct partition_{{partition.manifest.name|lower}}_load_info_t {{partition.manifest.name|lower}}_load;
+        {% for irq in partition.manifest.irqs %}
+            {% set irq_data = namespace() %}
+            {% if partition.manifest.psa_framework_version == 1.0 %}
+                {% set irq_data.signal = irq.signal %}
+            {% else %}
+                {% set irq_data.signal = irq.name + "_SIGNAL" %}
+            {% endif %}
+            {% if irq.source is number %}
+void irq_{{irq.source}}_Handler(void)
+            {% elif irq.source %}
+void {{irq.source}}_Handler(void)
+            {% else %}
+#error "Interrupt source isn't provided for 'irqs' in partition {{partition.manifest.name}}"
+            {% endif %}
+{
+            {% if irq.source %}
+                {% if partition.manifest.psa_framework_version == 1.1 and irq.handling == "FLIH" %}
+                    {% set irq_data.flih =  irq.name|lower + "_flih" %}
+                {% else %}
+                    {% set irq_data.flih =  "NULL" %}
+                {% endif %}
+    spm_interrupt_handler((struct partition_load_info_t *)&{{partition.manifest.name|lower}}_load, {{irq_data.signal}}, {{irq.source}}, {{irq_data.flih}});
+            {% else %}
+#error "Interrupt source isn't provided for 'irqs' in partition {{partition.manifest.name}}"
+            {% endif %}
+}
+        {% endfor %}
+        {% if partition.attr.conditional %}
+#endif /* {{partition.attr.conditional}} */
+        {% endif %}
+
+    {% endif %}
+{% endfor %}
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_spe_mailbox.c b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_spe_mailbox.c
index c4eb2e16c..fe3072628 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_spe_mailbox.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_spe_mailbox.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -12,7 +12,8 @@
 #include "utilities.h"
 #include "tfm_spe_mailbox.h"
 #include "tfm_rpc.h"
-#include "tfm_multi_core.h"
+
+#define NS_CALLER_FLAG          (true)
 
 static struct secure_mailbox_queue_t spe_mailbox_queue;
 
@@ -34,12 +35,12 @@ static int32_t tfm_mailbox_dispatch(uint32_t call_type,
         return MAILBOX_SUCCESS;
     case MAILBOX_PSA_VERSION:
         spm_params.sid = params->psa_version_params.sid;
-        *psa_ret = tfm_rpc_psa_version(&spm_params);
+        *psa_ret = tfm_rpc_psa_version(&spm_params, NS_CALLER_FLAG);
         return MAILBOX_SUCCESS;
     case MAILBOX_PSA_CONNECT:
         spm_params.sid = params->psa_connect_params.sid;
         spm_params.version = params->psa_connect_params.version;
-        *psa_ret = tfm_rpc_psa_connect(&spm_params);
+        *psa_ret = tfm_rpc_psa_connect(&spm_params, NS_CALLER_FLAG);
         return MAILBOX_SUCCESS;
     case MAILBOX_PSA_CALL:
         spm_params.handle = params->psa_call_params.handle;
@@ -48,11 +49,11 @@ static int32_t tfm_mailbox_dispatch(uint32_t call_type,
         spm_params.in_len = params->psa_call_params.in_len;
         spm_params.out_vec = params->psa_call_params.out_vec;
         spm_params.out_len = params->psa_call_params.out_len;
-        *psa_ret = tfm_rpc_psa_call(&spm_params);
+        *psa_ret = tfm_rpc_psa_call(&spm_params, NS_CALLER_FLAG);
         return MAILBOX_SUCCESS;
     case MAILBOX_PSA_CLOSE:
         spm_params.handle = params->psa_close_params.handle;
-        tfm_rpc_psa_close(&spm_params);
+        tfm_rpc_psa_close(&spm_params, NS_CALLER_FLAG);
         return MAILBOX_SUCCESS;
     default:
         return MAILBOX_INVAL_PARAMS;
@@ -403,8 +404,3 @@ int32_t tfm_mailbox_init(void)
 
     return MAILBOX_SUCCESS;
 }
-
-int32_t tfm_inter_core_comm_init(void)
-{
-    return tfm_mailbox_init();
-}
diff --git a/tf-m.old/secure_fw/spm/cmsis_psa/tfm_thread.c b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_thread.c
new file mode 100644
index 000000000..ef371a1b4
--- /dev/null
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_thread.c
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+#include <inttypes.h>
+#include "tfm_arch.h"
+#include "tfm_thread.h"
+#include "utilities.h"
+#include "svc_num.h"
+#include "tfm_memory_utils.h"
+#include "tfm_core_utils.h"
+
+/* Force ZERO in case ZI(bss) clear is missing */
+static struct tfm_core_thread_t *p_thrd_head = NULL; /* Head of all threads */
+static struct tfm_core_thread_t *p_rnbl_head = NULL; /* Head of runnable */
+static struct tfm_core_thread_t *p_curr_thrd = NULL; /* Current running */
+
+/* Define Macro to fetch global to support future expansion (PERCPU e.g.) */
+#define LIST_HEAD   p_thrd_head
+#define RNBL_HEAD   p_rnbl_head
+#define CURR_THRD   p_curr_thrd
+
+/* Get next thread to run for scheduler */
+struct tfm_core_thread_t *tfm_core_thrd_get_next(void)
+{
+    struct tfm_core_thread_t *pth = RNBL_HEAD;
+
+    /*
+     * First runnable thread has highest priority since threads are sorted with
+     * priority.
+     */
+    while (pth && pth->state != THRD_STATE_RUNNABLE) {
+        pth = pth->next;
+    }
+
+    return pth;
+}
+
+/* To get current running thread for caller */
+struct tfm_core_thread_t *tfm_core_thrd_get_curr(void)
+{
+    return CURR_THRD;
+}
+
+void tfm_core_thrd_set_curr(struct tfm_core_thread_t *pth)
+{
+    if (!pth) {
+        tfm_core_panic();
+    }
+
+    CURR_THRD = pth;
+}
+
+/* Insert a new thread into list by descending priority (Highest at head) */
+static void insert_by_prior(struct tfm_core_thread_t **head,
+                            struct tfm_core_thread_t *node)
+{
+    if (*head == NULL || (node->prior <= (*head)->prior)) {
+        node->next = *head;
+        *head = node;
+    } else {
+        struct tfm_core_thread_t *iter = *head;
+
+        while (iter->next && (node->prior > iter->next->prior)) {
+            iter = iter->next;
+        }
+        node->next = iter->next;
+        iter->next = node;
+    }
+}
+
+/* Set context members only. No validation here */
+void tfm_core_thrd_init(struct tfm_core_thread_t *pth,
+                        tfm_core_thrd_entry_t pfn, void *param,
+                        uintptr_t stk_top, uintptr_t stk_btm)
+{
+    pth->prior = THRD_PRIOR_MEDIUM;
+    pth->state = THRD_STATE_CREATING;
+    pth->pfn = pfn;
+    pth->param = param;
+    pth->stk_btm = stk_btm;
+    pth->stk_top = stk_top;
+    pth->flih_ctx = stk_top;
+}
+
+uint32_t tfm_core_thrd_start(struct tfm_core_thread_t *pth)
+{
+    /* Validate parameters before really start */
+    if ((pth->state != THRD_STATE_CREATING) ||
+        (pth->pfn == NULL)                  ||
+        (pth->stk_btm == 0)                 ||
+        (pth->stk_top == 0)) {
+        return THRD_ERR_INVALID_PARAM;
+    }
+
+    /* Thread management runs in handler mode; set context for thread mode. */
+    tfm_arch_init_context(&pth->arch_ctx, pth->param, (uintptr_t)pth->pfn,
+                          pth->stk_btm, pth->stk_top);
+
+    /* Insert a new thread with priority */
+    insert_by_prior(&LIST_HEAD, pth);
+
+    /* Mark it as RUNNABLE after insertion */
+    tfm_core_thrd_set_state(pth, THRD_STATE_RUNNABLE);
+
+    return THRD_SUCCESS;
+}
+
+void tfm_core_thrd_set_state(struct tfm_core_thread_t *pth, uint32_t new_state)
+{
+    TFM_CORE_ASSERT(pth != NULL && new_state < THRD_STATE_INVALID);
+
+    pth->state = new_state;
+
+    /*
+     * Set first runnable thread as head to reduce enumerate
+     * depth while searching for a first runnable thread.
+     */
+    if ((pth->state == THRD_STATE_RUNNABLE) &&
+        ((RNBL_HEAD == NULL) || (pth->prior < RNBL_HEAD->prior))) {
+        RNBL_HEAD = pth;
+    } else {
+        RNBL_HEAD = LIST_HEAD;
+    }
+}
+
+/* Scheduling won't happen immediately but after the exception returns */
+void tfm_core_thrd_activate_schedule(void)
+{
+    tfm_arch_trigger_pendsv();
+}
+
+void tfm_core_thrd_start_scheduler(struct tfm_core_thread_t *pth)
+{
+    /*
+     * There is no selected thread before scheduler start, assign the caller
+     * provided thread as the current thread. Update the hardware PSP/PSPLIM
+     * with the value in thread context to ensure they are identical.
+     * This function can be called only ONCE; further calling triggers assert.
+     */
+    TFM_CORE_ASSERT(CURR_THRD == NULL);
+    TFM_CORE_ASSERT(pth != NULL);
+    TFM_CORE_ASSERT(pth->arch_ctx.sp != 0);
+
+    tfm_arch_set_ctx(&pth->arch_ctx);
+
+    CURR_THRD = pth;
+
+    tfm_core_thrd_activate_schedule();
+}
+
+void tfm_core_thrd_switch_context(struct tfm_arch_ctx_t *p_actx,
+                                  struct tfm_core_thread_t *prev,
+                                  struct tfm_core_thread_t *next)
+{
+    TFM_CORE_ASSERT(prev != NULL);
+    TFM_CORE_ASSERT(next != NULL);
+
+    /*
+     * First, update latest context into the current thread context.
+     * Then, update background context with next thread's context.
+     */
+    spm_memcpy(&prev->arch_ctx, p_actx, sizeof(*p_actx));
+    spm_memcpy(p_actx, &next->arch_ctx, sizeof(next->arch_ctx));
+
+    prev->flih_ctx = prev->arch_ctx.sp;
+
+    /* Update current thread indicator */
+    CURR_THRD = next;
+}
diff --git a/tf-m.old/secure_fw/spm/cmsis_psa/tfm_thread.h b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_thread.h
new file mode 100644
index 000000000..f02b524e0
--- /dev/null
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_thread.h
@@ -0,0 +1,234 @@
+/*
+ * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+#ifndef __TFM_THREAD_H__
+#define __TFM_THREAD_H__
+
+#include <stdint.h>
+#include <stddef.h>
+#include "tfm_arch.h"
+#include "cmsis_compiler.h"
+
+/* State code */
+#define THRD_STATE_CREATING       0
+#define THRD_STATE_RUNNABLE       1
+#define THRD_STATE_BLOCK          2
+#define THRD_STATE_DETACH         3
+#define THRD_STATE_INVALID        4
+
+/* Security attribute - default as security */
+#define THRD_ATTR_SECURE_OFFSET   16
+#define THRD_ATTR_SECURE          (0)
+#define THRD_ATTR_NON_SECURE      (1 << THRD_ATTR_SECURE_OFFSET)
+
+/* Lower value has higher priority */
+#define THRD_PRIOR_MASK           0xFF
+#define THRD_PRIOR_HIGHEST        0x0
+#define THRD_PRIOR_HIGH           0xF
+#define THRD_PRIOR_MEDIUM         0x1F
+#define THRD_PRIOR_LOW            0x7F
+#define THRD_PRIOR_LOWEST         0xFF
+
+/* Error code */
+#define THRD_SUCCESS              0
+#define THRD_ERR_INVALID_PARAM    1
+
+/* Thread entry function type */
+typedef void *(*tfm_core_thrd_entry_t)(void *);
+
+/* Thread context */
+struct tfm_core_thread_t {
+    tfm_core_thrd_entry_t pfn;          /* entry function               */
+    void            *param;             /* entry parameter              */
+    uintptr_t       stk_btm;            /* stack bottom (lower address) */
+    uintptr_t       stk_top;            /* stack top    (higher address)*/
+    uintptr_t       flih_ctx;           /* FLIH context pointer         */
+    uint32_t        prior;              /* priority                     */
+    uint32_t        state;              /* state                        */
+
+    struct tfm_arch_ctx_t    arch_ctx;  /* State context                */
+    struct tfm_core_thread_t *next;     /* next thread in list          */
+};
+
+/*
+ * Initialize a thread context with the necessary info.
+ *
+ * Parameters :
+ *  pth         -    pointer of caller provided thread context
+ *  pfn         -    thread entry function
+ *  param       -    thread entry function parameter
+ *  stk_top     -    stack pointer top (higher address)
+ *  stk_btm     -    stack pointer bottom (lower address)
+ *
+ * Notes :
+ *  Thread contex rely on caller allocated memory; initialize members in
+ *  context. This function does not insert thread into schedulable list.
+ */
+void tfm_core_thrd_init(struct tfm_core_thread_t *pth,
+                        tfm_core_thrd_entry_t pfn, void *param,
+                        uintptr_t stk_top, uintptr_t stk_btm);
+
+/*
+ * Set thread priority.
+ *
+ * Parameters :
+ *  pth         -     pointer of thread context
+ *  prior       -     priority value (0~255)
+ *
+ * Notes :
+ *  Set thread priority. Priority is set to THRD_PRIOR_MEDIUM in
+ *  tfm_core_thrd_init().
+ */
+__STATIC_INLINE void tfm_core_thrd_set_priority(struct tfm_core_thread_t *pth,
+                                                uint32_t prior)
+{
+    pth->prior &= ~THRD_PRIOR_MASK;
+    pth->prior |= prior & THRD_PRIOR_MASK;
+}
+
+/*
+ * Set thread security attribute.
+ *
+ * Parameters :
+ *  pth         -     pointer of thread context
+ *  attr_secure -     THRD_ATTR_SECURE or THRD_ATTR_NON_SECURE
+ *
+ * Notes
+ *  Reuse prior of thread context to shift down non-secure thread priority.
+ */
+__STATIC_INLINE void tfm_core_thrd_set_secure(struct tfm_core_thread_t *pth,
+                                              uint32_t attr_secure)
+{
+    pth->prior &= ~THRD_ATTR_NON_SECURE;
+    pth->prior |= attr_secure;
+}
+
+/*
+ * Set thread state.
+ *
+ * Parameters :
+ *  pth         -     pointer of thread context
+ *  new_state   -     new state of thread
+ *
+ * Return :
+ *  None
+ *
+ * Notes :
+ *  Thread state is not changed if invalid state value inputed.
+ */
+void tfm_core_thrd_set_state(struct tfm_core_thread_t *pth, uint32_t new_state);
+
+/*
+ * Get thread state.
+ *
+ * Parameters :
+ *  pth         -     pointer of thread context
+ *
+ * Return :
+ *  State of thread
+ */
+__STATIC_INLINE uint32_t tfm_core_thrd_get_state(struct tfm_core_thread_t *pth)
+{
+    return pth->state;
+}
+
+/*
+ * Set thread state return value.
+ *
+ * Parameters :
+ *  pth         -     pointer of thread context
+ *  retval      -     return value to be set for thread state
+ *
+ * Notes :
+ *  This API is useful for blocked syscall blocking thread. Syscall
+ *  could set its return value to the caller before caller goes.
+ */
+__STATIC_INLINE void tfm_core_thrd_set_retval(struct tfm_core_thread_t *pth,
+                                              uint32_t retval)
+{
+    TFM_STATE_RET_VAL(&pth->arch_ctx) = retval;
+}
+
+/*
+ * Validate thread context and insert it into schedulable list.
+ *
+ * Parameters :
+ *  pth         -     pointer of thread context
+ *
+ * Return :
+ *  THRD_SUCCESS for success. Or an error is returned.
+ *
+ * Notes :
+ *  This function validates thread info. It returns error if thread info
+ *  is not correct. Thread is available after successful tfm_core_thrd_start().
+ */
+uint32_t tfm_core_thrd_start(struct tfm_core_thread_t *pth);
+
+/*
+ * Get current running thread.
+ *
+ * Return :
+ *  Current running thread context pointer.
+ */
+struct tfm_core_thread_t *tfm_core_thrd_get_curr(void);
+
+/*
+ * Set the current running thread
+ * Note:
+ *  This API is intended to update the current thread in FLIH handling.
+ *  So that in nested FLIH interrupts, the handler knows which isolation
+ *  boundary was preempted.
+ *  Although the CURR_THRD is updated, it does not mean the running Partition
+ *  thread is changed. It could also be the FLIH function which runs with the
+ *  same isolation boundary of the CURR_THRD.
+ */
+void tfm_core_thrd_set_curr(struct tfm_core_thread_t *pth);
+
+/*
+ * Get next thread to run in list.
+ *
+ * Return :
+ *  Pointer of next thread to run.
+ */
+struct tfm_core_thread_t *tfm_core_thrd_get_next(void);
+
+/*
+ * Start scheduler for existing threads
+ *
+ * Parameters:
+ *  pth         -     pointer of the caller context collecting thread
+ *
+ * Notes :
+ *  This function should be called only ONCE to start the scheduler.
+ *  Caller needs to provide a thread object to collect current context.
+ *  The usage of the collected context is caller defined.
+ */
+void tfm_core_thrd_start_scheduler(struct tfm_core_thread_t *pth);
+
+/*
+ * Activate a scheduling action after exception.
+ *
+ * Notes :
+ *  This function could be called multiple times before scheduling.
+ */
+void tfm_core_thrd_activate_schedule(void);
+
+/*
+ * Save current architecture context into 'prev' thread and switch to 'next'.
+ *
+ * Parameters :
+ *  p_actx      -     latest caller context
+ *  prev        -     previous thread to be switched out
+ *  next        -     thread to be run
+ *
+ * Notes :
+ *  This function could be called multiple times before scheduling.
+ */
+void tfm_core_thrd_switch_context(struct tfm_arch_ctx_t *p_actx,
+                                  struct tfm_core_thread_t *prev,
+                                  struct tfm_core_thread_t *next);
+
+#endif
diff --git a/tf-m.old/secure_fw/spm/cmsis_psa/tfm_wait.c b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_wait.c
new file mode 100644
index 000000000..561174b7a
--- /dev/null
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_wait.c
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+#include "tfm_thread.h"
+#include "utilities.h"
+#include "tfm_wait.h"
+
+void tfm_event_wait(struct tfm_event_t *pevnt)
+{
+    TFM_CORE_ASSERT(pevnt && pevnt->magic == TFM_EVENT_MAGIC);
+
+    pevnt->owner = tfm_core_thrd_get_curr();
+    tfm_core_thrd_set_state(pevnt->owner, THRD_STATE_BLOCK);
+    tfm_arch_get_ctx(&(pevnt->owner->arch_ctx));
+    tfm_core_thrd_activate_schedule();
+}
+
+void tfm_event_wake(struct tfm_event_t *pevnt, uint32_t retval)
+{
+    TFM_CORE_ASSERT(pevnt && pevnt->magic == TFM_EVENT_MAGIC);
+
+    if (pevnt->owner && pevnt->owner->state == THRD_STATE_BLOCK) {
+        tfm_core_thrd_set_state(pevnt->owner, THRD_STATE_RUNNABLE);
+        tfm_core_thrd_set_retval(pevnt->owner, retval);
+        pevnt->owner = NULL;
+        tfm_core_thrd_activate_schedule();
+    }
+}
diff --git a/tf-m.old/secure_fw/spm/cmsis_psa/tfm_wait.h b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_wait.h
new file mode 100644
index 000000000..7e6f468ea
--- /dev/null
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_wait.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+#ifndef __TFM_WAIT_H__
+#define __TFM_WAIT_H__
+
+#include <stddef.h>
+
+#include "cmsis_compiler.h"
+
+/* The magic number has two purposes: corruption detection and debug */
+#define TFM_EVENT_MAGIC               0x65766e74
+
+struct tfm_event_t {
+    uint32_t magic;                    /* 'evnt'               */
+    struct tfm_core_thread_t *owner;   /* Event blocked thread */
+};
+
+/*
+ * Initialize an event object.
+ *
+ * Parameters:
+ *  pevnt      -    The pointer of event object allocated by the caller
+ */
+__STATIC_INLINE void tfm_event_init(struct tfm_event_t *pevnt)
+{
+    pevnt->magic = TFM_EVENT_MAGIC;
+    pevnt->owner = NULL;
+}
+
+/*
+ * Wait on an event object.
+ *
+ * Parameters:
+ *  pevnt      -    The pointer of event object allocated by the caller
+ *
+ * Notes:
+ *  Block caller thread by calling this function.
+ */
+void tfm_event_wait(struct tfm_event_t *pevnt);
+
+/*
+ * Wake up an event object.
+ *
+ * Parameters :
+ *  pevnt      -    The pointer of event object allocated by the caller
+ *  retval     -    Value to be returned to owner
+ *
+ * Notes:
+ *  Wake up the blocked thread and set parameter 'retval' as the return value.
+ */
+void tfm_event_wake(struct tfm_event_t *pevnt, uint32_t retval);
+
+#endif
diff --git a/tf-m.old/secure_fw/spm/ffm/psa_client_service_apis.h b/lib/tf-m/secure_fw/spm/ffm/psa_client_service_apis.h
new file mode 100644
index 000000000..166890a69
--- /dev/null
+++ b/lib/tf-m/secure_fw/spm/ffm/psa_client_service_apis.h
@@ -0,0 +1,312 @@
+/*
+ * Copyright (c) 2020-2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#ifndef __PSA_CLIENT_SERVICE_APIS_H__
+#define __PSA_CLIENT_SERVICE_APIS_H__
+
+/* Svcall for PSA Client APIs */
+
+/*
+ * \brief This function get the current PSA RoT lifecycle state.
+ *
+ * \return state                The current security lifecycle state of the PSA
+ *                              RoT. The PSA state and implementation state are
+ *                              encoded as follows:
+ * \arg                           state[15:8] – PSA lifecycle state
+ * \arg                           state[7:0] – IMPLEMENTATION DEFINED state
+ */
+uint32_t tfm_spm_get_lifecycle_state(void);
+
+/**
+ * \brief SVC handler for \ref psa_framework_version.
+ *
+ * \return version              The version of the PSA Framework implementation
+ *                              that is providing the runtime services to the
+ *                              caller.
+ */
+uint32_t tfm_spm_psa_framework_version(void);
+
+/**
+ * \brief SVC handler for \ref psa_version.
+ *
+ * \param[in] args              Include all input arguments: sid.
+ * \param[in] ns_caller         If 'true', call from non-secure client.
+ *                              Or from secure client.
+ *
+ * \retval PSA_VERSION_NONE     The RoT Service is not implemented, or the
+ *                              caller is not permitted to access the service.
+ * \retval > 0                  The version of the implemented RoT Service.
+ */
+uint32_t tfm_spm_psa_version(uint32_t *args, bool ns_caller);
+
+/**
+ * \brief SVC handler for \ref psa_connect.
+ *
+ * \param[in] args              Include all input arguments:
+ *                              sid, version.
+ * \param[in] ns_caller         If 'true', call from non-secure client.
+ *                              Or from secure client.
+ *
+ * \retval PSA_SUCCESS          Success.
+ * \retval PSA_ERROR_CONNECTION_REFUSED The SPM or RoT Service has refused the
+ *                              connection.
+ * \retval PSA_ERROR_CONNECTION_BUSY The SPM or RoT Service cannot make the
+ *                              connection at the moment.
+ * \retval "Does not return"    The RoT Service ID and version are not
+ *                              supported, or the caller is not permitted to
+ *                              access the service.
+ */
+psa_status_t tfm_spm_psa_connect(uint32_t *args, bool ns_caller);
+
+/**
+ * \brief SVC handler for \ref psa_call.
+ *
+ * \param[in] args              Include all input arguments:
+ *                              handle, in_vec, in_len, out_vec, out_len.
+ * \param[in] ns_caller         If 'true', call from non-secure client.
+ *                              Or from secure client.
+ * \param[in] lr                EXC_RETURN value of the SVC.
+ *
+ * \retval >=0                  RoT Service-specific status value.
+ * \retval <0                   RoT Service-specific error code.
+ * \retval PSA_ERROR_PROGRAMMER_ERROR The connection has been terminated by the
+ *                              RoT Service. The call is a PROGRAMMER ERROR if
+ *                              one or more of the following are true:
+ * \arg                           An invalid handle was passed.
+ * \arg                           The connection is already handling a request.
+ * \arg                           type < 0.
+ * \arg                           An invalid memory reference was provided.
+ * \arg                           in_len + out_len > PSA_MAX_IOVEC.
+ * \arg                           The message is unrecognized by the RoT
+ *                                Service or incorrectly formatted.
+ */
+psa_status_t tfm_spm_psa_call(uint32_t *args, bool ns_caller, uint32_t lr);
+
+/**
+ * \brief SVC handler for \ref psa_close.
+ *
+ * \param[in] args              Include all input arguments: handle.
+ * \param[in] ns_caller         If 'true', call from non-secure client.
+ *                              Or from secure client.
+ *
+ * \retval void                 Success.
+ * \retval "Does not return"    The call is invalid, one or more of the
+ *                              following are true:
+ * \arg                           An invalid handle was provided that is not
+ *                                the null handle.
+ * \arg                           The connection is handling a request.
+ */
+void tfm_spm_psa_close(uint32_t *args, bool ns_caller);
+
+/* Svcall for PSA Service APIs */
+
+/**
+ * \brief SVC handler for \ref psa_wait.
+ *
+ * \param[in] args              Include all input arguments:
+ *                              signal_mask, timeout.
+ *
+ * \retval >0                   At least one signal is asserted.
+ * \retval 0                    No signals are asserted. This is only seen when
+ *                              a polling timeout is used.
+ */
+psa_signal_t tfm_spm_psa_wait(uint32_t *args);
+
+/**
+ * \brief SVC handler for \ref psa_get.
+ *
+ * \param[in] args              Include all input arguments: signal, msg.
+ *
+ * \retval PSA_SUCCESS          Success, *msg will contain the delivered
+ *                              message.
+ * \retval PSA_ERROR_DOES_NOT_EXIST Message could not be delivered.
+ * \retval "Does not return"    The call is invalid because one or more of the
+ *                              following are true:
+ * \arg                           signal has more than a single bit set.
+ * \arg                           signal does not correspond to an RoT Service.
+ * \arg                           The RoT Service signal is not currently
+ *                                asserted.
+ * \arg                           The msg pointer provided is not a valid memory
+ *                                reference.
+ */
+psa_status_t tfm_spm_psa_get(uint32_t *args);
+
+/**
+ * \brief SVC handler for \ref psa_set_rhandle.
+ *
+ * \param[in] args              Include all input arguments:
+ *                              msg_handle, rhandle.
+ *
+ * \retval void                 Success, rhandle will be provided with all
+ *                              subsequent messages delivered on this
+ *                              connection.
+ * \retval "Does not return"    msg_handle is invalid.
+ */
+void tfm_spm_psa_set_rhandle(uint32_t *args);
+
+/**
+ * \brief SVC handler for \ref psa_read.
+ *
+ * \param[in] args              Include all input arguments:
+ *                              msg_handle, invec_idx, buffer, num_bytes.
+ *
+ * \retval >0                   Number of bytes copied.
+ * \retval 0                    There was no remaining data in this input
+ *                              vector.
+ * \retval "Does not return"    The call is invalid, one or more of the
+ *                              following are true:
+ * \arg                           msg_handle is invalid.
+ * \arg                           msg_handle does not refer to a request
+ *                                message.
+ * \arg                           invec_idx is equal to or greater than
+ *                                \ref PSA_MAX_IOVEC.
+ * \arg                           the memory reference for buffer is invalid or
+ *                                not writable.
+ */
+size_t tfm_spm_psa_read(uint32_t *args);
+
+/**
+ * \brief SVC handler for \ref psa_skip.
+ *
+ * \param[in] args              Include all input arguments:
+ *                              msg_handle, invec_idx, num_bytes.
+ *
+ * \retval >0                   Number of bytes skipped.
+ * \retval 0                    There was no remaining data in this input
+ *                              vector.
+ * \retval "Does not return"    The call is invalid, one or more of the
+ *                              following are true:
+ * \arg                           msg_handle is invalid.
+ * \arg                           msg_handle does not refer to a request
+ *                                message.
+ * \arg                           invec_idx is equal to or greater than
+ *                                \ref PSA_MAX_IOVEC.
+ */
+size_t tfm_spm_psa_skip(uint32_t *args);
+
+/**
+ * \brief SVC handler for \ref psa_write.
+ *
+ * \param[in] args              Include all input arguments:
+ *                              msg_handle, outvec_idx, buffer, num_bytes.
+ *
+ * \retval void                 Success
+ * \retval "Does not return"    The call is invalid, one or more of the
+ *                              following are true:
+ * \arg                           msg_handle is invalid.
+ * \arg                           msg_handle does not refer to a request
+ *                                message.
+ * \arg                           outvec_idx is equal to or greater than
+ *                                \ref PSA_MAX_IOVEC.
+ * \arg                           The memory reference for buffer is invalid.
+ * \arg                           The call attempts to write data past the end
+ *                                of the client output vector.
+ */
+void tfm_spm_psa_write(uint32_t *args);
+
+/**
+ * \brief SVC handler for \ref psa_reply.
+ *
+ * \param[in] args              Include all input arguments:
+ *                              msg_handle, status.
+ *
+ * \retval void                 Success.
+ * \retval "Does not return"    The call is invalid, one or more of the
+ *                              following are true:
+ * \arg                         msg_handle is invalid.
+ * \arg                         An invalid status code is specified for the
+ *                              type of message.
+ */
+void tfm_spm_psa_reply(uint32_t *args);
+
+/**
+ * \brief SVC handler for \ref psa_notify.
+ *
+ * \param[in] args              Include all input arguments: partition_id.
+ *
+ * \retval void                 Success.
+ * \retval "Does not return"    partition_id does not correspond to a Secure
+ *                              Partition.
+ */
+void tfm_spm_psa_notify(uint32_t *args);
+
+/**
+ * \brief SVC handler for \ref psa_clear.
+ *
+ * \retval void                 Success.
+ * \retval "Does not return"    The Secure Partition's doorbell signal is not
+ *                              currently asserted.
+ */
+void tfm_spm_psa_clear(void);
+
+/**
+ * \brief SVC handler for \ref psa_eoi.
+ *
+ * \param[in] args              Include all input arguments: irq_signal.
+ *
+ * \retval void                 Success.
+ * \retval "Does not return"    The call is invalid, one or more of the
+ *                              following are true:
+ * \arg                           irq_signal is not an interrupt signal.
+ * \arg                           irq_signal indicates more than one signal.
+ * \arg                           irq_signal is not currently asserted.
+ */
+void tfm_spm_psa_eoi(uint32_t *args);
+
+/**
+ * \brief Terminate execution within the calling Secure Partition and will not
+ *        return.
+ *
+ * \retval "Does not return"
+ */
+void tfm_spm_psa_panic(void);
+
+/**
+ * \brief SVC handler for \ref psa_irq_enable.
+ *
+ * \param[in] args            Include all input arguments: irq_signal.
+ *
+ * \retval void
+ * \retval "Does not return"  The call is invalid, if one or more of the
+ *                            following are true:
+ *  \arg                      irq_signal does not belong to the calling
+ *                            partition.
+ *  \arg                      irq_signal indicates more than one signal.
+ */
+void tfm_spm_irq_enable(uint32_t *args);
+
+/**
+ * \brief SVC handler for \ref psa_irq_disable.
+ *
+ * \param[in] args            Include all input arguments: irq_signal.
+ *
+ * \retval 0                  The interrupt was disabled prior to this call
+ *         1                  The interrupt was enabled prior to this call
+ * \retval "Does not return"  The call is invalid, if one or more of the
+ *                            following are true:
+ * \arg                       irq_signal does not belong to the calling
+ *                            partition.
+ * \arg                       irq_signal indicates more than one signal.
+ */
+psa_irq_status_t tfm_spm_irq_disable(uint32_t *args);
+
+/**
+ * \brief SVC handler for \ref psa_reset_signal.
+ *
+ * \param[in] args           Include all input arguments: irq_signal.
+ *
+ * \retval void
+ * \retval "Does not return" if one or more of the following are true:
+ * \arg                      irq_signal is not a signal for an interrupt
+ *                           that is specified with FLIH handling in the Secure
+ *                           Partition manifest.
+ * \arg                      irq_signal indicates more than one signal.
+ * \arg                      irq_signal is not currently asserted.
+ */
+void tfm_spm_psa_reset_signal(uint32_t *args);
+
+#endif /* __PSA_CLIENT_SERVICE_APIS_H__ */
diff --git a/lib/tf-m/secure_fw/spm/ffm/spm_log.c b/lib/tf-m/secure_fw/spm/ffm/spm_log.c
index b15f87d76..5488d5470 100644
--- a/lib/tf-m/secure_fw/spm/ffm/spm_log.c
+++ b/lib/tf-m/secure_fw/spm/ffm/spm_log.c
@@ -6,6 +6,22 @@
  */
 
 #include "tfm_spm_log.h"
+#if (TFM_SYSTEM_FP >= 1)
+#include <stdbool.h>
+#include "tfm_core_utils.h"
+#endif
+
+#define MAX_DIGIT_BITS 12  /* 8 char for number, 2 for '0x' and 2 for '\r\n' */
+#if (TFM_SYSTEM_FP >= 1)
+/* 1 for '+/-', 1 for '.' and 2 for '\r\n', remainings are for number */
+#define MAX_DIGIT_BITS_F      (24)
+#define MAX_DECIMAL_BITS      (6) /* Upto 6 decimal points */
+#define MAX_DECIMAL_NUM       (1000000U)
+#define MAX_FLOAT_NUM         (1e9)
+
+#define ERROR_NAN             ("nan\r\n")
+#define ERROR_NOT_SUPPORTED   ("not support\r\n")
+#endif
 
 #define MAX_DIGIT_BITS 12  /* 8 char for number, 2 for '0x' and 2 for '\r\n' */
 const static char HEX_TABLE[] = {'0', '1', '2', '3', '4', '5', '6', '7',
@@ -54,3 +70,112 @@ int32_t spm_log_msgval(const char *msg, size_t len, uint32_t value)
     }
     return (result_msg + result_val);
 }
+
+#if (TFM_SYSTEM_FP >= 1)
+void ftoa(double num, char* num_buff)
+{
+    int count = 0, k = 0;
+    int i = 0, j = 0, temp = 0;
+    bool f_neg = false;
+
+    /* NAN detection */
+    if (num != num) {
+        spm_memcpy(num_buff, ERROR_NAN, 5);
+        return;
+    }
+
+    /* Maximum float number supported is 1e9, otherwise overflow 32 bits */
+    if ((num > MAX_FLOAT_NUM) || (num < -MAX_FLOAT_NUM)) {
+        spm_memcpy(num_buff, ERROR_NOT_SUPPORTED, 13);
+        return;
+    }
+
+    /* Check negative number */
+    if (num < 0) {
+        f_neg = true;
+        num = 0 - num;
+    }
+
+    /* Break down */
+    int ipart = (int)num;
+    float part = (num - ipart) * MAX_DECIMAL_NUM;
+    int fpart = (int)part;
+    float rpart = part - fpart;
+    /* Round check */
+    if (rpart > 0.5) {
+        fpart += 1;
+    }
+
+    num_buff[count++] = '\n';
+    num_buff[count++] = '\r';
+
+    k = MAX_DECIMAL_BITS;
+    /* Fraction part */
+    while (count < MAX_DIGIT_BITS_F) {
+        --k;
+        num_buff[count++] = '0' + (fpart % 10);
+        if (!(fpart /= 10U)) {
+            break;
+        }
+    }
+
+    /* Adding extra 0s for decimal part starting with zero, e.g.0.000XXX */
+    while ((count < MAX_DIGIT_BITS_F) && (k-- > 0)) {
+        num_buff[count++] = '0';
+    }
+
+    /* Radix point */
+    if (count < MAX_DIGIT_BITS_F) {
+        num_buff[count++] = '.';
+    }
+
+    /* Integer part */
+    while (count < MAX_DIGIT_BITS_F) {
+        num_buff[count++] = '0' + (ipart % 10);
+        if (!(ipart /= 10)) {
+            break;
+        }
+    }
+
+    /* Add sign for negative number */
+    if (count < MAX_DIGIT_BITS_F) {
+        if (f_neg) {
+            num_buff[count++] = '-';
+        }
+    }
+
+    /* Reverse */
+    j = count;
+    i = 0;
+    while (i < j) {
+        temp = num_buff[i];
+        num_buff[i] = num_buff[j];
+        num_buff[j] = temp;
+        i++;
+        j--;
+    }
+}
+
+int32_t spm_log_msgvalf(const char *msg, size_t len, double value)
+{
+    int32_t result_msg = 0, result_val;
+    char value_str[MAX_DIGIT_BITS_F];
+
+    if (msg && len) {
+        result_msg = tfm_hal_output_spm_log(msg, len);
+        if (result_msg < TFM_HAL_SUCCESS) {
+            return result_msg;
+        }
+    }
+
+    spm_memset(value_str, 0, MAX_DIGIT_BITS_F);
+    ftoa(value, value_str);
+    result_val = tfm_hal_output_spm_log(value_str,
+                                        MAX_DIGIT_BITS_F);
+    if (result_val < TFM_HAL_SUCCESS) {
+        return result_val;
+    }
+
+    return (result_msg + result_val);
+}
+#endif /* TFM_SYSTEM_FP >= 1 */
diff --git a/tf-m.old/secure_fw/spm/ffm/spm_psa_client_call.c b/lib/tf-m/secure_fw/spm/ffm/spm_psa_client_call.c
new file mode 100644
index 000000000..628773ebd
--- /dev/null
+++ b/lib/tf-m/secure_fw/spm/ffm/spm_psa_client_call.c
@@ -0,0 +1,371 @@
+/*
+ * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#include "psa/service.h"
+#include "spm_ipc.h"
+#include "tfm_core_utils.h"
+#include "tfm_memory_utils.h"
+#include "load/service_defs.h"
+#include "spm_psa_client_call.h"
+#include "utilities.h"
+#include "tfm_wait.h"
+#include "tfm_nspm.h"
+#include "ffm/spm_error_base.h"
+
+#define GET_STATELESS_SERVICE(index)    (stateless_services_ref_tbl[index])
+extern struct service_t *stateless_services_ref_tbl[];
+
+uint32_t tfm_spm_client_psa_framework_version(void)
+{
+    return PSA_FRAMEWORK_VERSION;
+}
+
+uint32_t tfm_spm_client_psa_version(uint32_t sid, bool ns_caller)
+{
+    struct service_t *service;
+
+    /*
+     * It should return PSA_VERSION_NONE if the RoT Service is not
+     * implemented.
+     */
+    service = tfm_spm_get_service_by_sid(sid);
+    if (!service) {
+        return PSA_VERSION_NONE;
+    }
+
+    /*
+     * It should return PSA_VERSION_NONE if the caller is not authorized
+     * to access the RoT Service.
+     */
+    if (tfm_spm_check_authorization(sid, service, ns_caller) != SPM_SUCCESS) {
+        return PSA_VERSION_NONE;
+    }
+
+    return service->p_ldinf->version;
+}
+
+psa_status_t tfm_spm_client_psa_connect(uint32_t sid, uint32_t version,
+                                        bool ns_caller)
+{
+    struct service_t *service;
+    struct tfm_msg_body_t *msg;
+    struct tfm_conn_handle_t *connect_handle;
+    int32_t client_id;
+    psa_handle_t handle;
+
+    /*
+     * It is a PROGRAMMER ERROR if the RoT Service does not exist on the
+     * platform.
+     */
+    service = tfm_spm_get_service_by_sid(sid);
+    if (!service) {
+        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_CONNECTION_REFUSED);
+    }
+
+    /* It is a PROGRAMMER ERROR if connecting to a stateless service. */
+    if (SERVICE_IS_STATELESS(service->p_ldinf->flags)) {
+        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
+    }
+
+    /*
+     * It is a PROGRAMMER ERROR if the caller is not authorized to access the
+     * RoT Service.
+     */
+    if (tfm_spm_check_authorization(sid, service, ns_caller) != SPM_SUCCESS) {
+        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_CONNECTION_REFUSED);
+    }
+
+    /*
+     * It is a PROGRAMMER ERROR if the version of the RoT Service requested is
+     * not supported on the platform.
+     */
+    if (tfm_spm_check_client_version(service, version) != SPM_SUCCESS) {
+        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_CONNECTION_REFUSED);
+    }
+
+    if (ns_caller) {
+        client_id = tfm_nspm_get_current_client_id();
+    } else {
+        client_id = tfm_spm_partition_get_running_partition_id();
+    }
+
+    /*
+     * Create connection handle here since it is possible to return the error
+     * code to client when creation fails.
+     */
+    connect_handle = tfm_spm_create_conn_handle(service, client_id);
+    if (!connect_handle) {
+        return PSA_ERROR_CONNECTION_BUSY;
+    }
+
+    msg = tfm_spm_get_msg_buffer_from_conn_handle(connect_handle);
+    if (!msg) {
+        /* Have no enough resource to create message */
+        return PSA_ERROR_CONNECTION_BUSY;
+    }
+
+    handle = tfm_spm_to_user_handle(connect_handle);
+    /* No input or output needed for connect message */
+    tfm_spm_fill_msg(msg, service, handle, PSA_IPC_CONNECT,
+                     client_id, NULL, 0, NULL, 0, NULL);
+
+    /*
+     * Send message and wake up the SP who is waiting on message queue,
+     * and scheduler triggered
+     */
+    tfm_spm_send_event(service, msg);
+
+    return PSA_SUCCESS;
+}
+
+psa_status_t tfm_spm_client_psa_call(psa_handle_t handle, int32_t type,
+                                     const psa_invec *inptr, size_t in_num,
+                                     psa_outvec *outptr, size_t out_num,
+                                     bool ns_caller, uint32_t privileged)
+{
+    psa_invec invecs[PSA_MAX_IOVEC];
+    psa_outvec outvecs[PSA_MAX_IOVEC];
+    struct tfm_conn_handle_t *conn_handle;
+    struct service_t *service;
+    struct tfm_msg_body_t *msg;
+    int i, j;
+    int32_t client_id;
+    uint32_t sid, version, index;
+
+    /* It is a PROGRAMMER ERROR if in_len + out_len > PSA_MAX_IOVEC. */
+    if ((in_num > PSA_MAX_IOVEC) ||
+        (out_num > PSA_MAX_IOVEC) ||
+        (in_num + out_num > PSA_MAX_IOVEC)) {
+        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
+    }
+
+    if (ns_caller) {
+        client_id = tfm_nspm_get_current_client_id();
+    } else {
+        client_id = tfm_spm_partition_get_running_partition_id();
+    }
+
+    /* Allocate space from handle pool for static handle. */
+    if (IS_STATIC_HANDLE(handle)) {
+        index = GET_INDEX_FROM_STATIC_HANDLE(handle);
+
+        if (!IS_VALID_STATIC_HANDLE_IDX(index)) {
+            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
+        }
+
+        service = GET_STATELESS_SERVICE(index);
+        if (!service) {
+            tfm_core_panic();
+        }
+
+        sid = service->p_ldinf->sid;
+
+        /*
+         * It is a PROGRAMMER ERROR if the caller is not authorized to access
+         * the RoT Service.
+         */
+        if (tfm_spm_check_authorization(sid, service, ns_caller)
+            != SPM_SUCCESS) {
+            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_CONNECTION_REFUSED);
+        }
+
+        version = GET_VERSION_FROM_STATIC_HANDLE(handle);
+
+        if (tfm_spm_check_client_version(service, version) != SPM_SUCCESS) {
+            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
+        }
+
+        conn_handle = tfm_spm_create_conn_handle(service, client_id);
+
+        if (!conn_handle) {
+            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_CONNECTION_BUSY);
+        }
+
+        conn_handle->rhandle = NULL;
+        handle = tfm_spm_to_user_handle(conn_handle);
+    } else {
+        conn_handle = tfm_spm_to_handle_instance(handle);
+
+        /* It is a PROGRAMMER ERROR if an invalid handle was passed. */
+        if (tfm_spm_validate_conn_handle(conn_handle, client_id)
+            != SPM_SUCCESS) {
+            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
+        }
+
+        /*
+         * It is a PROGRAMMER ERROR if the connection is currently
+         * handling a request.
+         */
+        if (conn_handle->status == TFM_HANDLE_STATUS_ACTIVE) {
+            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
+        }
+
+        /*
+         * Return PSA_ERROR_PROGRAMMER_ERROR immediately for the connection
+         * has been terminated by the RoT Service.
+         */
+        if (conn_handle->status == TFM_HANDLE_STATUS_CONNECT_ERROR) {
+            return PSA_ERROR_PROGRAMMER_ERROR;
+        }
+
+        service = conn_handle->service;
+    }
+
+    if (!service) {
+        /* FixMe: Need to implement one mechanism to resolve this failure. */
+        tfm_core_panic();
+    }
+
+    /*
+     * Read client invecs from the wrap input vector. It is a PROGRAMMER ERROR
+     * if the memory reference for the wrap input vector is invalid or not
+     * readable.
+     */
+    if (tfm_memory_check(inptr, in_num * sizeof(psa_invec), ns_caller,
+        TFM_MEMORY_ACCESS_RO, privileged) != SPM_SUCCESS) {
+        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
+    }
+
+    /*
+     * Read client outvecs from the wrap output vector and will update the
+     * actual length later. It is a PROGRAMMER ERROR if the memory reference for
+     * the wrap output vector is invalid or not read-write.
+     */
+    if (tfm_memory_check(outptr, out_num * sizeof(psa_outvec), ns_caller,
+        TFM_MEMORY_ACCESS_RW, privileged) != SPM_SUCCESS) {
+        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
+    }
+
+    spm_memset(invecs, 0, sizeof(invecs));
+    spm_memset(outvecs, 0, sizeof(outvecs));
+
+    /* Copy the address out to avoid TOCTOU attacks. */
+    spm_memcpy(invecs, inptr, in_num * sizeof(psa_invec));
+    spm_memcpy(outvecs, outptr, out_num * sizeof(psa_outvec));
+
+    /*
+     * For client input vector, it is a PROGRAMMER ERROR if the provided payload
+     * memory reference was invalid or not readable.
+     */
+    for (i = 0; i < in_num; i++) {
+        if (tfm_memory_check(invecs[i].base, invecs[i].len, ns_caller,
+            TFM_MEMORY_ACCESS_RO, privileged) != SPM_SUCCESS) {
+            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
+        }
+    }
+
+    /*
+     * Clients must never overlap input parameters because of the risk of a
+     * double-fetch inconsistency.
+     * Overflow is checked in tfm_memory_check functions.
+     */
+    for (i = 0; i + 1 < in_num; i++) {
+        for (j = i+1; j < in_num; j++) {
+            if (!((char *) invecs[j].base + invecs[j].len <=
+                  (char *) invecs[i].base ||
+                  (char *) invecs[j].base >=
+                  (char *) invecs[i].base + invecs[i].len)) {
+                TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
+            }
+        }
+    }
+
+    /*
+     * For client output vector, it is a PROGRAMMER ERROR if the provided
+     * payload memory reference was invalid or not read-write.
+     */
+    for (i = 0; i < out_num; i++) {
+        if (tfm_memory_check(outvecs[i].base, outvecs[i].len,
+            ns_caller, TFM_MEMORY_ACCESS_RW, privileged) != SPM_SUCCESS) {
+            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
+        }
+    }
+
+    /*
+     * FixMe: Need to check if the message is unrecognized by the RoT
+     * Service or incorrectly formatted.
+     */
+    msg = tfm_spm_get_msg_buffer_from_conn_handle(conn_handle);
+    if (!msg) {
+        /* FixMe: Need to implement one mechanism to resolve this failure. */
+        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
+    }
+
+    tfm_spm_fill_msg(msg, service, handle, type, client_id,
+                     invecs, in_num, outvecs, out_num, outptr);
+
+    /*
+     * Send message and wake up the SP who is waiting on message queue,
+     * and scheduler triggered
+     */
+    tfm_spm_send_event(service, msg);
+
+    return PSA_SUCCESS;
+}
+
+void tfm_spm_client_psa_close(psa_handle_t handle, bool ns_caller)
+{
+    struct service_t *service;
+    struct tfm_msg_body_t *msg;
+    struct tfm_conn_handle_t *conn_handle;
+    int32_t client_id;
+
+    /* It will have no effect if called with the NULL handle */
+    if (handle == PSA_NULL_HANDLE) {
+        return;
+    }
+
+    /* It is a PROGRAMMER ERROR if called with a stateless handle. */
+    if (IS_STATIC_HANDLE(handle)) {
+        TFM_PROGRAMMER_ERROR(ns_caller, PROGRAMMER_ERROR_NULL);
+    }
+
+    if (ns_caller) {
+        client_id = tfm_nspm_get_current_client_id();
+    } else {
+        client_id = tfm_spm_partition_get_running_partition_id();
+    }
+
+    conn_handle = tfm_spm_to_handle_instance(handle);
+    /*
+     * It is a PROGRAMMER ERROR if an invalid handle was provided that is not
+     * the null handle.
+     */
+    if (tfm_spm_validate_conn_handle(conn_handle, client_id) != SPM_SUCCESS) {
+        TFM_PROGRAMMER_ERROR(ns_caller, PROGRAMMER_ERROR_NULL);
+    }
+
+    service = conn_handle->service;
+    if (!service) {
+        /* FixMe: Need to implement one mechanism to resolve this failure. */
+        tfm_core_panic();
+    }
+
+    msg = tfm_spm_get_msg_buffer_from_conn_handle(conn_handle);
+    if (!msg) {
+        /* FixMe: Need to implement one mechanism to resolve this failure. */
+        tfm_core_panic();
+    }
+
+    /*
+     * It is a PROGRAMMER ERROR if the connection is currently handling a
+     * request.
+     */
+    if (conn_handle->status == TFM_HANDLE_STATUS_ACTIVE) {
+        TFM_PROGRAMMER_ERROR(ns_caller, PROGRAMMER_ERROR_NULL);
+    }
+
+    /* No input or output needed for close message */
+    tfm_spm_fill_msg(msg, service, handle, PSA_IPC_DISCONNECT, client_id,
+                     NULL, 0, NULL, 0, NULL);
+
+    /*
+     * Send message and wake up the SP who is waiting on message queue,
+     * and scheduler triggered
+     */
+    tfm_spm_send_event(service, msg);
+}
diff --git a/tf-m.old/secure_fw/spm/ffm/spm_psa_client_call.h b/lib/tf-m/secure_fw/spm/ffm/spm_psa_client_call.h
new file mode 100644
index 000000000..0a05a0e77
--- /dev/null
+++ b/lib/tf-m/secure_fw/spm/ffm/spm_psa_client_call.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#ifndef __TFM_PSA_CLIENT_CALL_H__
+#define __TFM_PSA_CLIENT_CALL_H__
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "psa/client.h"
+
+#define PROGRAMMER_ERROR_NULL
+#define TFM_PROGRAMMER_ERROR(ns_caller, error_status) \
+        do { \
+            if (ns_caller) { \
+                return error_status; \
+             } else { \
+                tfm_core_panic(); \
+             } \
+        } while (0)
+
+/* Common handlers for PSA client calls */
+
+/**
+ * \brief handler for \ref psa_framework_version.
+ *
+ * \return version              The version of the PSA Framework implementation
+ *                              that is providing the runtime services.
+ */
+uint32_t tfm_spm_client_psa_framework_version(void);
+
+/**
+ * \brief handler for \ref psa_version.
+ *
+ * \param[in] sid               RoT Service identity.
+ * \param[in] ns_caller         If 'true', call from non-secure client.
+ *                              Otherwise from secure client.
+ *
+ * \retval PSA_VERSION_NONE     The RoT Service is not implemented, or the
+ *                              caller is not permitted to access the service.
+ * \retval > 0                  The version of the implemented RoT Service.
+ */
+uint32_t tfm_spm_client_psa_version(uint32_t sid, bool ns_caller);
+
+/**
+ * \brief handler for \ref psa_connect.
+ *
+ * \param[in] sid               RoT Service identity.
+ * \param[in] version           The version of the RoT Service.
+ * \param[in] ns_caller         If 'true', call from non-secure client.
+ *                              Otherwise from secure client.
+ *
+ * \retval PSA_SUCCESS          Success.
+ * \retval PSA_ERROR_CONNECTION_REFUSED The SPM or RoT Service has refused the
+ *                              connection.
+ * \retval PSA_ERROR_CONNECTION_BUSY The SPM or RoT Service cannot make the
+ *                              connection at the moment.
+ * \retval "Does not return"    The RoT Service ID and version are not
+ *                              supported, or the caller is not permitted to
+ *                              access the service.
+ */
+psa_status_t tfm_spm_client_psa_connect(uint32_t sid, uint32_t version,
+                                        bool ns_caller);
+
+/**
+ * \brief handler for \ref psa_call.
+ *
+ * \param[in] handle            Service handle to the established connection,
+ *                              \ref psa_handle_t
+ * \param[in] type              The request type.
+ *                              Must be zero( \ref PSA_IPC_CALL) or positive.
+ * \param[in] inptr             Array of input psa_invec structures.
+ *                              \ref psa_invec
+ * \param[in] in_num            Number of input psa_invec structures.
+ *                              \ref psa_invec
+ * \param[in] outptr            Array of output psa_outvec structures.
+ *                              \ref psa_outvec
+ * \param[in] out_num           Number of outut psa_outvec structures.
+ *                              \ref psa_outvec
+ * \param[in] ns_caller         If 'true', call from non-secure client.
+ *                              Otherwise from secure client.
+ * \param[in] privileged        Privileged mode or unprivileged mode:
+ *                              \ref TFM_PARTITION_UNPRIVILEGED_MODE
+ *                              \ref TFM_PARTITION_PRIVILEGED_MODE
+ *
+ * \retval PSA_SUCCESS          Success.
+ * \retval "Does not return"    The call is invalid, one or more of the
+ *                              following are true:
+ * \arg                           An invalid handle was passed.
+ * \arg                           The connection is already handling a request.
+ * \arg                           An invalid memory reference was provided.
+ * \arg                           in_num + out_num > PSA_MAX_IOVEC.
+ * \arg                           The message is unrecognized by the RoT
+ *                                Service or incorrectly formatted.
+ */
+psa_status_t tfm_spm_client_psa_call(psa_handle_t handle, int32_t type,
+                                     const psa_invec *inptr, size_t in_num,
+                                     psa_outvec *outptr, size_t out_num,
+                                     bool ns_caller, uint32_t privileged);
+
+/**
+ * \brief handler for \ref psa_close.
+ *
+ * \param[in] handle            Service handle to the connection to be closed,
+ *                              \ref psa_handle_t
+ * \param[in] ns_caller         If 'true', call from non-secure client.
+ *                              Otherwise from secure client.
+ *
+ * \retval void                 Success.
+ * \retval "Does not return"    The call is invalid, one or more of the
+ *                              following are true:
+ * \arg                           An invalid handle was provided that is not
+ *                                the null handle.
+ * \arg                           The connection is handling a request.
+ */
+void tfm_spm_client_psa_close(psa_handle_t handle, bool ns_caller);
+
+#endif
diff --git a/lib/tf-m/secure_fw/spm/ffm/tfm_boot_data.c b/lib/tf-m/secure_fw/spm/ffm/tfm_boot_data.c
index 1d0aeeff1..39cd00ad4 100644
--- a/lib/tf-m/secure_fw/spm/ffm/tfm_boot_data.c
+++ b/lib/tf-m/secure_fw/spm/ffm/tfm_boot_data.c
@@ -12,12 +12,13 @@
 #include "tfm_memory_utils.h"
 #include "tfm_api.h"
 #include "tfm_core_utils.h"
-#include "psa_manifest/pid.h"
+#include "spm_partition_defs.h"
 #ifdef TFM_PSA_API
 #include "internal_errors.h"
 #include "utilities.h"
 #include "psa/service.h"
-#include "thread.h"
+#include "tfm_thread.h"
+#include "tfm_wait.h"
 #include "tfm_spm_hal.h"
 #include "spm_ipc.h"
 #include "load/partition_defs.h"
@@ -56,7 +57,7 @@ static uint32_t is_boot_data_valid = BOOT_DATA_INVALID;
  *        data area (between bootloader and runtime firmware).
  */
 struct boot_data_access_policy {
-    int32_t partition_id;
+    uint32_t partition_id;
     uint32_t major_type;
 };
 
@@ -86,7 +87,7 @@ static const struct boot_data_access_policy access_policy_table[] = {
  */
 static int32_t tfm_core_check_boot_data_access_policy(uint8_t major_type)
 {
-    int32_t partition_id;
+    uint32_t partition_id;
     uint32_t i;
     int32_t rc = -1;
     const uint32_t array_size = ARRAY_SIZE(access_policy_table);
diff --git a/lib/tf-m/secure_fw/spm/include/interface/svc_num.h b/lib/tf-m/secure_fw/spm/include/interface/svc_num.h
index 55e796dd7..7a3c3c521 100644
--- a/lib/tf-m/secure_fw/spm/include/interface/svc_num.h
+++ b/lib/tf-m/secure_fw/spm/include/interface/svc_num.h
@@ -8,6 +8,8 @@
 #ifndef __SVC_NUM_H__
 #define __SVC_NUM_H__
 
+#include "tfm_spm_log.h"
+
 /*
  * SVC numbers for FF-M compliant implementations.
  * 0x0 ~ 0x7F can be only called from Thread Mode, the rest from ISR only.
@@ -37,11 +39,12 @@
 #define TFM_SVC_PSA_IRQ_DISABLE         (0x12)
 #define TFM_SVC_PSA_RESET_SIGNAL        (0x13)
 /* TF-M specific, starts from 0x40 */
-#define TFM_SVC_GET_BOOT_DATA           (0x40)
-#define TFM_SVC_SPM_INIT                (0x41)
-#define TFM_SVC_FLIH_FUNC_RETURN        (0x42)
+#define TFM_SVC_SPM_REQUEST             (0x40)
+#define TFM_SVC_GET_BOOT_DATA           (0x41)
+#define TFM_SVC_SPM_INIT                (0x42)
+#define TFM_SVC_FLIH_FUNC_RETURN        (0x43)
 #define TFM_SVC_THREAD_NUMBER_END       (0x7F)
-#if TFM_SP_LOG_RAW_ENABLED
+#if (TFM_SPM_LOG_LEVEL > TFM_SPM_LOG_LEVEL_SILENCE)
 #define TFM_SVC_OUTPUT_UNPRIV_STRING    (TFM_SVC_THREAD_NUMBER_END)
 #endif
 
diff --git a/lib/tf-m/secure_fw/spm/include/lists.h b/lib/tf-m/secure_fw/spm/include/lists.h
index 1a11dee15..c0962c562 100644
--- a/lib/tf-m/secure_fw/spm/include/lists.h
+++ b/lib/tf-m/secure_fw/spm/include/lists.h
@@ -75,22 +75,8 @@ struct bi_list_node_t {
     (curr)->next = node;                          \
 } while (0)
 
-/* Move a node after posi node */
-#define UNI_LIST_MOVE_AFTER(posi, prev, node) do {\
-    if (prev != NULL) {                           \
-        (prev)->next = (node)->next;              \
-        (node)->next = (posi)->next;              \
-        (posi)->next = node;                      \
-    }                                             \
-} while (0)
-
 /* Go through each node of a list */
 #define UNI_LIST_FOR_EACH(node, head)             \
     for (node = (head)->next; node != NULL; node = (node)->next)
 
-/* Go through each node of a list with prev node */
-#define UNI_LIST_FOR_EACH_PREV(prev, node, head)  \
-    for (prev = NULL, node = (head)->next;        \
-                 node != NULL; prev = node, node = (prev)->next)
-
 #endif /* __LISTS_H__ */
diff --git a/lib/tf-m/secure_fw/spm/include/load/asset_defs.h b/lib/tf-m/secure_fw/spm/include/load/asset_defs.h
index f5b4608d4..af1289c68 100644
--- a/lib/tf-m/secure_fw/spm/include/load/asset_defs.h
+++ b/lib/tf-m/secure_fw/spm/include/load/asset_defs.h
@@ -9,24 +9,25 @@
 
 #include <stdint.h>
 
-/* Memory, MMIO and PPB asset attributes */
-#define ASSET_ATTR_READ_ONLY        (1U << 0)  /* 1: Read-only MMIO         */
-#define ASSET_ATTR_READ_WRITE       (1U << 1)  /* 1: Read-write MMIO        */
-#define ASSET_ATTR_PPB              (1U << 2)  /* 1: PPB indicator          */
+/* Memory-based object attributes */
+#define ASSET_MEM_RD_BIT            (1U << 0)  /* 1: readable memory address */
+#define ASSET_MEM_WR_BIT            (1U << 1)  /* 1: writable memory address */
+#define ASSET_MEM_PPB_BIT           (1U << 2)  /* 1: PPB indicator           */
 
-#define ASSET_ATTR_NAMED_MMIO       (1U << 3)  /* 1: Named mmio object       */
-#define ASSET_ATTR_NUMBERED_MMIO    (1U << 4)  /* 1: Numbered mmio object    */
-#define ASSET_ATTR_MMIO             (ASSET_ATTR_NAMED_MMIO | \
-                                     ASSET_ATTR_NUMBERED_MMIO)
+/* Customized objects such as device or symbol. Refer by 'dev' in the union. */
+#define ASSET_DEV_REF_BIT           (1U << 3)
+
+#define PTR_TO_REFERENCE(x)         (uintptr_t)(x)
+#define REFERENCE_TO_PTR(x, t)      (t)(x)
 
 struct asset_desc_t {
     union {
-        struct {                            /* Memory-based asset type  */
-            uintptr_t start;
-            uintptr_t limit;
+        struct {                            /* Memory asset type        */
+            uintptr_t addr_x;
+            uintptr_t addr_y;
         } mem;
         struct {                            /* Device asset type        */
-            uintptr_t dev_ref;
+            uintptr_t addr_ref;
             uintptr_t reserved;
         } dev;
     };
diff --git a/tf-m.old/secure_fw/spm/include/load/irq_defs.h b/lib/tf-m/secure_fw/spm/include/load/irq_defs.h
new file mode 100644
index 000000000..1540d23f6
--- /dev/null
+++ b/lib/tf-m/secure_fw/spm/include/load/irq_defs.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#ifndef __IRQ_DEFS_H__
+#define __IRQ_DEFS_H__
+
+#include "psa/service.h"
+
+struct irq_load_info_t {
+    uint32_t source;                       /* IRQ source (number/index)       */
+    uint32_t flih_func;                    /* FLIH function - 0 if SLIH       */
+    psa_signal_t signal;                   /* The signal assigned for IRQ     */
+};
+
+#endif /* __IRQ_DEFS_H__ */
diff --git a/lib/tf-m/secure_fw/spm/include/load/partition_defs.h b/lib/tf-m/secure_fw/spm/include/load/partition_defs.h
index a427c5b26..9eb3ea978 100644
--- a/lib/tf-m/secure_fw/spm/include/load/partition_defs.h
+++ b/lib/tf-m/secure_fw/spm/include/load/partition_defs.h
@@ -11,11 +11,6 @@
 #include <stddef.h>
 #include <stdint.h>
 
-/* TF-M internal partition ID */
-#define TFM_SP_NON_SECURE_ID                    (0)
-#define TFM_SP_IDLE_ID                          (1)
-#define INVALID_PARTITION_ID                    (~0U)
-
 /* Encode a magic number into version for validating partition info */
 #define PARTITION_INFO_VERSION_MASK             (0x0000FFFF)
 #define PARTITION_INFO_MAGIC_MASK               (0xFFFF0000)
@@ -38,20 +33,14 @@
 #define PARTITION_PRI_LOWEST                    (0xFF)
 #define PARTITION_PRI_MASK                      (0xFF)
 
-/* TODO: This def couples with library model, rename it later. */
 #define SPM_PART_FLAG_PSA_ROT                   (1U << 8)
-
-#define PARTITION_MODEL_IPC                     (1U << 9)
+#define SPM_PART_FLAG_IPC                       (1U << 9)
 
 #define PARTITION_PRIORITY(flag)                ((flag) & PARTITION_PRI_MASK)
 #define TO_THREAD_PRIORITY(x)                   (x)
 
 #define ENTRY_TO_POSITION(x)                    (uintptr_t)(x)
 #define POSITION_TO_ENTRY(x, t)                 (t)(x)
-
-#define PTR_TO_REFERENCE(x)                     (uintptr_t)(x)
-#define REFERENCE_TO_PTR(x, t)                  (t)(x)
-
 /*
  * Common partition structure type, the extendable data is right after it.
  * Extendable data has different size for each partition, and must be 4-byte
@@ -60,7 +49,7 @@
  */
 struct partition_load_info_t {
     uint32_t        psa_ff_ver;         /* Encode the version with magic    */
-    int32_t         pid;                /* Partition ID                     */
+    uint32_t        pid;                /* Partition ID                     */
     uint32_t        flags;              /* ARoT/PRoT, SFN/IPC, priority     */
     uintptr_t       entry;              /* Entry point                      */
     size_t          stack_size;         /* Stack size                       */
diff --git a/lib/tf-m/secure_fw/spm/include/load/spm_load_api.h b/lib/tf-m/secure_fw/spm/include/load/spm_load_api.h
index d8fbc166a..bb8f8993b 100644
--- a/lib/tf-m/secure_fw/spm/include/load/spm_load_api.h
+++ b/lib/tf-m/secure_fw/spm/include/load/spm_load_api.h
@@ -10,16 +10,13 @@
 #define __SPM_LOAD_API_H__
 
 #include "asset_defs.h"
-#include "interrupt_defs.h"
+#include "irq_defs.h"
 #include "partition_defs.h"
 #include "service_defs.h"
 #include "spm_ipc.h"
 
-/* No more partition to be loaded */
-#define NO_MORE_PARTITION        NULL
-
 /* Length of extendable variables in partition load type */
-#define LOAD_INFO_EXT_LENGTH                        (2)
+#define LOAD_INFO_EXT_LENGTH                2
 /* Argument "pldinf" must be a "struct partition_load_info_t *". */
 #define LOAD_INFSZ_BYTES(pldinf)                                       \
     (sizeof(*(pldinf)) + LOAD_INFO_EXT_LENGTH * sizeof(uintptr_t) +    \
@@ -42,6 +39,7 @@
     ((uintptr_t)LOAD_INFO_ASSET(pldinf) +                              \
      (pldinf)->nassets * sizeof(struct asset_desc_t))
 
+
 /* Runtime partition struct list head node type */
 struct partition_head_t {
     uint32_t reserved;                  /* Reserved             */
@@ -56,9 +54,9 @@ struct service_head_t {
 
 /*
  * Load a partition object to linked list and return if a load is successful.
- * An 'assuredly' function, return NO_MORE_PARTITION for no more partitions and
- * return a valid pointer if succeed. Other errors simply panic the system and
- * never return.
+ * An 'assuredly' function, return NULL for no more partitions and
+ * return a valid pointer if succeed. Other errors simply panic
+ * the system and never return.
  */
 struct partition_t *load_a_partition_assuredly(struct partition_head_t *head);
 
diff --git a/lib/tf-m/secure_fw/spm/include/tfm_arch.h b/lib/tf-m/secure_fw/spm/include/tfm_arch.h
index f7740c292..8a96d9fb3 100644
--- a/lib/tf-m/secure_fw/spm/include/tfm_arch.h
+++ b/lib/tf-m/secure_fw/spm/include/tfm_arch.h
@@ -26,7 +26,7 @@
 
 #define XPSR_T32            0x01000000
 
-/* State context defined by architecture */
+/* General core state context */
 struct tfm_state_context_t {
     uint32_t    r0;
     uint32_t    r1;
@@ -36,38 +36,9 @@ struct tfm_state_context_t {
     uint32_t    lr;
     uint32_t    ra;
     uint32_t    xpsr;
-};
-
-/* Context addition to state context */
-struct tfm_additional_context_t {
-    uint32_t    callee[8];     /* R4-R11. NOT ORDERED!! */
-};
-
-/* Full thread context */
-struct full_context_t {
-    struct tfm_additional_context_t addi_ctx;
-    struct tfm_state_context_t      stat_ctx;
-};
-
-/* Context control */
-struct context_ctrl_t {
-    uint32_t                sp;        /* Stack pointer (higher address)   */
-    uint32_t                sp_limit;  /* Stack limit (lower address)      */
-    uint32_t                reserved;  /* Reserved                         */
-    uint32_t                exc_ret;   /* EXC_RETURN pattern.              */
-};
+} __attribute__ ((aligned(8)));
 
-/*
- * The context on MSP when de-privileged FLIH Function calls SVC to return.
- * It is the same when de-privileged FLIH Function is ready to run.
- */
-struct context_flih_ret_t {
-    uint64_t stack_seal;    /* Two words stack seal */
-    struct tfm_additional_context_t addi_ctx;
-    uint32_t exc_ret;   /* EXC_RETURN value when interrupt exception ocurrs */
-    uint32_t psp;       /* PSP when interrupt exception ocurrs              */
-    struct tfm_state_context_t state_ctx; /* ctx on SVC_PREPARE_DEPRIV_FLIH */
-};
+#define TFM_STATE_RET_VAL(ctx) (((struct tfm_state_context_t *)((ctx)->sp))->r0)
 
 __attribute__ ((always_inline))
 __STATIC_INLINE void tfm_arch_trigger_pendsv(void)
@@ -111,40 +82,28 @@ __STATIC_INLINE void __set_CONTROL_SPSEL(uint32_t SPSEL)
     __ISB();
 }
 
-/* Set secure exceptions priority. */
-void tfm_arch_set_secure_exception_priorities(void);
-
-/* Configure various extensions. */
-void tfm_arch_config_extensions(void);
-
-/* Clear float point status. */
-void tfm_arch_clear_fp_status(void);
-
 /*
- * This function is called after SPM has initialized.
- * It frees the stack used by SPM initialization and do Exception Return.
- * It does not return.
+ * Initialize CPU architecture specific thread context extension
  */
-void tfm_arch_free_msp_and_exc_ret(uint32_t exc_return);
+void tfm_arch_init_actx(struct tfm_arch_ctx_t *p_actx,
+                        uint32_t sp, uint32_t sp_limit);
 
 /*
- * This function sets return value on APIs that cause scheduling, for example
- * psa_wait(), by manipulating the control context - this is usaully setting the
- * R0 register of the thread context.
+ * Set secure exceptions priority
  */
-void tfm_arch_set_context_ret_code(void *p_ctx_ctrl, uintptr_t ret_code);
+void tfm_arch_set_secure_exception_priorities(void);
 
-/* Init a thread context on thread stack and update the control context. */
-void tfm_arch_init_context(void *p_ctx_ctrl,
-                           uintptr_t pfn, void *param, uintptr_t pfnlr,
-                           uintptr_t sp_limit, uintptr_t sp);
+/**
+ * \brief Configure coprocessors and hardware re-entrant detection if supported.
+ */
+void tfm_arch_config_extensions(void);
 
 /*
- * Refresh the HW (sp, splimit) according to the given control context and
- * returns the EXC_RETURN payload (caller might need it for following codes).
- *
- * The p_ctx_ctrl must have been initialized by tfm_arch_init_context
+ * Clear float point status.
  */
-uint32_t tfm_arch_refresh_hardware_context(void *p_ctx_ctrl);
+void tfm_arch_clear_fp_status(void);
 
+void tfm_arch_init_context(struct tfm_arch_ctx_t *p_actx,
+                           void *param, uintptr_t pfn,
+                           uintptr_t stk_btm, uintptr_t stk_top);
 #endif
diff --git a/lib/tf-m/secure_fw/spm/include/tfm_arch_v8m.h b/lib/tf-m/secure_fw/spm/include/tfm_arch_v8m.h
index 0c2f519d3..5fbc2b229 100644
--- a/lib/tf-m/secure_fw/spm/include/tfm_arch_v8m.h
+++ b/lib/tf-m/secure_fw/spm/include/tfm_arch_v8m.h
@@ -40,12 +40,37 @@
         EXC_RETURN_STACK_MAIN | EXC_RETURN_RES0 |               \
         EXC_RETURN_EXC_SECURE
 
-/* Exception numbers */
-#define EXC_NUM_THREAD_MODE                     (0)
-#define EXC_NUM_SVCALL                          (11)
-#define EXC_NUM_PENDSV                          (14)
-
-#define VTOR_BASE                       (0xE000ED08)
+#if defined(__ARM_ARCH_8_1M_MAIN__) || defined(__ARM_ARCH_8M_MAIN__)
+struct tfm_arch_ctx_t {
+    uint32_t    r4;
+    uint32_t    r5;
+    uint32_t    r6;
+    uint32_t    r7;
+    uint32_t    r8;
+    uint32_t    r9;
+    uint32_t    r10;
+    uint32_t    r11;
+    uint32_t    sp;
+    uint32_t    sp_limit;
+    uint32_t    dummy;
+    uint32_t    lr;
+};
+#elif defined(__ARM_ARCH_8M_BASE__)
+struct tfm_arch_ctx_t {
+    uint32_t    r8;
+    uint32_t    r9;
+    uint32_t    r10;
+    uint32_t    r11;
+    uint32_t    r4;
+    uint32_t    r5;
+    uint32_t    r6;
+    uint32_t    r7;
+    uint32_t    sp;
+    uint32_t    sp_limit;
+    uint32_t    dummy;
+    uint32_t    lr;
+};
+#endif
 
 /* Disable NS exceptions by setting NS PRIMASK to 1 */
 #define TFM_NS_EXC_DISABLE()    __TZ_set_PRIMASK_NS(1)
@@ -92,16 +117,6 @@ __STATIC_INLINE void tfm_arch_set_psplim(uint32_t psplim)
     __set_PSPLIM(psplim);
 }
 
-/**
- * \brief Set MSP limit value.
- *
- * \param[in] msplim        MSP limit value to be written.
- */
-__STATIC_INLINE void tfm_arch_set_msplim(uint32_t msplim)
-{
-    __set_MSPLIM(msplim);
-}
-
 /**
  * \brief Seal the thread stack.
  *
@@ -111,7 +126,7 @@ __STATIC_INLINE void tfm_arch_set_msplim(uint32_t msplim)
  *
  * \retval stack         Updated thread stack address.
  */
-__STATIC_INLINE uintptr_t arch_seal_thread_stack(uintptr_t stk)
+__STATIC_INLINE uintptr_t tfm_arch_seal_thread_stack(uintptr_t stk)
 {
     TFM_CORE_ASSERT((stk & 0x7) == 0);
     stk -= TFM_STACK_SEALED_SIZE;
@@ -122,6 +137,28 @@ __STATIC_INLINE uintptr_t arch_seal_thread_stack(uintptr_t stk)
     return stk;
 }
 
+/**
+ * \brief Get architecture context value into context struct
+ *
+ * \param[in] p_actx        Pointer of context data
+ */
+__STATIC_INLINE void tfm_arch_get_ctx(struct tfm_arch_ctx_t *p_actx)
+{
+    p_actx->sp = __get_PSP();
+    p_actx->sp_limit = __get_PSPLIM();
+}
+
+/**
+ * \brief Set architecture context value into hardware
+ *
+ * \param[in] p_actx        Pointer of context data
+ */
+__STATIC_INLINE void tfm_arch_set_ctx(struct tfm_arch_ctx_t *p_actx)
+{
+    __set_PSP(p_actx->sp);
+    __set_PSPLIM(p_actx->sp_limit);
+}
+
 /**
  * \brief Set MSPLIM register and seal the MSP.
  *
diff --git a/lib/tf-m/secure_fw/spm/include/tfm_core_trustzone.h b/lib/tf-m/secure_fw/spm/include/tfm_core_trustzone.h
index c0a6f5970..c53e034fe 100644
--- a/lib/tf-m/secure_fw/spm/include/tfm_core_trustzone.h
+++ b/lib/tf-m/secure_fw/spm/include/tfm_core_trustzone.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -8,8 +8,6 @@
 #ifndef __TFM_CORE_TRUSTZONE_H__
 #define __TFM_CORE_TRUSTZONE_H__
 
-#include "security_defs.h"
-
 /* This file holds specification or design defined TrustZone settings. */
 
 /*
@@ -19,7 +17,7 @@
  * 0xFEF5EDA5.
  */
 #define TFM_STACK_SEALED_SIZE           8
-#define TFM_STACK_SEAL_VALUE            STACK_SEAL_PATTERN
+#define TFM_STACK_SEAL_VALUE            0xFEF5EDA5
 
 /*
  * The numbers in 32bit words while basic FP involved in preempted context:
diff --git a/lib/tf-m/secure_fw/spm/include/tfm_spm_log.h b/lib/tf-m/secure_fw/spm/include/tfm_spm_log.h
index 4ad749ea5..33b2ddb40 100644
--- a/lib/tf-m/secure_fw/spm/include/tfm_spm_log.h
+++ b/lib/tf-m/secure_fw/spm/include/tfm_spm_log.h
@@ -36,25 +36,37 @@
 
 #if (TFM_SPM_LOG_LEVEL == TFM_SPM_LOG_LEVEL_DEBUG)
 #define SPMLOG_DBGMSGVAL(msg, val) spm_log_msgval(msg, sizeof(msg), val)
+#if (TFM_SYSTEM_FP >= 1)
+#define SPMLOG_DBGMSGVALF(msg, val) spm_log_msgvalf(msg, sizeof(msg), val)
+#endif
 #define SPMLOG_DBGMSG(msg) tfm_hal_output_spm_log(msg, sizeof(msg))
 #else
 #define SPMLOG_DBGMSGVAL(msg, val)
+#define SPMLOG_DBGMSGVALF(msg, val)
 #define SPMLOG_DBGMSG(msg)
 #endif
 
 #if (TFM_SPM_LOG_LEVEL >= TFM_SPM_LOG_LEVEL_INFO)
 #define SPMLOG_INFMSGVAL(msg, val) spm_log_msgval(msg, sizeof(msg), val)
+#if (TFM_SYSTEM_FP >= 1)
+#define SPMLOG_INFMSGVALF(msg, val) spm_log_msgvalf(msg, sizeof(msg), val)
+#endif
 #define SPMLOG_INFMSG(msg) tfm_hal_output_spm_log(msg, sizeof(msg))
 #else
 #define SPMLOG_INFMSGVAL(msg, val)
+#define SPMLOG_DBGMSGVALF(msg, val)
 #define SPMLOG_INFMSG(msg)
 #endif
 
 #if (TFM_SPM_LOG_LEVEL >= TFM_SPM_LOG_LEVEL_ERROR)
 #define SPMLOG_ERRMSGVAL(msg, val) spm_log_msgval(msg, sizeof(msg), val)
+#if (TFM_SYSTEM_FP >= 1)
+#define SPMLOG_ERRMSGVALF(msg, val) spm_log_msgvalf(msg, sizeof(msg), val)
+#endif
 #define SPMLOG_ERRMSG(msg) tfm_hal_output_spm_log(msg, sizeof(msg))
 #else
 #define SPMLOG_ERRMSGVAL(msg, val)
+#define SPMLOG_DBGMSGVALF(msg, val)
 #define SPMLOG_ERRMSG(msg)
 #endif
 
@@ -71,4 +83,19 @@
  */
 int32_t spm_log_msgval(const char *msg, size_t len, uint32_t value);
 
+#if (TFM_SYSTEM_FP >= 1)
+/**
+ * \brief SPM output API to print floating point number and call the HAL API
+ *        tfm_hal_output_spm_log.
+ *
+ * \param[in]  msg    A string message
+ * \param[in]  len    The length of the message
+ * \param[in]  value  A floating point value need to be output
+ *
+ * \retval >=0        Number of chars output.
+ * \retval <0         TFM HAL error code.
+ */
+int32_t spm_log_msgvalf(const char *msg, size_t len, double value);
+#endif
+
 #endif /* __TFM_SPM_LOG_H__ */
diff --git a/tf-m.old/secure_fw/spm/include/tfm_version.h b/lib/tf-m/secure_fw/spm/include/tfm_version.h
new file mode 100644
index 000000000..8e2466550
--- /dev/null
+++ b/lib/tf-m/secure_fw/spm/include/tfm_version.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2020-2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#ifndef __TFM_VERSION_H__
+#define __TFM_VERSION_H__
+
+/*
+ * Defines for TFM version.
+ */
+#define VERSION_MAJOR    1
+#define VERSION_MINOR    3
+#define VERSION_HOTFIX   0
+#define VERSION_STRING   ""
+
+#define VERSTR(x)      #x
+#define VERCON(major, minor, hotfix) VERSTR(major)"."VERSTR(minor)"."VERSTR(hotfix)
+
+#define VERSION_FULLSTR VERCON(VERSION_MAJOR, VERSION_MINOR, VERSION_HOTFIX)""VERSION_STRING
+
+
+
+#endif /* __TFM_VERSION_H__ */
diff --git a/lib/tf-m/secure_fw/spm/include/utilities.h b/lib/tf-m/secure_fw/spm/include/utilities.h
index aec3ea078..f52707140 100644
--- a/lib/tf-m/secure_fw/spm/include/utilities.h
+++ b/lib/tf-m/secure_fw/spm/include/utilities.h
@@ -37,8 +37,4 @@ void tfm_core_panic(void);
 /* FixMe: Replace ERROR_MSG() in platform code with a suitable API */
 #define ERROR_MSG(msg) SPMLOG_ERRMSG(msg "\r\n")
 
-/* Preprocessor to reference C MACRO to string in inline asm */
-#define M2S_HELPER(x)  #x
-#define M2S(m)         M2S_HELPER(m)
-
 #endif /* __TFM_UTILS_H__ */
