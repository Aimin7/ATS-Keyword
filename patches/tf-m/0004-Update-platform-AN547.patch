From 1c4e25f4dfa7c5d1d4919c45c8cd790a8737f82d Mon Sep 17 00:00:00 2001
From: Marton Berke <marton.berke@arm.com>
Date: Mon, 2 Aug 2021 14:31:26 +0200
Subject: [PATCH 4/5] Update platform AN547

Update platform files with ethernet PPC fix

Add missing native drivers

Signed-off-by: Marton Berke <marton.berke@arm.com>
Change-Id: I6db460f279e25fcdf52f71fc1af0e8f34a8825b5
---
 .../an547/device/include/device_definition.h  |  141 +++
 .../mps3/an547/device/include/platform_regs.h |    2 +-
 .../an547/device/source/device_definition.c   |  302 ++++-
 .../an547/native_drivers/arm_mps3_io_drv.c    |  146 +++
 .../an547/native_drivers/arm_mps3_io_drv.h    |  111 ++
 .../an547/native_drivers/smsc9220_eth_drv.c   | 1079 +++++++++++++++++
 .../an547/native_drivers/smsc9220_eth_drv.h   |  544 +++++++++
 .../ext/target/arm/mps3/an547/target_cfg.c    |   16 +
 8 files changed, 2339 insertions(+), 2 deletions(-)
 create mode 100644 platform/ext/target/arm/mps3/an547/native_drivers/arm_mps3_io_drv.c
 create mode 100644 platform/ext/target/arm/mps3/an547/native_drivers/arm_mps3_io_drv.h
 create mode 100644 platform/ext/target/arm/mps3/an547/native_drivers/smsc9220_eth_drv.c
 create mode 100644 platform/ext/target/arm/mps3/an547/native_drivers/smsc9220_eth_drv.h

diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/device_definition.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/device_definition.h
index 754f8dd1..58d38b95 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/device_definition.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/device_definition.h
@@ -94,56 +94,111 @@ extern struct uart_cmsdk_dev_t UART5_CMSDK_DEV_NS;
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN0_DEV_S;
 #endif
 
+#ifdef PPC_SSE300_MAIN0_NS
+#include "ppc_sse300_drv.h"
+extern struct ppc_sse300_dev_t PPC_SSE300_MAIN0_DEV_NS;
+#endif
+
 #ifdef PPC_SSE300_MAIN_EXP0_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP0_DEV_S;
 #endif
 
+#ifdef PPC_SSE300_MAIN_EXP0_NS
+#include "ppc_sse300_drv.h"
+extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP0_DEV_NS;
+#endif
+
 #ifdef PPC_SSE300_MAIN_EXP1_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP1_DEV_S;
 #endif
 
+#ifdef PPC_SSE300_MAIN_EXP1_NS
+#include "ppc_sse300_drv.h"
+extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP1_DEV_NS;
+#endif
+
 #ifdef PPC_SSE300_MAIN_EXP2_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP2_DEV_S;
 #endif
 
+#ifdef PPC_SSE300_MAIN_EXP2_NS
+#include "ppc_sse300_drv.h"
+extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP2_DEV_NS;
+#endif
+
 #ifdef PPC_SSE300_MAIN_EXP3_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP3_DEV_S;
 #endif
 
+#ifdef PPC_SSE300_MAIN_EXP3_NS
+#include "ppc_sse300_drv.h"
+extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP3_DEV_NS;
+#endif
+
 #ifdef PPC_SSE300_PERIPH0_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH0_DEV_S;
 #endif
 
+#ifdef PPC_SSE300_PERIPH0_NS
+#include "ppc_sse300_drv.h"
+extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH0_DEV_NS;
+#endif
+
 #ifdef PPC_SSE300_PERIPH1_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH1_DEV_S;
 #endif
 
+#ifdef PPC_SSE300_PERIPH1_NS
+#include "ppc_sse300_drv.h"
+extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH1_DEV_NS;
+#endif
+
 #ifdef PPC_SSE300_PERIPH_EXP0_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP0_DEV_S;
 #endif
 
+#ifdef PPC_SSE300_PERIPH_EXP0_NS
+#include "ppc_sse300_drv.h"
+extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP0_DEV_NS;
+#endif
+
 #ifdef PPC_SSE300_PERIPH_EXP1_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP1_DEV_S;
 #endif
 
+#ifdef PPC_SSE300_PERIPH_EXP1_NS
+#include "ppc_sse300_drv.h"
+extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP1_DEV_NS;
+#endif
+
 #ifdef PPC_SSE300_PERIPH_EXP2_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP2_DEV_S;
 #endif
 
+#ifdef PPC_SSE300_PERIPH_EXP2_NS
+#include "ppc_sse300_drv.h"
+extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP2_DEV_NS;
+#endif
+
 #ifdef PPC_SSE300_PERIPH_EXP3_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP3_DEV_S;
 #endif
 
+#ifdef PPC_SSE300_PERIPH_EXP3_NS
+#include "ppc_sse300_drv.h"
+extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP3_DEV_NS;
+#endif
+
 /* System counters */
 #ifdef SYSCOUNTER_CNTRL_ARMV8_M_S
 #include "syscounter_armv8-m_cntrl_drv.h"
@@ -242,6 +297,92 @@ extern struct arm_mps3_io_dev_t MPS3_IO_DEV_S;
 extern struct arm_mps3_io_dev_t MPS3_IO_DEV_NS;
 #endif
 
+#ifdef SMSC9220_ETH_S
+#include "smsc9220_eth_drv.h"
+extern struct smsc9220_eth_dev_t SMSC9220_ETH_DEV_S;
+#endif
+
+#ifdef SMSC9220_ETH_NS
+#include "smsc9220_eth_drv.h"
+extern struct smsc9220_eth_dev_t SMSC9220_ETH_DEV_NS;
+#endif
+
+/* CMSDK GPIO driver structures */
+#ifdef GPIO0_CMSDK_S
+#include "gpio_cmsdk_drv.h"
+extern struct gpio_cmsdk_dev_t GPIO0_CMSDK_DEV_S;
+#endif
+
+#ifdef GPIO0_CMSDK_NS
+#include "gpio_cmsdk_drv.h"
+extern struct gpio_cmsdk_dev_t GPIO0_CMSDK_DEV_NS;
+#endif
+
+#ifdef GPIO1_CMSDK_S
+#include "gpio_cmsdk_drv.h"
+extern struct gpio_cmsdk_dev_t GPIO1_CMSDK_DEV_S;
+#endif
+
+#ifdef GPIO1_CMSDK_NS
+#include "gpio_cmsdk_drv.h"
+extern struct gpio_cmsdk_dev_t GPIO1_CMSDK_DEV_NS;
+#endif
+
+#ifdef GPIO2_CMSDK_S
+#include "gpio_cmsdk_drv.h"
+extern struct gpio_cmsdk_dev_t GPIO2_CMSDK_DEV_S;
+#endif
+
+#ifdef GPIO2_CMSDK_NS
+#include "gpio_cmsdk_drv.h"
+extern struct gpio_cmsdk_dev_t GPIO2_CMSDK_DEV_NS;
+#endif
+
+#ifdef GPIO3_CMSDK_S
+#include "gpio_cmsdk_drv.h"
+extern struct gpio_cmsdk_dev_t GPIO3_CMSDK_DEV_S;
+#endif
+
+#ifdef GPIO3_CMSDK_NS
+#include "gpio_cmsdk_drv.h"
+extern struct gpio_cmsdk_dev_t GPIO3_CMSDK_DEV_NS;
+#endif
+
+/* I2C_SBCon driver structures */
+#ifdef I2C0_SBCON_S
+#include "timeout.h"
+#include "i2c_sbcon_drv.h"
+extern struct i2c_sbcon_dev_t I2C0_SBCON_DEV_S;
+#endif
+
+#ifdef I2C0_SBCON_NS
+#include "timeout.h"
+#include "i2c_sbcon_drv.h"
+extern struct i2c_sbcon_dev_t I2C0_SBCON_DEV_NS;
+#endif
+
+/* I2S driver structures */
+#ifdef MPS3_I2S_S
+#include "audio_i2s_mps3_drv.h"
+extern struct audio_i2s_mps3_dev_t MPS3_I2S_DEV_S;
+#endif
+
+#ifdef MPS3_I2S_NS
+#include "audio_i2s_mps3_drv.h"
+extern struct audio_i2s_mps3_dev_t MPS3_I2S_DEV_NS;
+#endif
+
+/* TGU driver structure */
+#ifdef TGU_ARMV8_M_ITCM_S
+#include "tgu_armv8_m_drv.h"
+extern struct tgu_armv8_m_dev_t TGU_ARMV8_M_ITCM_DEV_S;
+#endif
+
+#ifdef TGU_ARMV8_M_DTCM_S
+#include "tgu_armv8_m_drv.h"
+extern struct tgu_armv8_m_dev_t TGU_ARMV8_M_DTCM_DEV_S;
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/platform_regs.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/platform_regs.h
index 696d95f3..cc24ec6f 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/platform_regs.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/platform_regs.h
@@ -254,10 +254,10 @@ struct sse300_nsacfg_t {
 #define GPIO1_MAIN_PPCEXP0_POS_MASK             (1UL << 1)
 #define GPIO2_MAIN_PPCEXP0_POS_MASK             (1UL << 2)
 #define GPIO3_MAIN_PPCEXP0_POS_MASK             (1UL << 3)
-#define USB_AND_ETHERNET_MAIN_PPCEXP0_POS_MASK  (1UL << 4)
 #define USER_AHB0_MAIN_PPCEXP0_POS_MASK         (1UL << 5)
 #define USER_AHB1_MAIN_PPCEXP0_POS_MASK         (1UL << 6)
 #define USER_AHB2_MAIN_PPCEXP0_POS_MASK         (1UL << 7)
+#define USB_AND_ETHERNET_MAIN_PPCEXP0_POS_MASK  (1UL << 8)
 /* End MAIN PPCEXP0 peripherals definition */
 
 /* MAIN PPCEXP1 peripherals definition */
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/device_definition.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/device_definition.c
index 4a18c1c8..43186875 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/device_definition.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/device_definition.c
@@ -230,6 +230,18 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN0_DEV_S = {
     &PPC_SSE300_MAIN0_DATA_S };
 #endif
 
+#ifdef PPC_SSE300_MAIN0_NS
+static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN0_CFG_NS = {
+    .nsacfg_base = SSE300_NSACFG_BASE_NS,
+    .ppc_name = PPC_SSE300_MAIN0};
+static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN0_DATA_NS = {
+    .nsacfg_nsp_ppc = 0,
+    .is_initialized = false };
+struct ppc_sse300_dev_t PPC_SSE300_MAIN0_DEV_NS = {
+    &PPC_SSE300_MAIN0_CFG_NS,
+    &PPC_SSE300_MAIN0_DATA_NS };
+#endif
+
 #ifdef PPC_SSE300_MAIN_EXP0_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP0_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -246,6 +258,18 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP0_DEV_S = {
     &PPC_SSE300_MAIN_EXP0_DATA_S };
 #endif
 
+#ifdef PPC_SSE300_MAIN_EXP0_NS
+static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP0_CFG_NS = {
+    .nsacfg_base = SSE300_NSACFG_BASE_NS,
+    .ppc_name = PPC_SSE300_MAIN_EXP0};
+static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN_EXP0_DATA_NS = {
+    .nsacfg_nsp_ppc = 0,
+    .is_initialized = false };
+struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP0_DEV_NS = {
+    &PPC_SSE300_MAIN_EXP0_CFG_NS,
+    &PPC_SSE300_MAIN_EXP0_DATA_NS };
+#endif
+
 #ifdef PPC_SSE300_MAIN_EXP1_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP1_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -262,6 +286,18 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP1_DEV_S = {
     &PPC_SSE300_MAIN_EXP1_DATA_S };
 #endif
 
+#ifdef PPC_SSE300_MAIN_EXP1_NS
+static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP1_CFG_NS = {
+    .nsacfg_base = SSE300_NSACFG_BASE_NS,
+    .ppc_name = PPC_SSE300_MAIN_EXP1};
+static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN_EXP1_DATA_NS = {
+    .nsacfg_nsp_ppc = 0,
+    .is_initialized = false };
+struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP1_DEV_NS = {
+    &PPC_SSE300_MAIN_EXP1_CFG_NS,
+    &PPC_SSE300_MAIN_EXP1_DATA_NS };
+#endif
+
 #ifdef PPC_SSE300_MAIN_EXP2_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP2_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -278,6 +314,18 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP2_DEV_S = {
     &PPC_SSE300_MAIN_EXP2_DATA_S };
 #endif
 
+#ifdef PPC_SSE300_MAIN_EXP2_NS
+static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP2_CFG_NS = {
+    .nsacfg_base = SSE300_NSACFG_BASE_NS,
+    .ppc_name = PPC_SSE300_MAIN_EXP2};
+static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN_EXP2_DATA_NS = {
+    .nsacfg_nsp_ppc = 0,
+    .is_initialized = false };
+struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP2_DEV_NS = {
+    &PPC_SSE300_MAIN_EXP2_CFG_NS,
+    &PPC_SSE300_MAIN_EXP2_DATA_NS };
+#endif
+
 #ifdef PPC_SSE300_MAIN_EXP3_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP3_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -294,6 +342,18 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP3_DEV_S = {
     &PPC_SSE300_MAIN_EXP3_DATA_S };
 #endif
 
+#ifdef PPC_SSE300_MAIN_EXP3_NS
+static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP3_CFG_NS = {
+    .nsacfg_base = SSE300_NSACFG_BASE_NS,
+    .ppc_name = PPC_SSE300_MAIN_EXP3};
+static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN_EXP3_DATA_NS = {
+    .nsacfg_nsp_ppc = 0,
+    .is_initialized = false };
+struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP3_DEV_NS = {
+    &PPC_SSE300_MAIN_EXP3_CFG_NS,
+    &PPC_SSE300_MAIN_EXP3_DATA_NS };
+#endif
+
 #ifdef PPC_SSE300_PERIPH0_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH0_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -310,6 +370,18 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH0_DEV_S = {
     &PPC_SSE300_PERIPH0_DATA_S };
 #endif
 
+#ifdef PPC_SSE300_PERIPH0_NS
+static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH0_CFG_NS = {
+    .nsacfg_base = SSE300_NSACFG_BASE_NS,
+    .ppc_name = PPC_SSE300_PERIPH0};
+static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH0_DATA_NS = {
+    .nsacfg_nsp_ppc = 0,
+    .is_initialized = false };
+struct ppc_sse300_dev_t PPC_SSE300_PERIPH0_DEV_NS = {
+    &PPC_SSE300_PERIPH0_CFG_NS,
+    &PPC_SSE300_PERIPH0_DATA_NS };
+#endif
+
 #ifdef PPC_SSE300_PERIPH1_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH1_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -326,6 +398,18 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH1_DEV_S = {
     &PPC_SSE300_PERIPH1_DATA_S };
 #endif
 
+#ifdef PPC_SSE300_PERIPH1_NS
+static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH1_CFG_NS = {
+    .nsacfg_base = SSE300_NSACFG_BASE_NS,
+    .ppc_name = PPC_SSE300_PERIPH1};
+static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH1_DATA_NS = {
+    .nsacfg_nsp_ppc = 0,
+    .is_initialized = false };
+struct ppc_sse300_dev_t PPC_SSE300_PERIPH1_DEV_NS = {
+    &PPC_SSE300_PERIPH1_CFG_NS,
+    &PPC_SSE300_PERIPH1_DATA_NS };
+#endif
+
 #ifdef PPC_SSE300_PERIPH_EXP0_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP0_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -342,6 +426,18 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP0_DEV_S = {
     &PPC_SSE300_PERIPH_EXP0_DATA_S };
 #endif
 
+#ifdef PPC_SSE300_PERIPH_EXP0_NS
+static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP0_CFG_NS = {
+    .nsacfg_base = SSE300_NSACFG_BASE_NS,
+    .ppc_name = PPC_SSE300_PERIPH_EXP0};
+static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH_EXP0_DATA_NS = {
+    .nsacfg_nsp_ppc = 0,
+    .is_initialized = false };
+struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP0_DEV_NS = {
+    &PPC_SSE300_PERIPH_EXP0_CFG_NS,
+    &PPC_SSE300_PERIPH_EXP0_DATA_NS };
+#endif
+
 #ifdef PPC_SSE300_PERIPH_EXP1_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP1_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -358,6 +454,18 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP1_DEV_S = {
     &PPC_SSE300_PERIPH_EXP1_DATA_S };
 #endif
 
+#ifdef PPC_SSE300_PERIPH_EXP1_NS
+static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP1_CFG_NS = {
+    .nsacfg_base = SSE300_NSACFG_BASE_NS,
+    .ppc_name = PPC_SSE300_PERIPH_EXP1};
+static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH_EXP1_DATA_NS = {
+    .nsacfg_nsp_ppc = 0,
+    .is_initialized = false };
+struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP1_DEV_NS = {
+    &PPC_SSE300_PERIPH_EXP1_CFG_NS,
+    &PPC_SSE300_PERIPH_EXP1_DATA_NS };
+#endif
+
 #ifdef PPC_SSE300_PERIPH_EXP2_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP2_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -374,6 +482,18 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP2_DEV_S = {
     &PPC_SSE300_PERIPH_EXP2_DATA_S };
 #endif
 
+#ifdef PPC_SSE300_PERIPH_EXP2_NS
+static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP2_CFG_NS = {
+    .nsacfg_base = SSE300_NSACFG_BASE_NS,
+    .ppc_name = PPC_SSE300_PERIPH_EXP2};
+static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH_EXP2_DATA_NS = {
+    .nsacfg_nsp_ppc = 0,
+    .is_initialized = false };
+struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP2_DEV_NS = {
+    &PPC_SSE300_PERIPH_EXP2_CFG_NS,
+    &PPC_SSE300_PERIPH_EXP2_DATA_NS };
+#endif
+
 #ifdef PPC_SSE300_PERIPH_EXP3_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP3_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -390,6 +510,18 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP3_DEV_S = {
     &PPC_SSE300_PERIPH_EXP3_DATA_S };
 #endif
 
+#ifdef PPC_SSE300_PERIPH_EXP3_NS
+static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP3_CFG_NS = {
+    .nsacfg_base = SSE300_NSACFG_BASE_NS,
+    .ppc_name = PPC_SSE300_PERIPH_EXP3};
+static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH_EXP3_DATA_NS = {
+    .nsacfg_nsp_ppc = 0,
+    .is_initialized = false };
+struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP3_DEV_NS = {
+    &PPC_SSE300_PERIPH_EXP3_CFG_NS,
+    &PPC_SSE300_PERIPH_EXP3_DATA_NS };
+#endif
+
 /* System counters */
 #ifdef SYSCOUNTER_CNTRL_ARMV8_M_S
 
@@ -443,7 +575,7 @@ SYSCOUNTER_READ_ARMV8_M_DEV_CFG_NS = {
     .base = SYSCNTR_READ_BASE_NS,
 };
 struct syscounter_armv8_m_read_dev_t SYSCOUNTER_READ_ARMV8_M_DEV_NS = {
-    &(SYSCOUNTER_CNTRL_ARMV8_M_DEV_CFG_NS),
+    &(SYSCOUNTER_READ_ARMV8_M_DEV_CFG_NS),
 };
 #endif
 
@@ -675,3 +807,171 @@ struct arm_mps3_io_dev_t MPS3_IO_DEV_NS = {
     .cfg = &(MPS3_IO_DEV_CFG_NS)
 };
 #endif
+
+#ifdef SMSC9220_ETH_S
+static struct smsc9220_eth_dev_cfg_t SMSC9220_ETH_DEV_CFG_S = {
+    .base = ETHERNET_BASE_S
+};
+static struct smsc9220_eth_dev_data_t SMSC9220_ETH_DEV_DATA_S = {
+    .state = 0,
+    .wait_ms = 0,
+    .ongoing_packet_length = 0,
+    .ongoing_packet_length_sent = 0,
+    .current_rx_size_words = 0,
+};
+struct smsc9220_eth_dev_t SMSC9220_ETH_DEV_S = {
+    .cfg = &(SMSC9220_ETH_DEV_CFG_S),
+    .data = &(SMSC9220_ETH_DEV_DATA_S),
+};
+#endif
+
+#ifdef SMSC9220_ETH_NS
+static struct smsc9220_eth_dev_cfg_t SMSC9220_ETH_DEV_CFG_NS = {
+    .base = ETHERNET_BASE_NS
+};
+static struct smsc9220_eth_dev_data_t SMSC9220_ETH_DEV_DATA_NS = {
+    .state = 0,
+    .wait_ms = 0,
+    .ongoing_packet_length = 0,
+    .ongoing_packet_length_sent = 0,
+    .current_rx_size_words = 0,
+};
+struct smsc9220_eth_dev_t SMSC9220_ETH_DEV_NS = {
+    .cfg = &(SMSC9220_ETH_DEV_CFG_NS),
+    .data = &(SMSC9220_ETH_DEV_DATA_NS),
+};
+#endif
+
+/* CMSDK GPIO driver structures */
+#ifdef GPIO0_CMSDK_S
+static const struct gpio_cmsdk_dev_cfg_t GPIO0_CMSDK_DEV_CFG_S = {
+    .base = GPIO0_CMSDK_BASE_S};
+struct gpio_cmsdk_dev_t GPIO0_CMSDK_DEV_S = {&(GPIO0_CMSDK_DEV_CFG_S)};
+#endif
+
+#ifdef GPIO0_CMSDK_NS
+static const struct gpio_cmsdk_dev_cfg_t GPIO0_CMSDK_DEV_CFG_NS = {
+    .base = GPIO0_CMSDK_BASE_NS};
+struct gpio_cmsdk_dev_t GPIO0_CMSDK_DEV_NS = {&(GPIO0_CMSDK_DEV_CFG_NS)};
+#endif
+
+#ifdef GPIO1_CMSDK_S
+static const struct gpio_cmsdk_dev_cfg_t GPIO1_CMSDK_DEV_CFG_S = {
+    .base = GPIO1_CMSDK_BASE_S};
+struct gpio_cmsdk_dev_t GPIO1_CMSDK_DEV_S = {&(GPIO1_CMSDK_DEV_CFG_S)};
+#endif
+
+#ifdef GPIO1_CMSDK_NS
+static const struct gpio_cmsdk_dev_cfg_t GPIO1_CMSDK_DEV_CFG_NS = {
+    .base = GPIO1_CMSDK_BASE_NS};
+struct gpio_cmsdk_dev_t GPIO1_CMSDK_DEV_NS = {&(GPIO1_CMSDK_DEV_CFG_NS)};
+#endif
+
+#ifdef GPIO2_CMSDK_S
+static const struct gpio_cmsdk_dev_cfg_t GPIO2_CMSDK_DEV_CFG_S = {
+    .base = GPIO2_CMSDK_BASE_S};
+struct gpio_cmsdk_dev_t GPIO2_CMSDK_DEV_S = {&(GPIO2_CMSDK_DEV_CFG_S)};
+#endif
+
+#ifdef GPIO2_CMSDK_NS
+static const struct gpio_cmsdk_dev_cfg_t GPIO2_CMSDK_DEV_CFG_NS = {
+    .base = GPIO2_CMSDK_BASE_NS};
+struct gpio_cmsdk_dev_t GPIO2_CMSDK_DEV_NS = {&(GPIO2_CMSDK_DEV_CFG_NS)};
+#endif
+
+#ifdef GPIO3_CMSDK_S
+static const struct gpio_cmsdk_dev_cfg_t GPIO3_CMSDK_DEV_CFG_S = {
+    .base = GPIO3_CMSDK_BASE_S};
+struct gpio_cmsdk_dev_t GPIO3_CMSDK_DEV_S = {&(GPIO3_CMSDK_DEV_CFG_S)};
+#endif
+
+#ifdef GPIO3_CMSDK_NS
+static const struct gpio_cmsdk_dev_cfg_t GPIO3_CMSDK_DEV_CFG_NS = {
+    .base = GPIO3_CMSDK_BASE_NS};
+struct gpio_cmsdk_dev_t GPIO3_CMSDK_DEV_NS = {&(GPIO3_CMSDK_DEV_CFG_NS)};
+#endif
+
+/* I2C_SBCon driver structures */
+#ifdef I2C0_SBCON_S
+static struct i2c_sbcon_dev_cfg_t I2C0_SBCON_DEV_CFG_S = {
+    .base = FPGA_SBCon_I2C_AUDIO_BASE_S,
+    .default_freq_hz = 100000,
+    .sleep_us = &wait_us
+};
+static struct i2c_sbcon_dev_data_t I2C0_SBCON_DEV_DATA_S ={
+    .freq_us = 0,
+    .sys_clk = 0,
+    .state = 0
+};
+struct i2c_sbcon_dev_t I2C0_SBCON_DEV_S = {
+    .cfg = &(I2C0_SBCON_DEV_CFG_S),
+    .data = &(I2C0_SBCON_DEV_DATA_S)
+};
+#endif
+
+#ifdef I2C0_SBCON_NS
+static struct i2c_sbcon_dev_cfg_t I2C0_SBCON_DEV_CFG_NS = {
+    .base = FPGA_SBCon_I2C_AUDIO_BASE_NS,
+    .default_freq_hz = 100000,
+    .sleep_us = &wait_us
+};
+static struct i2c_sbcon_dev_data_t I2C0_SBCON_DEV_DATA_NS ={
+    .freq_us = 0,
+    .sys_clk = 0,
+    .state = 0
+};
+struct i2c_sbcon_dev_t I2C0_SBCON_DEV_NS = {
+    .cfg = &(I2C0_SBCON_DEV_CFG_NS),
+    .data = &(I2C0_SBCON_DEV_DATA_NS)
+};
+#endif
+
+/* I2S driver structures */
+#ifdef MPS3_I2S_S
+static const struct audio_i2s_mps3_dev_cfg_t MPS3_I2S_DEV_CFG_S = {
+    .base = FPGA_I2S_BASE_S
+};
+struct audio_i2s_mps3_dev_t MPS3_I2S_DEV_S = {
+    &(MPS3_I2S_DEV_CFG_S),
+};
+#endif
+
+#ifdef MPS3_I2S_NS
+static const struct audio_i2s_mps3_dev_cfg_t MPS3_I2S_DEV_CFG_NS = {
+    .base = FPGA_I2S_BASE_NS
+};
+struct audio_i2s_mps3_dev_t MPS3_I2S_DEV_NS = {
+    &(MPS3_I2S_DEV_CFG_NS),
+};
+#endif
+
+/* TGU driver structures */
+#ifdef TGU_ARMV8_M_ITCM_S
+static const struct tgu_armv8_m_dev_cfg_t TGU_ARMV8_M_ITCM_DEV_CFG_S = {
+    .base = ITGU_CTRL_BASE
+};
+static struct tgu_armv8_m_dev_data_t TGU_ARMV8_M_ITCM_DEV_DATA_S = {
+    .range_list = 0,
+    .nbr_of_ranges = 0,
+    .is_initialized = false
+};
+struct tgu_armv8_m_dev_t TGU_ARMV8_M_ITCM_DEV_S = {
+&(TGU_ARMV8_M_ITCM_DEV_CFG_S),
+&(TGU_ARMV8_M_ITCM_DEV_DATA_S),
+};
+#endif
+
+#ifdef TGU_ARMV8_M_DTCM_S
+static const struct tgu_armv8_m_dev_cfg_t TGU_ARMV8_M_DTCM_DEV_CFG_S = {
+    .base = DTGU_CTRL_BASE
+};
+static struct tgu_armv8_m_dev_data_t TGU_ARMV8_M_DTCM_DEV_DATA_S = {
+    .range_list = 0,
+    .nbr_of_ranges = 0,
+    .is_initialized = false,
+};
+struct tgu_armv8_m_dev_t TGU_ARMV8_M_DTCM_DEV_S = {
+&(TGU_ARMV8_M_DTCM_DEV_CFG_S),
+&(TGU_ARMV8_M_DTCM_DEV_DATA_S),
+};
+#endif
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/arm_mps3_io_drv.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/arm_mps3_io_drv.c
new file mode 100644
index 00000000..828b90a6
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/arm_mps3_io_drv.c
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2018 ARM Limited
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "arm_mps3_io_drv.h"
+
+/* There is at most 10 LEDs 8 switches and 2 buttons on MPS3 FPGA IO */
+#define MAX_PIN_FPGAIO_LED         10UL
+#define MAX_PIN_FPGAIO_BUTTON      2UL
+#define MAX_PIN_FPGAIO_SWITCH      8UL
+
+/* Mask to 1 the first X bits */
+#define MASK(X)            ((1UL << (X)) - 1)
+
+/* MPS3 IO register map structure */
+struct arm_mps3_io_reg_map_t {
+    volatile uint32_t fpgaio_leds;      /* Offset: 0x000 (R/W) LED connections
+                                         *         [31:10] : Reserved
+                                         *         [9:0]  : FPGAIO LEDs */
+    volatile uint32_t reserved[1];
+    volatile uint32_t fpgaio_buttons;   /* Offset: 0x008 (R/ ) Buttons
+                                         *         [31:2] : Reserved
+                                         *         [1:0]  : Buttons */
+    volatile uint32_t reserved2[7];
+    volatile uint32_t fpgaio_switches;  /* Offset: 0x028 (R/ ) Denotes the
+                                         *                  state of the FPGAIO
+                                         *                  user switches
+                                         *         [31:8] : Reserved
+                                         *         [7:0]  : FPGAIO switches */
+};
+
+void arm_mps3_io_write_leds(struct arm_mps3_io_dev_t* dev,
+                            enum arm_mps3_io_access_t access,
+                            uint8_t pin_num,
+                            uint32_t value)
+{
+    struct arm_mps3_io_reg_map_t* p_mps3_io_port =
+                                  (struct arm_mps3_io_reg_map_t*)dev->cfg->base;
+    /* Mask of involved bits */
+    uint32_t write_mask = 0;
+
+    if (pin_num >= MAX_PIN_FPGAIO_LED) {
+        return;
+    }
+
+    switch (access) {
+    case ARM_MPS3_IO_ACCESS_PIN:
+        write_mask = (1UL << pin_num);
+        break;
+    case ARM_MPS3_IO_ACCESS_PORT:
+        write_mask = MASK(MAX_PIN_FPGAIO_LED);
+        break;
+    /*
+     * default: explicitely not used to force to cover all enumeration
+     * cases
+     */
+    }
+
+    if (value) {
+        p_mps3_io_port->fpgaio_leds |= write_mask;
+    } else {
+        p_mps3_io_port->fpgaio_leds &= ~write_mask;
+    }
+
+}
+
+uint32_t arm_mps3_io_read_buttons(struct arm_mps3_io_dev_t* dev,
+                                  enum arm_mps3_io_access_t access,
+                                  uint8_t pin_num)
+{
+    struct arm_mps3_io_reg_map_t* p_mps3_io_port =
+                                  (struct arm_mps3_io_reg_map_t*)dev->cfg->base;
+    uint32_t value = 0;
+
+    if (pin_num >= MAX_PIN_FPGAIO_BUTTON) {
+        return 0;
+    }
+
+    /* Only read significant bits from this register */
+    value = p_mps3_io_port->fpgaio_buttons &
+            MASK(MAX_PIN_FPGAIO_BUTTON);
+
+    if (access == ARM_MPS3_IO_ACCESS_PIN) {
+        value = ((value >> pin_num) & 1UL);
+    }
+
+    return value;
+}
+
+uint32_t arm_mps3_io_read_switches(struct arm_mps3_io_dev_t* dev,
+                                  enum arm_mps3_io_access_t access,
+                                  uint8_t pin_num)
+{
+    struct arm_mps3_io_reg_map_t* p_mps3_io_port =
+                                  (struct arm_mps3_io_reg_map_t*)dev->cfg->base;
+    uint32_t value = 0;
+
+    if (pin_num >= MAX_PIN_FPGAIO_SWITCH) {
+        return 0;
+    }
+
+    /* Only read significant bits from this register */
+    value = p_mps3_io_port->fpgaio_switches &
+            MASK(MAX_PIN_FPGAIO_SWITCH);
+
+
+    if (access == ARM_MPS3_IO_ACCESS_PIN) {
+        value = ((value >> pin_num) & 1UL);
+    }
+
+    return value;
+}
+
+uint32_t arm_mps3_io_read_leds(struct arm_mps3_io_dev_t* dev,
+                               enum arm_mps3_io_access_t access,
+                               uint8_t pin_num)
+{
+    struct arm_mps3_io_reg_map_t* p_mps3_io_port =
+                                  (struct arm_mps3_io_reg_map_t*)dev->cfg->base;
+    uint32_t value = 0;
+
+    if (pin_num >= MAX_PIN_FPGAIO_LED) {
+        return 0;
+    }
+
+    /* Only read significant bits from this register */
+    value = p_mps3_io_port->fpgaio_leds & MASK(MAX_PIN_FPGAIO_LED);
+
+    if (access == ARM_MPS3_IO_ACCESS_PIN) {
+        value = ((value >> pin_num) & 1UL);
+    }
+
+    return value;
+}
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/arm_mps3_io_drv.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/arm_mps3_io_drv.h
new file mode 100644
index 00000000..c3c4bb84
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/arm_mps3_io_drv.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2018 ARM Limited
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * \file arm_mps3_io_drv.h
+ * \brief Generic driver for ARM MPS3 FPGAIO.
+ */
+
+#ifndef __ARM_MPS3_IO_DRV_H__
+#define __ARM_MPS3_IO_DRV_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ARM MPS3 IO enumeration types */
+enum arm_mps3_io_access_t {
+    ARM_MPS3_IO_ACCESS_PIN = 0,  /*!< Pin access to MPS3 IO */
+    ARM_MPS3_IO_ACCESS_PORT      /*!< Port access to MPS3 IO */
+};
+
+/* ARM MPS3 IO device configuration structure */
+struct arm_mps3_io_dev_cfg_t {
+    const uint32_t base;                 /*!< MPS3 IO base address */
+};
+
+/* ARM MPS3 IO device structure */
+struct arm_mps3_io_dev_t {
+    const struct arm_mps3_io_dev_cfg_t* const cfg; /*!< MPS3 IO configuration */
+};
+
+/**
+ * \brief  Writes to output LEDs.
+ *
+ * \param[in] dev      MPS3 IO device where to write \ref arm_mps3_io_dev_t
+ * \param[in] access   Access type \ref arm_mps3_io_access_t
+ * \param[in] pin_num  Pin number.
+ * \param[in] value    Value(s) to set.
+ *
+ * \note This function doesn't check if dev is NULL.
+ */
+void arm_mps3_io_write_leds(struct arm_mps3_io_dev_t* dev,
+                            enum arm_mps3_io_access_t access,
+                            uint8_t pin_num,
+                            uint32_t value);
+
+/**
+ * \brief Reads the buttons status.
+ *
+ * \param[in] dev      MPS3 IO device where to read \ref arm_mps3_io_dev_t
+ * \param[in] access   Access type \ref arm_mps3_io_access_t
+ * \param[in] pin_num  Pin number.
+ *
+ * \return Returns bit value for Pin access or port value for port access.
+ *
+ * \note This function doesn't check if dev is NULL.
+ */
+uint32_t arm_mps3_io_read_buttons(struct arm_mps3_io_dev_t* dev,
+                                  enum arm_mps3_io_access_t access,
+                                  uint8_t pin_num);
+
+/**
+ * \brief Reads the switches status.
+ *
+ * \param[in] dev      MPS3 IO device where to read \ref arm_mps3_io_dev_t
+ * \param[in] access   Access type \ref arm_mps3_io_access_t
+ * \param[in] pin_num  Pin number.
+ *
+ * \return Returns bit value for Pin access or port value for port access.
+ *
+ * \note This function doesn't check if dev is NULL.
+ */
+ uint32_t arm_mps3_io_read_switches(struct arm_mps3_io_dev_t* dev,
+                                      enum arm_mps3_io_access_t access,
+                                      uint8_t pin_num);
+
+/**
+ * \brief Reads the LED status.
+ *
+ * \param[in] dev      MPS3 IO device where to read \ref arm_mps3_io_dev_t
+ * \param[in] access   Access type \ref arm_mps3_io_access_t
+ * \param[in] pin_num  Pin number.
+ *
+ * \return Returns bit value for Pin access or port value for port access.
+ *
+ * \note This function doesn't check if dev is NULL.
+ */
+uint32_t arm_mps3_io_read_leds(struct arm_mps3_io_dev_t* dev,
+                               enum arm_mps3_io_access_t access,
+                               uint8_t pin_num);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ARM_MPS3_IO_DRV_H__ */
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/smsc9220_eth_drv.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/smsc9220_eth_drv.c
new file mode 100644
index 00000000..5c929a74
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/smsc9220_eth_drv.c
@@ -0,0 +1,1079 @@
+/*
+ * Copyright (c) 2016-2019 Arm Limited
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "cmsis.h"
+#include "smsc9220_eth_drv.h"
+
+/** Setter bit manipulation macro */
+#define SET_BIT(WORD, BIT_INDEX) ((WORD) |= (1U << (BIT_INDEX)))
+/** Clearing bit manipulation macro */
+#define CLR_BIT(WORD, BIT_INDEX) ((WORD) &= ~(1U << (BIT_INDEX)))
+/** Getter bit manipulation macro */
+#define GET_BIT(WORD, BIT_INDEX) (bool)(((WORD) & (1U << (BIT_INDEX))))
+
+/** Setter bit-field manipulation macro */
+#define SET_BIT_FIELD(WORD, BIT_MASK, BIT_OFFSET, VALUE) \
+            (WORD |= ((VALUE & BIT_MASK) << BIT_OFFSET))
+
+/** Clearing bit-field manipulation macro */
+#define CLR_BIT_FIELD(WORD, BIT_MASK, BIT_OFFSET, VALUE) \
+            (WORD &= ~((VALUE & BIT_MASK) << BIT_OFFSET))
+
+/** Getter bit-field manipulation macro */
+#define GET_BIT_FIELD(WORD, BIT_MASK, BIT_OFFSET) \
+            ((WORD >> BIT_OFFSET) & BIT_MASK)
+
+/** Millisec timeout macros */
+#define RESET_TIME_OUT_MS        10U
+#define REG_WRITE_TIME_OUT_MS    50U
+#define PHY_RESET_TIME_OUT_MS    100U
+#define INIT_FINISH_DELAY        2000U
+
+struct smsc9220_eth_reg_map_t {
+__I  uint32_t rx_data_port;      /**< Receive FIFO Ports (offset 0x0) */
+     uint32_t reserved1[0x7];
+__O  uint32_t tx_data_port;      /**< Transmit FIFO Ports (offset 0x20) */
+     uint32_t reserved2[0x7];
+
+__I  uint32_t rx_status_port;   /**< Receive FIFO status port (offset 0x40) */
+__I  uint32_t rx_status_peek;   /**< Receive FIFO status peek (offset 0x44) */
+__I  uint32_t tx_status_port;   /**< Transmit FIFO status port (offset 0x48) */
+__I  uint32_t tx_status_peek;   /**< Transmit FIFO status peek (offset 0x4C) */
+
+__I  uint32_t id_revision;      /**< Chip ID and Revision (offset 0x50) */
+__IO uint32_t irq_cfg;          /**< Main Interrupt Config (offset 0x54) */
+__IO uint32_t irq_status;       /**< Interrupt Status (offset 0x58) */
+__IO uint32_t irq_enable;       /**< Interrupt Enable Register (offset 0x5C) */
+     uint32_t reserved3;        /**< Reserved for future use (offset 0x60) */
+__I  uint32_t byte_test;        /**< Byte order test 87654321h (offset 0x64) */
+__IO uint32_t fifo_level_irq;   /**< FIFO Level Interrupts (offset 0x68) */
+__IO uint32_t rx_cfg;           /**< Receive Configuration (offset 0x6C) */
+__IO uint32_t tx_cfg;           /**< Transmit Configuration (offset 0x70) */
+__IO uint32_t hw_cfg;           /**< Hardware Configuration (offset 0x74) */
+__IO uint32_t rx_datapath_ctrl; /**< RX Datapath Control (offset 0x78) */
+__I  uint32_t rx_fifo_inf;      /**< Receive FIFO Information (offset 0x7C) */
+__I  uint32_t tx_fifo_inf;      /**< Transmit FIFO Information (offset 0x80) */
+__IO uint32_t pmt_ctrl;         /**< Power Management Control (offset 0x84) */
+__IO uint32_t gpio_cfg;         /**< GPIO Configuration (offset 0x88) */
+__IO uint32_t gptimer_cfg;      /**< GP Timer Configuration (offset 0x8C) */
+__I  uint32_t gptimer_count;    /**< GP Timer Count (offset 0x90) */
+     uint32_t reserved4;        /**< Reserved for future use (offset 0x94) */
+__IO uint32_t word_swap;        /**< WORD SWAP Register (offset 0x98) */
+__I  uint32_t free_run_counter; /**< Free Run Counter (offset 0x9C) */
+__I  uint32_t rx_dropped_frames;/**< RX Dropped Frames Counter (offset 0xA0) */
+__IO uint32_t mac_csr_cmd;      /**< MAC CSR Synchronizer Cmd (offset 0xA4) */
+__IO uint32_t mac_csr_data;     /**< MAC CSR Synchronizer Data (offset 0xA8) */
+__IO uint32_t afc_cfg;          /**< AutomaticFlow Ctrl Config (offset 0xAC) */
+__IO uint32_t eeprom_cmd;       /**< EEPROM Command (offset 0xB0) */
+__IO uint32_t eeprom_data;      /**< EEPROM Data (offset 0xB4) */
+};
+
+/**
+ * \brief TX FIFO Size definitions
+ *
+ */
+#define TX_STATUS_FIFO_SIZE_BYTES       512U /*< fixed allocation in bytes */
+#define TX_DATA_FIFO_SIZE_KBYTES_POS    16U
+#define TX_DATA_FIFO_SIZE_KBYTES_MASK   0x0FU
+#define KBYTES_TO_BYTES_MULTIPLIER      1024U
+
+/**
+ * \brief FIFO Info definitions
+ *
+ */
+#define FIFO_USED_SPACE_MASK         0xFFFFU
+#define DATA_FIFO_USED_SPACE_POS     0U
+#define STATUS_FIFO_USED_SPACE_POS   16U
+
+/**
+ * \brief MAC CSR Synchronizer Command bit definitions
+ *
+ */
+enum mac_csr_cmd_bits_t{
+    MAC_CSR_CMD_RW_INDEX = 30U,
+    MAC_CSR_CMD_BUSY_INDEX = 31U,
+};
+
+#define MAC_CSR_CMD_ADDRESS_MASK    0x0FU
+
+/**
+ * \brief MAC Control register bit definitions
+ *
+ */
+enum mac_reg_cr_bits_t{
+    MAC_REG_CR_RXEN_INDEX = 2U,
+    MAC_REG_CR_TXEN_INDEX = 3U
+};
+
+/**
+ * \brief MII Access register bit definitions
+ *
+ */
+enum mac_reg_mii_acc_bits_t{
+    MAC_REG_MII_ACC_BUSY_INDEX = 0U,
+    MAC_REG_MII_ACC_WRITE_INDEX = 1U,
+    MAC_REG_MII_ACC_PHYADDR_INDEX = 11U
+};
+#define MAC_REG_MII_ACC_MII_REG_MASK    0x1FU
+#define MAC_REG_MII_ACC_MII_REG_OFFSET  6U
+
+/**
+ * \brief Hardware config register bit definitions
+ *
+ */
+enum hw_cfg_reg_bits_t{
+    HW_CFG_REG_SRST_INDEX = 0U,
+    HW_CFG_REG_SRST_TIMEOUT_INDEX = 1U,
+    HW_CFG_REG_MUST_BE_ONE_INDEX = 20U,
+};
+#define HW_CFG_REG_TX_FIFO_SIZE_POS     16U
+#define HW_CFG_REG_TX_FIFO_SIZE_MIN     2U  /*< Min Tx fifo size in KB */
+#define HW_CFG_REG_TX_FIFO_SIZE_MAX     14U /*< Max Tx fifo size in KB */
+#define HW_CFG_REG_TX_FIFO_SIZE         5U  /*< Tx fifo size in KB */
+
+/**
+ * \brief EEPROM command register bit definitions
+ *
+ */
+enum eeprom_cmd_reg_bits_t{
+    EEPROM_CMD_REG_BUSY_INDEX = 31U,
+};
+
+/**
+ * \brief PHY Basic Control register bit definitions
+ *
+ */
+enum phy_reg_bctrl_reg_bits_t{
+    PHY_REG_BCTRL_RST_AUTO_NEG_INDEX = 9U,
+    PHY_REG_BCTRL_AUTO_NEG_EN_INDEX = 12U,
+    PHY_REG_BCTRL_RESET_INDEX = 15U
+};
+
+/**
+ * \brief TX Command A bit definitions
+ *
+ */
+#define TX_CMD_DATA_START_OFFSET_BYTES_POS   16U
+#define TX_CMD_DATA_START_OFFSET_BYTES_MASK  0x1FU
+
+
+enum tx_command_a_bits_t{
+    TX_COMMAND_A_LAST_SEGMENT_INDEX = 12U,
+    TX_COMMAND_A_FIRST_SEGMENT_INDEX = 13U
+};
+
+#define TX_CMD_PKT_LEN_BYTES_MASK  0x7FFU
+#define TX_CMD_PKT_TAG_MASK        0xFFFFU
+#define TX_CMD_PKT_TAG_POS         16U
+
+
+/**
+ * \brief RX Fifo Status bit definitions
+ *
+ */
+enum rx_fifo_status_bits_t{
+    RX_FIFO_STATUS_CRC_ERROR_INDEX       = 1U,
+    RX_FIFO_STATUS_DRIBBLING_BIT_INDEX   = 2U,
+    RX_FIFO_STATUS_MII_ERROR_INDEX       = 3U,
+    RX_FIFO_STATUS_REC_WD_TIMEOUT_INDEX  = 4U,
+    RX_FIFO_STATUS_FRAME_TYPE_INDEX      = 5U,
+    RX_FIFO_STATUS_COLLISION_SEEN_INDEX  = 6U,
+    RX_FIFO_STATUS_FRAME_TOO_LONG_INDEX  = 7U,
+    RX_FIFO_STATUS_MULTICAST_INDEX       = 10U,
+    RX_FIFO_STATUS_RUNT_FRAME_INDEX      = 11U,
+    RX_FIFO_STATUS_LENGTH_ERROR_INDEX    = 12U,
+    RX_FIFO_STATUS_BROADCAST_FRAME_INDEX = 13U,
+    RX_FIFO_STATUS_ERROR_INDEX           = 15U,
+    RX_FIFO_STATUS_FILTERING_FAIL_INDEX  = 30U,
+};
+#define RX_FIFO_STATUS_PKT_LENGTH_POS    16U
+#define RX_FIFO_STATUS_PKT_LENGTH_MASK   0x3FFFU
+
+/**
+ * \brief Interrupt Configuration register bit definitions
+ *
+ */
+enum irq_cfg_bits_t{
+    IRQ_CFG_IRQ_EN_INDEX = 8U
+};
+
+#define IRQ_CFG_INT_DEAS_MASK   0xFFU
+#define IRQ_CFG_INT_DEAS_POS    24U
+#define IRQ_CFG_INT_DEAS_10US   0x22U
+
+/**
+ * \brief Automatic Flow Control register bit definitions
+ *
+ */
+enum afc_bits_t{
+    AFC_ANY_INDEX = 0U,
+    AFC_ADDR_INDEX = 1U,
+    AFC_BROADCAST_INDEX = 2U,
+    AFC_MULTICAST_INDEX = 3U
+};
+
+#define AFC_BACK_DUR_MASK    0x0FU
+#define AFC_BACK_DUR_POS     4U
+#define AFC_BACK_DUR         4U  /**< equal to 50us */
+
+#define AFC_LOW_LEVEL_MASK   0xFFU
+#define AFC_LOW_LEVEL_POS    8U
+#define AFC_LOW_LEVEL        55U  /**< specifies in multiple of 64 bytes */
+
+#define AFC_HIGH_LEVEL_MASK  0xFFU
+#define AFC_HIGH_LEVEL_POS   16U
+#define AFC_HIGH_LEVEL       110U  /**< specifies in multiple of 64 bytes */
+
+/**
+ * \brief Auto-Negotiation Advertisement register bit definitions
+ *
+ */
+enum aneg_bits_t{
+    ANEG_10_BASE_T_INDEX             = 5U, /**< 10Mbps able */
+    ANEG_10_BASE_T_FULL_DUPL_INDEX   = 6U, /**< 10Mbps with full duplex */
+    ANEG_100_BASE_TX_INDEX           = 7U, /**< 100Mbps Tx able */
+    ANEG_100_BASE_TX_FULL_DUPL_INDEX = 8U, /**< 100Mbps with full duplex */
+    ANEG_SYMM_PAUSE_INDEX            = 10U, /**< Symmetric Pause */
+    ANEG_ASYMM_PAUSE_INDEX           = 11U /**< Asymmetric Pause */
+};
+
+/**
+ * \brief Transmit Configuration register bit definitions
+ *
+ */
+enum tx_cfg_bits_t{
+    TX_CFG_STOP_INDEX = 0U,      /*< stop */
+    TX_CFG_ON_INDEX = 1U,        /*< on */
+    TX_CFG_AO_INDEX = 2U,        /*< allow overrun */
+    TX_CFG_TXD_DUMP_INDEX = 14U, /*< Data FIFO dump */
+    TX_CFG_TXS_DUMP_INDEX = 15U  /*< Status FIFO dump */
+};
+
+/**
+ * \brief Chip ID definitions
+ *
+ */
+#define CHIP_ID         0x9220U
+#define CHIP_ID_MASK    0xFFFFU
+#define CHIP_ID_POS     16U
+
+/**
+ * \brief GPIO Configuration register bit definitions
+ *
+ */
+enum gpio_cfg_bits_t{
+    GPIO_CFG_GPIO0_PUSHPULL_INDEX = 16U, /*< GPIO0 push/pull or open-drain */
+    GPIO_CFG_GPIO1_PUSHPULL_INDEX = 17U, /*< GPIO1 push/pull or open-drain */
+    GPIO_CFG_GPIO2_PUSHPULL_INDEX = 18U, /*< GPIO2 push/pull or open-drain */
+    GPIO_CFG_GPIO0_LED_INDEX = 28U,      /*< GPIO0 set to LED1 */
+    GPIO_CFG_GPIO1_LED_INDEX = 29U,      /*< GPIO1 set to LED2 */
+    GPIO_CFG_GPIO2_LED_INDEX = 30U       /*< GPIO2 set to LED3 */
+};
+
+
+static void fill_tx_fifo(const struct smsc9220_eth_dev_t* dev,
+                               uint8_t *data, uint32_t size_bytes)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    uint32_t tx_data_port_tmp = 0;
+    uint8_t *tx_data_port_tmp_ptr = (uint8_t *)&tx_data_port_tmp;
+
+    /*If the data length is not a multiple of 4, then the beginning of the first
+     * DWORD of the TX DATA FIFO gets filled up with zeros and a byte offset is
+     * set accordingly to guarantee proper transmission.*/
+    uint32_t remainder_bytes = (size_bytes % 4);
+    uint32_t filler_bytes = (4 - remainder_bytes);
+    for(uint32_t i = 0; i < 4; i++){
+        if(i < filler_bytes){
+            tx_data_port_tmp_ptr[i] = 0;
+        } else {
+            tx_data_port_tmp_ptr[i] = data[i-filler_bytes];
+        }
+    }
+    register_map->tx_data_port = tx_data_port_tmp;
+    size_bytes -= remainder_bytes;
+    data += remainder_bytes;
+
+    while (size_bytes > 0) {
+        /* Keep the same endianness in data as in the temp variable */
+        tx_data_port_tmp_ptr[0] = data[0];
+        tx_data_port_tmp_ptr[1] = data[1];
+        tx_data_port_tmp_ptr[2] = data[2];
+        tx_data_port_tmp_ptr[3] = data[3];
+        register_map->tx_data_port = tx_data_port_tmp;
+        data += 4;
+        size_bytes -= 4;
+    }
+}
+
+static void empty_rx_fifo(const struct smsc9220_eth_dev_t* dev,
+                               uint8_t *data, uint32_t size_bytes)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    uint32_t rx_data_port_tmp = 0;
+    uint8_t *rx_data_port_tmp_ptr = (uint8_t *)&rx_data_port_tmp;
+
+    uint32_t remainder_bytes = (size_bytes % 4);
+    size_bytes -= remainder_bytes;
+
+    while (size_bytes > 0) {
+        /* Keep the same endianness in data as in the temp variable */
+        rx_data_port_tmp = register_map->rx_data_port;
+        data[0] = rx_data_port_tmp_ptr[0];
+        data[1] = rx_data_port_tmp_ptr[1];
+        data[2] = rx_data_port_tmp_ptr[2];
+        data[3] = rx_data_port_tmp_ptr[3];
+        data += 4;
+        size_bytes -= 4;
+    }
+
+    rx_data_port_tmp = register_map->rx_data_port;
+    for(uint32_t i = 0; i < remainder_bytes; i++) {
+        data[i] = rx_data_port_tmp_ptr[i];
+    }
+}
+
+enum smsc9220_error_t smsc9220_mac_regread(
+        const struct smsc9220_eth_dev_t* dev,
+        enum smsc9220_mac_reg_offsets_t regoffset,
+        uint32_t *data)
+{
+    volatile uint32_t val;
+    uint32_t maccmd = GET_BIT_FIELD(regoffset,
+                                        MAC_CSR_CMD_ADDRESS_MASK, 0);
+    uint32_t time_out = REG_WRITE_TIME_OUT_MS;
+
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    /* Make sure there's no pending operation */
+    if(!(GET_BIT(register_map->mac_csr_cmd, MAC_CSR_CMD_BUSY_INDEX))) {
+        SET_BIT(maccmd, MAC_CSR_CMD_RW_INDEX);
+        SET_BIT(maccmd, MAC_CSR_CMD_BUSY_INDEX);
+        register_map->mac_csr_cmd = maccmd;    /* Start operation */
+
+        do {
+            val = register_map->byte_test;  /* A no-op read. */
+            (void)val;
+            if (dev->data->wait_ms) {
+                dev->data->wait_ms(1);
+            }
+            time_out--;
+        } while(time_out &&
+                GET_BIT(register_map->mac_csr_cmd,MAC_CSR_CMD_BUSY_INDEX));
+
+        if(!time_out) {
+            return SMSC9220_ERROR_TIMEOUT;
+        }
+        else {
+            *data = register_map->mac_csr_data;
+        }
+    } else {
+        return SMSC9220_ERROR_BUSY;
+    }
+    return SMSC9220_ERROR_NONE;
+}
+
+enum smsc9220_error_t  smsc9220_mac_regwrite(
+        const struct smsc9220_eth_dev_t* dev,
+        enum smsc9220_mac_reg_offsets_t regoffset,
+        uint32_t data)
+{
+    volatile uint32_t read = 0;
+    uint32_t maccmd = GET_BIT_FIELD(regoffset,
+                                        MAC_CSR_CMD_ADDRESS_MASK, 0);
+    uint32_t time_out = REG_WRITE_TIME_OUT_MS;
+
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    /* Make sure there's no pending operation */
+    if(!GET_BIT(register_map->mac_csr_cmd, MAC_CSR_CMD_BUSY_INDEX)) {
+        register_map->mac_csr_data = data;      /* Store data. */
+        CLR_BIT(maccmd, MAC_CSR_CMD_RW_INDEX);
+        SET_BIT(maccmd, MAC_CSR_CMD_BUSY_INDEX);
+        register_map->mac_csr_cmd = maccmd;
+
+        do {
+            read = register_map->byte_test;     /* A no-op read. */
+            (void)read;
+            if (dev->data->wait_ms) {
+                dev->data->wait_ms(1);
+            }
+            time_out--;
+        } while(time_out &&
+                (register_map->mac_csr_cmd &
+                 GET_BIT(register_map->mac_csr_cmd, MAC_CSR_CMD_BUSY_INDEX)));
+
+        if(!time_out) {
+            return SMSC9220_ERROR_TIMEOUT;
+        }
+    } else {
+       return SMSC9220_ERROR_BUSY;
+    }
+    return SMSC9220_ERROR_NONE;
+}
+
+enum smsc9220_error_t smsc9220_phy_regread(
+        const struct smsc9220_eth_dev_t* dev,
+        enum phy_reg_offsets_t regoffset,
+        uint32_t *data)
+{
+    uint32_t val = 0;
+    uint32_t phycmd = 0;
+    uint32_t time_out = REG_WRITE_TIME_OUT_MS;
+
+    if (smsc9220_mac_regread(dev, SMSC9220_MAC_REG_OFFSET_MII_ACC, &val)) {
+        return SMSC9220_ERROR_INTERNAL;
+    }
+
+    if(!GET_BIT(val, MAC_REG_MII_ACC_BUSY_INDEX)) {
+        phycmd = 0;
+        SET_BIT(phycmd, MAC_REG_MII_ACC_PHYADDR_INDEX);
+        SET_BIT_FIELD(phycmd, MAC_REG_MII_ACC_MII_REG_MASK,
+                      MAC_REG_MII_ACC_MII_REG_OFFSET, regoffset);
+        CLR_BIT(phycmd, MAC_REG_MII_ACC_WRITE_INDEX);
+        SET_BIT(phycmd, MAC_REG_MII_ACC_BUSY_INDEX);
+
+        if (smsc9220_mac_regwrite(dev, SMSC9220_MAC_REG_OFFSET_MII_ACC,
+                                  phycmd)) {
+            return SMSC9220_ERROR_INTERNAL;
+        }
+
+        val = 0;
+        do {
+            if (dev->data->wait_ms) {
+                dev->data->wait_ms(1);
+            }
+            time_out--;
+            if (smsc9220_mac_regread(dev, SMSC9220_MAC_REG_OFFSET_MII_ACC,
+                &val)) {
+                return SMSC9220_ERROR_INTERNAL;
+            }
+        } while(time_out && (GET_BIT(val, MAC_REG_MII_ACC_BUSY_INDEX)));
+
+        if (!time_out) {
+            return SMSC9220_ERROR_TIMEOUT;
+        } else if (smsc9220_mac_regread(dev, SMSC9220_MAC_REG_OFFSET_MII_DATA,
+                   data)) {
+            return SMSC9220_ERROR_INTERNAL;
+        }
+    } else {
+        return SMSC9220_ERROR_BUSY;
+    }
+    return SMSC9220_ERROR_NONE;
+}
+
+enum smsc9220_error_t smsc9220_phy_regwrite(
+        const struct smsc9220_eth_dev_t* dev,
+        enum phy_reg_offsets_t regoffset,
+        uint32_t data)
+{
+    uint32_t val = 0;
+    uint32_t phycmd = 0;
+    uint32_t time_out = REG_WRITE_TIME_OUT_MS;
+
+    if (smsc9220_mac_regread(dev, SMSC9220_MAC_REG_OFFSET_MII_ACC, &val)) {
+        return SMSC9220_ERROR_INTERNAL;
+    }
+
+    if(!GET_BIT(val, MAC_REG_MII_ACC_BUSY_INDEX)) {
+        /* Load the data */
+        if (smsc9220_mac_regwrite(dev, SMSC9220_MAC_REG_OFFSET_MII_DATA,
+                                 (data & 0xFFFF))) {
+            return SMSC9220_ERROR_INTERNAL;
+        }
+        phycmd = 0;
+        SET_BIT(phycmd, MAC_REG_MII_ACC_PHYADDR_INDEX);
+        SET_BIT_FIELD(phycmd, MAC_REG_MII_ACC_MII_REG_MASK,
+                      MAC_REG_MII_ACC_MII_REG_OFFSET, regoffset);
+        SET_BIT(phycmd, MAC_REG_MII_ACC_WRITE_INDEX);
+        SET_BIT(phycmd, MAC_REG_MII_ACC_BUSY_INDEX);
+        /* Start operation */
+        if (smsc9220_mac_regwrite(dev, SMSC9220_MAC_REG_OFFSET_MII_ACC,
+                                  phycmd)) {
+            return SMSC9220_ERROR_INTERNAL;
+        }
+
+        phycmd = 0;
+
+        do {
+            if (dev->data->wait_ms) {
+                dev->data->wait_ms(1);
+            }
+            time_out--;
+            if (smsc9220_mac_regread(dev, SMSC9220_MAC_REG_OFFSET_MII_ACC,
+                                     &phycmd)){
+                return SMSC9220_ERROR_INTERNAL;
+            }
+        } while(time_out &&  GET_BIT(phycmd, 0));
+
+        if (!time_out) {
+            return SMSC9220_ERROR_TIMEOUT;
+        }
+
+    } else {
+        return SMSC9220_ERROR_BUSY;
+    }
+    return SMSC9220_ERROR_NONE;
+}
+
+uint32_t smsc9220_read_id(const struct smsc9220_eth_dev_t* dev)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    return register_map->id_revision;
+}
+
+enum smsc9220_error_t  smsc9220_soft_reset(
+        const struct smsc9220_eth_dev_t* dev)
+{
+    uint32_t time_out = RESET_TIME_OUT_MS;
+
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    /* Soft reset */
+    SET_BIT(register_map->hw_cfg, HW_CFG_REG_SRST_INDEX);
+
+    do {
+        if (dev->data->wait_ms) {
+            dev->data->wait_ms(1);
+        }
+        time_out--;
+    } while(time_out &&
+            GET_BIT(register_map->hw_cfg, HW_CFG_REG_SRST_TIMEOUT_INDEX));
+
+    if (!time_out) {
+        return SMSC9220_ERROR_TIMEOUT;
+    }
+
+    return SMSC9220_ERROR_NONE;
+}
+
+void smsc9220_set_txfifo(const struct smsc9220_eth_dev_t* dev,
+                         uint32_t val)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    if(val >= HW_CFG_REG_TX_FIFO_SIZE_MIN &&
+       val <= HW_CFG_REG_TX_FIFO_SIZE_MAX) {
+       register_map->hw_cfg = val << HW_CFG_REG_TX_FIFO_SIZE_POS;
+    }
+}
+
+enum smsc9220_error_t smsc9220_set_fifo_level_irq(
+        const struct smsc9220_eth_dev_t* dev,
+        enum smsc9220_fifo_level_irq_pos_t irq_level_pos,
+        uint32_t level)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    if (level < SMSC9220_FIFO_LEVEL_IRQ_LEVEL_MIN ||
+        level > SMSC9220_FIFO_LEVEL_IRQ_LEVEL_MAX) {
+        return SMSC9220_ERROR_PARAM;
+    }
+
+    CLR_BIT_FIELD(register_map->fifo_level_irq, SMSC9220_FIFO_LEVEL_IRQ_MASK,
+                  irq_level_pos, SMSC9220_FIFO_LEVEL_IRQ_MASK);
+    SET_BIT_FIELD(register_map->fifo_level_irq, SMSC9220_FIFO_LEVEL_IRQ_MASK,
+                  irq_level_pos, level);
+    return SMSC9220_ERROR_NONE;
+}
+
+enum smsc9220_error_t smsc9220_wait_eeprom(
+        const struct smsc9220_eth_dev_t* dev)
+{
+    uint32_t time_out = REG_WRITE_TIME_OUT_MS;
+
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    do {
+        if (dev->data->wait_ms) {
+            dev->data->wait_ms(1);
+        }
+        time_out--;
+    } while(time_out &&
+            GET_BIT(register_map->eeprom_cmd, EEPROM_CMD_REG_BUSY_INDEX));
+
+    if (!time_out) {
+        return SMSC9220_ERROR_TIMEOUT;
+    }
+
+    return SMSC9220_ERROR_NONE;
+}
+
+void smsc9220_init_irqs(const struct smsc9220_eth_dev_t* dev)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    smsc9220_disable_all_interrupts(dev);
+    smsc9220_clear_all_interrupts(dev);
+
+    /* Set IRQ deassertion interval */
+    SET_BIT_FIELD(register_map->irq_cfg, IRQ_CFG_INT_DEAS_MASK,
+                  IRQ_CFG_INT_DEAS_POS, IRQ_CFG_INT_DEAS_10US);
+
+    /* enable interrupts */
+    SET_BIT(register_map->irq_cfg, IRQ_CFG_IRQ_EN_INDEX);
+}
+
+enum smsc9220_error_t smsc9220_check_phy(const struct smsc9220_eth_dev_t* dev)
+{
+    uint32_t phyid1 = 0;
+    uint32_t phyid2 = 0;
+
+    if (smsc9220_phy_regread(dev, SMSC9220_PHY_REG_OFFSET_ID1,&phyid1)) {
+        return SMSC9220_ERROR_INTERNAL;
+    }
+    if (smsc9220_phy_regread(dev, SMSC9220_PHY_REG_OFFSET_ID2,&phyid2)) {
+        return SMSC9220_ERROR_INTERNAL;
+    }
+    if ((phyid1 == 0xFFFF && phyid2 == 0xFFFF) ||
+            (phyid1 == 0x0 && phyid2 == 0x0)) {
+        return SMSC9220_ERROR_INTERNAL;
+    }
+    return SMSC9220_ERROR_NONE;
+}
+
+enum smsc9220_error_t smsc9220_reset_phy(const struct smsc9220_eth_dev_t* dev)
+{
+    uint32_t read = 0;
+
+    if(smsc9220_phy_regread(dev, SMSC9220_PHY_REG_OFFSET_BCTRL, &read)) {
+        return SMSC9220_ERROR_INTERNAL;
+    }
+
+    SET_BIT(read, PHY_REG_BCTRL_RESET_INDEX);
+    if(smsc9220_phy_regwrite(dev, SMSC9220_PHY_REG_OFFSET_BCTRL, read)) {
+        return SMSC9220_ERROR_INTERNAL;
+    }
+    return SMSC9220_ERROR_NONE;
+}
+
+void smsc9220_advertise_cap(const struct smsc9220_eth_dev_t* dev)
+{
+    uint32_t aneg_adv = 0;
+    smsc9220_phy_regread(dev, SMSC9220_PHY_REG_OFFSET_ANEG_ADV, &aneg_adv);
+
+    SET_BIT(aneg_adv, ANEG_10_BASE_T_INDEX);
+    SET_BIT(aneg_adv, ANEG_10_BASE_T_FULL_DUPL_INDEX);
+    SET_BIT(aneg_adv, ANEG_100_BASE_TX_INDEX);
+    SET_BIT(aneg_adv, ANEG_100_BASE_TX_FULL_DUPL_INDEX);
+    SET_BIT(aneg_adv, ANEG_SYMM_PAUSE_INDEX);
+    SET_BIT(aneg_adv, ANEG_ASYMM_PAUSE_INDEX);
+
+    smsc9220_phy_regwrite(dev, SMSC9220_PHY_REG_OFFSET_ANEG_ADV, aneg_adv);
+}
+
+void smsc9220_enable_xmit(const struct smsc9220_eth_dev_t* dev)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    SET_BIT(register_map->tx_cfg, TX_CFG_ON_INDEX);
+}
+
+void smsc9220_disable_xmit(const struct smsc9220_eth_dev_t* dev)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    CLR_BIT(register_map->tx_cfg, TX_CFG_ON_INDEX);
+}
+
+void smsc9220_enable_mac_xmit(const struct smsc9220_eth_dev_t* dev)
+{
+    uint32_t mac_cr = 0;
+    smsc9220_mac_regread(dev, SMSC9220_MAC_REG_OFFSET_CR, &mac_cr);
+
+    SET_BIT(mac_cr, MAC_REG_CR_TXEN_INDEX);
+
+    smsc9220_mac_regwrite(dev, SMSC9220_MAC_REG_OFFSET_CR, mac_cr);
+}
+
+void smsc9220_disable_mac_xmit(const struct smsc9220_eth_dev_t* dev)
+{
+    uint32_t mac_cr = 0;
+    smsc9220_mac_regread(dev, SMSC9220_MAC_REG_OFFSET_CR, &mac_cr);
+
+    CLR_BIT(mac_cr, MAC_REG_CR_TXEN_INDEX);
+
+    smsc9220_mac_regwrite(dev, SMSC9220_MAC_REG_OFFSET_CR, mac_cr);
+}
+
+void smsc9220_enable_mac_recv(const struct smsc9220_eth_dev_t* dev)
+{
+    uint32_t mac_cr = 0;
+    smsc9220_mac_regread(dev, SMSC9220_MAC_REG_OFFSET_CR, &mac_cr);
+
+    SET_BIT(mac_cr, MAC_REG_CR_RXEN_INDEX);
+
+    smsc9220_mac_regwrite(dev, SMSC9220_MAC_REG_OFFSET_CR, mac_cr);
+}
+
+void smsc9220_disable_mac_recv(const struct smsc9220_eth_dev_t* dev)
+{
+    uint32_t mac_cr = 0;
+    smsc9220_mac_regread(dev, SMSC9220_MAC_REG_OFFSET_CR, &mac_cr);
+
+    CLR_BIT(mac_cr, MAC_REG_CR_RXEN_INDEX);
+
+    smsc9220_mac_regwrite(dev, SMSC9220_MAC_REG_OFFSET_CR, mac_cr);
+}
+
+int smsc9220_check_id(const struct smsc9220_eth_dev_t* dev)
+{
+    uint32_t id = smsc9220_read_id(dev);
+
+    return ((GET_BIT_FIELD(id, CHIP_ID_MASK, CHIP_ID_POS) == CHIP_ID) ? 0 : 1);
+}
+
+void smsc9220_enable_interrupt(const struct smsc9220_eth_dev_t* dev,
+                               enum smsc9220_interrupt_source source)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    SET_BIT(register_map->irq_enable, source);
+}
+
+void smsc9220_disable_interrupt(const struct smsc9220_eth_dev_t* dev,
+                                enum smsc9220_interrupt_source source)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    CLR_BIT(register_map->irq_enable, source);
+}
+
+void smsc9220_disable_all_interrupts(const struct smsc9220_eth_dev_t* dev)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    register_map->irq_enable = 0;
+}
+
+void smsc9220_clear_interrupt(const struct smsc9220_eth_dev_t* dev,
+                              enum smsc9220_interrupt_source source)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    SET_BIT(register_map->irq_status, source);
+}
+
+void smsc9220_clear_all_interrupts(const struct smsc9220_eth_dev_t* dev)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    register_map->irq_status = UINT32_MAX;
+}
+
+int smsc9220_get_interrupt(const struct smsc9220_eth_dev_t* dev,
+                           enum smsc9220_interrupt_source source)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    return GET_BIT(register_map->irq_status, source);
+}
+
+void smsc9220_establish_link(const struct smsc9220_eth_dev_t* dev)
+{
+    uint32_t bcr = 0;
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    smsc9220_phy_regread(dev, SMSC9220_PHY_REG_OFFSET_BCTRL, &bcr);
+    SET_BIT(bcr, PHY_REG_BCTRL_AUTO_NEG_EN_INDEX);
+    SET_BIT(bcr, PHY_REG_BCTRL_RST_AUTO_NEG_INDEX);
+    smsc9220_phy_regwrite(dev, SMSC9220_PHY_REG_OFFSET_BCTRL, bcr);
+
+    SET_BIT(register_map->hw_cfg, HW_CFG_REG_MUST_BE_ONE_INDEX);
+}
+
+enum smsc9220_error_t smsc9220_read_mac_address(
+        const struct smsc9220_eth_dev_t* dev, char *mac)
+{
+    uint32_t mac_low = 0;
+    uint32_t mac_high = 0;
+
+    if(!mac) {
+        return SMSC9220_ERROR_PARAM;
+    }
+
+    if (smsc9220_mac_regread(dev, SMSC9220_MAC_REG_OFFSET_ADDRH, &mac_high)) {
+        return SMSC9220_ERROR_INTERNAL;
+    }
+    if (smsc9220_mac_regread(dev, SMSC9220_MAC_REG_OFFSET_ADDRL, &mac_low)) {
+        return SMSC9220_ERROR_INTERNAL;
+    }
+    mac[0] = mac_low & 0xFF;
+    mac[1] = (mac_low >> 8) & 0xFF;
+    mac[2] = (mac_low >> 16) & 0xFF;
+    mac[3] = (mac_low >> 24) & 0xFF;
+    mac[4] = mac_high & 0xFF;
+    mac[5] = (mac_high >> 8) & 0xFF;
+
+    return SMSC9220_ERROR_NONE;
+}
+
+uint32_t smsc9220_get_tx_data_fifo_size(
+        const struct smsc9220_eth_dev_t* dev)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    uint32_t tx_fifo_size =
+            GET_BIT_FIELD(register_map->hw_cfg,
+                    TX_DATA_FIFO_SIZE_KBYTES_MASK,
+                    TX_DATA_FIFO_SIZE_KBYTES_POS) * KBYTES_TO_BYTES_MULTIPLIER;
+
+    return (tx_fifo_size - TX_STATUS_FIFO_SIZE_BYTES);
+}
+
+enum smsc9220_error_t smsc9220_init(
+        const struct smsc9220_eth_dev_t* dev,
+        void(* wait_ms_function)(int))
+{
+    uint32_t phyreset = 0;
+    enum smsc9220_error_t error = SMSC9220_ERROR_NONE;
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    if (!wait_ms_function) {
+        return SMSC9220_ERROR_PARAM;
+    }
+    dev->data->wait_ms = wait_ms_function;
+
+    error = smsc9220_check_id(dev);
+    if(error != SMSC9220_ERROR_NONE) {
+        return error;
+    }
+
+    error = smsc9220_soft_reset(dev);
+    if(error != SMSC9220_ERROR_NONE) {
+        return error;
+    }
+
+    smsc9220_set_txfifo(dev, HW_CFG_REG_TX_FIFO_SIZE);
+
+    SET_BIT_FIELD(register_map->afc_cfg, AFC_BACK_DUR_MASK,
+                  AFC_BACK_DUR_POS, AFC_BACK_DUR);
+    SET_BIT_FIELD(register_map->afc_cfg, AFC_LOW_LEVEL_MASK,
+                  AFC_LOW_LEVEL_POS, AFC_LOW_LEVEL);
+    SET_BIT_FIELD(register_map->afc_cfg, AFC_HIGH_LEVEL_MASK,
+                  AFC_HIGH_LEVEL_POS, AFC_HIGH_LEVEL);
+
+    error = smsc9220_wait_eeprom(dev);
+    if(error != SMSC9220_ERROR_NONE) {
+        return error;
+    }
+
+    /* Configure GPIOs as LED outputs. */
+    register_map->gpio_cfg = 0;
+    SET_BIT(register_map->gpio_cfg, GPIO_CFG_GPIO0_PUSHPULL_INDEX);
+    SET_BIT(register_map->gpio_cfg, GPIO_CFG_GPIO1_PUSHPULL_INDEX);
+    SET_BIT(register_map->gpio_cfg, GPIO_CFG_GPIO2_PUSHPULL_INDEX);
+    SET_BIT(register_map->gpio_cfg, GPIO_CFG_GPIO0_LED_INDEX);
+    SET_BIT(register_map->gpio_cfg, GPIO_CFG_GPIO1_LED_INDEX);
+    SET_BIT(register_map->gpio_cfg, GPIO_CFG_GPIO2_LED_INDEX);
+
+    smsc9220_init_irqs(dev);
+
+    /* Configure MAC addresses here if needed. */
+
+    error = smsc9220_check_phy(dev);
+    if(error != SMSC9220_ERROR_NONE) {
+        return error;
+    }
+
+    error = smsc9220_reset_phy(dev);
+    if(error != SMSC9220_ERROR_NONE) {
+        return error;
+    }
+
+    if (dev->data->wait_ms) {
+        dev->data->wait_ms(PHY_RESET_TIME_OUT_MS);
+    }
+    /* Checking whether phy reset completed successfully.*/
+    error = smsc9220_phy_regread(dev, SMSC9220_PHY_REG_OFFSET_BCTRL,
+                                &phyreset);
+    if(error != SMSC9220_ERROR_NONE) {
+        return error;
+    }
+
+    if(GET_BIT(phyreset, PHY_REG_BCTRL_RESET_INDEX)) {
+        return SMSC9220_ERROR_INTERNAL;
+    }
+
+    smsc9220_advertise_cap(dev);
+    smsc9220_establish_link(dev);
+
+    smsc9220_enable_mac_xmit(dev);
+    smsc9220_enable_xmit(dev);
+    smsc9220_enable_mac_recv(dev);
+
+    /* This sleep is compulsory otherwise txmit/receive will fail. */
+    if (dev->data->wait_ms) {
+        dev->data->wait_ms(INIT_FINISH_DELAY);
+    }
+    dev->data->state = 1;
+
+    return SMSC9220_ERROR_NONE;
+}
+
+enum smsc9220_error_t smsc9220_send_by_chunks(
+                            const struct smsc9220_eth_dev_t* dev,
+                            uint32_t total_payload_length,
+                            bool is_new_packet,
+                            const char *data, uint32_t current_size)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+    bool is_first_segment = false;
+    bool is_last_segment = false;
+    uint32_t txcmd_a, txcmd_b = 0;
+    uint32_t tx_buffer_free_space = 0;
+    volatile uint32_t xmit_stat = 0;
+
+    if (!data) {
+        return SMSC9220_ERROR_PARAM;
+    }
+
+    if (is_new_packet) {
+        is_first_segment = true;
+        dev->data->ongoing_packet_length = total_payload_length;
+        dev->data->ongoing_packet_length_sent = 0;
+    } else if (dev->data->ongoing_packet_length != total_payload_length ||
+             dev->data->ongoing_packet_length_sent >= total_payload_length) {
+        return SMSC9220_ERROR_PARAM;
+    }
+
+    /* Would next chunk fit into buffer? */
+    tx_buffer_free_space = GET_BIT_FIELD(register_map->tx_fifo_inf,
+                                         FIFO_USED_SPACE_MASK,
+                                         DATA_FIFO_USED_SPACE_POS);
+    if (current_size > tx_buffer_free_space) {
+        return SMSC9220_ERROR_INTERNAL; /* Not enough space in FIFO */
+    }
+    if ((dev->data->ongoing_packet_length_sent + current_size) ==
+         total_payload_length) {
+        is_last_segment = true;
+    }
+
+    txcmd_a = 0;
+    txcmd_b = 0;
+
+    if (is_last_segment) {
+        SET_BIT(txcmd_a, TX_COMMAND_A_LAST_SEGMENT_INDEX);
+    }
+    if (is_first_segment) {
+        SET_BIT(txcmd_a, TX_COMMAND_A_FIRST_SEGMENT_INDEX);
+    }
+
+    uint32_t data_start_offset_bytes = (4 - (current_size % 4));
+
+    SET_BIT_FIELD(txcmd_a, TX_CMD_PKT_LEN_BYTES_MASK, 0, current_size);
+    SET_BIT_FIELD(txcmd_a, TX_CMD_DATA_START_OFFSET_BYTES_MASK,
+                           TX_CMD_DATA_START_OFFSET_BYTES_POS,
+                           data_start_offset_bytes);
+
+    SET_BIT_FIELD(txcmd_b, TX_CMD_PKT_LEN_BYTES_MASK, 0, current_size);
+    SET_BIT_FIELD(txcmd_b, TX_CMD_PKT_TAG_MASK, TX_CMD_PKT_TAG_POS,
+                  current_size);
+
+    register_map->tx_data_port = txcmd_a;
+    register_map->tx_data_port = txcmd_b;
+
+    fill_tx_fifo(dev, (uint8_t *)data, current_size);
+
+    if (is_last_segment) {
+        /* Pop status port for error check */
+        xmit_stat = register_map->tx_status_port;
+        (void)xmit_stat;
+    }
+    dev->data->ongoing_packet_length_sent += current_size;
+    return SMSC9220_ERROR_NONE;
+}
+
+uint32_t smsc9220_get_rxfifo_data_used_space(const struct
+                                                 smsc9220_eth_dev_t* dev)
+{
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    return GET_BIT_FIELD(register_map->rx_fifo_inf, FIFO_USED_SPACE_MASK,
+                         DATA_FIFO_USED_SPACE_POS);
+}
+
+uint32_t smsc9220_receive_by_chunks(const struct smsc9220_eth_dev_t* dev,
+                                        char *data, uint32_t dlen)
+{
+    uint32_t rxfifo_inf = 0;
+    uint32_t rxfifo_stat = 0;
+    uint32_t packet_length_byte = 0;
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    if (!data) {
+        return 0; /* Invalid input parameter, cannot read */
+    }
+    rxfifo_inf = register_map->rx_fifo_inf;
+
+    if(rxfifo_inf & 0xFFFF) { /* If there's data */
+        rxfifo_stat = register_map->rx_status_port;
+        if(rxfifo_stat != 0) {   /* Fetch status of this packet */
+                /* Ethernet controller is padding to 32bit aligned data */
+                packet_length_byte = GET_BIT_FIELD(rxfifo_stat,
+                                        RX_FIFO_STATUS_PKT_LENGTH_MASK,
+                                        RX_FIFO_STATUS_PKT_LENGTH_POS);
+                packet_length_byte -= 4;
+                dev->data->current_rx_size_words = packet_length_byte;
+        }
+    }
+
+    empty_rx_fifo(dev, (uint8_t *)data, packet_length_byte);
+    dev->data->current_rx_size_words = 0;
+    return packet_length_byte;
+}
+
+uint32_t smsc9220_peek_next_packet_size(const struct
+                                            smsc9220_eth_dev_t* dev)
+{
+    uint32_t packet_size = 0;
+    struct smsc9220_eth_reg_map_t* register_map =
+            (struct smsc9220_eth_reg_map_t*)dev->cfg->base;
+
+    if(smsc9220_get_rxfifo_data_used_space(dev)) {
+        packet_size = GET_BIT_FIELD(register_map->rx_status_peek,
+                                    RX_FIFO_STATUS_PKT_LENGTH_MASK,
+                                    RX_FIFO_STATUS_PKT_LENGTH_POS);
+    }
+    return packet_size;
+}
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/smsc9220_eth_drv.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/smsc9220_eth_drv.h
new file mode 100644
index 00000000..3c60f45b
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/native_drivers/smsc9220_eth_drv.h
@@ -0,0 +1,544 @@
+/*
+ * Copyright (c) 2016-2019 Arm Limited
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * \file smsc9220_drv.h
+ * \brief Generic driver for SMSC9220 Ethernet controller
+ */
+
+#ifndef __SMSC9220_ETH_H__
+#define __SMSC9220_ETH_H__
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** SMSC9220 device configuration structure */
+struct smsc9220_eth_dev_cfg_t {
+    const uint32_t base;              /*!< SMSC9220 base address */
+};
+
+/** SMSC9220 device data structure */
+struct smsc9220_eth_dev_data_t {
+    uint32_t state;       /*!< Indicates if the SMSC9220 driver
+                               is initialized and enabled */
+    void (*wait_ms) (int);/*!< function pointer to system's millisec delay
+                               function, will be used for delays */
+    uint32_t ongoing_packet_length;/*!< size in bytes of the packet
+                                            is being sent */
+    uint32_t ongoing_packet_length_sent; /*!< size in bytes of the packet
+                                                  has been sent */
+    uint32_t current_rx_size_words; /*!< Data length in words,
+                                             currently is being read */
+};
+
+/** SMSC9220 device structure */
+struct smsc9220_eth_dev_t {
+    const struct smsc9220_eth_dev_cfg_t* const cfg; /*!< configuration */
+    struct smsc9220_eth_dev_data_t* const data;     /*!< data */
+};
+
+/**
+ * \brief Error code definitions
+ *
+ */
+enum smsc9220_error_t{
+    SMSC9220_ERROR_NONE     = 0U, /*!< no error */
+    SMSC9220_ERROR_TIMEOUT  = 1U, /*!< timeout */
+    SMSC9220_ERROR_BUSY     = 2U, /*!< no error */
+    SMSC9220_ERROR_PARAM    = 3U, /*!< invalid parameter */
+    SMSC9220_ERROR_INTERNAL = 4U  /*!< internal error */
+};
+
+/**
+ * \brief Interrupt source definitions
+ *
+ */
+enum smsc9220_interrupt_source {
+    SMSC9220_INTERRUPT_GPIO0                  = 0U,
+    SMSC9220_INTERRUPT_GPIO1                  = 1U,
+    SMSC9220_INTERRUPT_GPIO2                  = 2U,
+    SMSC9220_INTERRUPT_RX_STATUS_FIFO_LEVEL   = 3U,
+    SMSC9220_INTERRUPT_RX_STATUS_FIFO_FULL    = 4U,
+    /* 5 Reserved according to Datasheet */
+    SMSC9220_INTERRUPT_RX_DROPPED_FRAME       = 6U,
+    SMSC9220_INTERRUPT_TX_STATUS_FIFO_LEVEL   = 7U,
+    SMSC9220_INTERRUPT_TX_STATUS_FIFO_FULL    = 8U,
+    SMSC9220_INTERRUPT_TX_DATA_FIFO_AVAILABLE = 9U,
+    SMSC9220_INTERRUPT_TX_DATA_FIFO_OVERRUN   = 10U,
+    /* 11, 12 Reserved according to Datasheet */
+    SMSC9220_INTERRUPT_TX_ERROR               = 13U,
+    SMSC9220_INTERRUPT_RX_ERROR               = 14U,
+    SMSC9220_INTERRUPT_RX_WATCHDOG_TIMEOUT    = 15U,
+    SMSC9220_INTERRUPT_TX_STATUS_OVERFLOW     = 16U,
+    SMSC9220_INTERRUPT_TX_POWER_MANAGEMENT    = 17U,
+    SMSC9220_INTERRUPT_PHY                    = 18U,
+    SMSC9220_INTERRUPT_GP_TIMER               = 19U,
+    SMSC9220_INTERRUPT_RX_DMA                 = 20U,
+    SMSC9220_INTERRUPT_TX_IOC                 = 21U,
+    /* 22 Reserved according to Datasheet*/
+    SMSC9220_INTERRUPT_RX_DROPPED_FRAME_HALF  = 23U,
+    SMSC9220_INTERRUPT_RX_STOPPED             = 24U,
+    SMSC9220_INTERRUPT_TX_STOPPED             = 25U,
+    /* 26 - 30 Reserved according to Datasheet*/
+    SMSC9220_INTERRUPT_SW                     = 31U
+};
+
+/**
+ * \brief MAC register offset definitions
+ *
+ */
+enum smsc9220_mac_reg_offsets_t{
+    SMSC9220_MAC_REG_OFFSET_CR =       0x1U,
+    SMSC9220_MAC_REG_OFFSET_ADDRH =    0x2U,
+    SMSC9220_MAC_REG_OFFSET_ADDRL =    0x3U,
+    SMSC9220_MAC_REG_OFFSET_HASHH =    0x4U,
+    SMSC9220_MAC_REG_OFFSET_HASHL =    0x5U,
+    SMSC9220_MAC_REG_OFFSET_MII_ACC =  0x6U,
+    SMSC9220_MAC_REG_OFFSET_MII_DATA = 0x7U,
+    SMSC9220_MAC_REG_OFFSET_FLOW =     0x8U,
+    SMSC9220_MAC_REG_OFFSET_VLAN1 =    0x9U,
+    SMSC9220_MAC_REG_OFFSET_VLAN2 =    0xAU,
+    SMSC9220_MAC_REG_OFFSET_WUFF =     0xBU,
+    SMSC9220_MAC_REG_OFFSET_WUCSR =    0xCU,
+    SMSC9220_MAC_REG_OFFSET_COE_CR =   0xDU
+};
+
+/**
+ * \brief PHY register offset definitions
+ *
+ */
+enum phy_reg_offsets_t{
+    SMSC9220_PHY_REG_OFFSET_BCTRL =      0U,
+    SMSC9220_PHY_REG_OFFSET_BSTATUS =    1U,
+    SMSC9220_PHY_REG_OFFSET_ID1 =        2U,
+    SMSC9220_PHY_REG_OFFSET_ID2 =        3U,
+    SMSC9220_PHY_REG_OFFSET_ANEG_ADV =   4U,
+    SMSC9220_PHY_REG_OFFSET_ANEG_LPA =   5U,
+    SMSC9220_PHY_REG_OFFSET_ANEG_EXP =   6U,
+    SMSC9220_PHY_REG_OFFSET_MCONTROL =   17U,
+    SMSC9220_PHY_REG_OFFSET_MSTATUS =    18U,
+    SMSC9220_PHY_REG_OFFSET_CSINDICATE = 27U,
+    SMSC9220_PHY_REG_OFFSET_INTSRC =     29U,
+    SMSC9220_PHY_REG_OFFSET_INTMASK =    30U,
+    SMSC9220_PHY_REG_OFFSET_CS =         31U
+};
+
+/* Bit definitions for PHY Basic Status Register */
+#define PHY_REG_BSTATUS_EXTENDED_CAPABILITIES_INDEX     0U
+#define PHY_REG_BSTATUS_JABBER_DETECT_INDEX             1U
+#define PHY_REG_BSTATUS_LINK_STATUS_INDEX               2U
+#define PHY_REG_BSTATUS_AUTO_NEG_ABILITY_INDEX          3U
+#define PHY_REG_BSTATUS_REMOTE_FAULT_INDEX              4U
+#define PHY_REG_BSTATUS_AUTO_NEG_COMPLETE_INDEX         5U
+#define PHY_REG_BSTATUS_10BASE_T_HALF_DUPLEX_INDEX      11U
+#define PHY_REG_BSTATUS_10BASE_T_FULL_DUPLEX_INDEX      12U
+#define PHY_REG_BSTATUS_100BASE_TX_HALF_DUPLEX_INDEX    13U
+#define PHY_REG_BSTATUS_100BASE_TX_FULL_DUPLEX_INDEX    14U
+#define PHY_REG_BSTATUS_100BASE_T4_INDEX                15U
+
+/**
+ * \brief FIFO Level Interrupt bit definitions
+ *
+ */
+enum smsc9220_fifo_level_irq_pos_t{
+    SMSC9220_FIFO_LEVEL_IRQ_RX_STATUS_POS = 0U,
+    SMSC9220_FIFO_LEVEL_IRQ_TX_STATUS_POS = 16U,
+    SMSC9220_FIFO_LEVEL_IRQ_TX_DATA_POS = 24U
+};
+
+/**
+ * \brief FIFO Level Interrupt limits
+ *
+ */
+#define SMSC9220_FIFO_LEVEL_IRQ_MASK             0xFFU
+#define SMSC9220_FIFO_LEVEL_IRQ_LEVEL_MIN        0U
+#define SMSC9220_FIFO_LEVEL_IRQ_LEVEL_MAX        SMSC9220_FIFO_LEVEL_IRQ_MASK
+
+/**
+ * \brief Initializes SMSC9220 Ethernet controller to a known default state:
+ *          - device ID is checked
+ *          - global interrupt is enabled, but all irq sources are disabled
+ *          - all capabilities are advertised
+ *              - 10Mbps able
+ *              - 10Mbps with full duplex
+ *              - 100Mbps Tx able
+ *              - 100Mbps with full duplex
+ *              - Symmetric Pause
+ *              - Asymmetric Pause
+ *          - Establish link enabled
+ *          - Rx enabled
+ *          - Tx enabled
+ *        Init should be called prior to any other process and
+ *        it's the caller's responsibility to follow proper call order.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in] wait_ms_function function pointer to a millisec delay function
+ *                             for proper timing of some processes
+ *
+ * \return error code /ref smsc9220_error_t
+ */
+enum smsc9220_error_t smsc9220_init(const struct smsc9220_eth_dev_t* dev,
+                               void(* wait_ms_function)(int));
+
+/**
+ * \brief Reads the MAC register.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in] regoffset Register offset
+ * \param[in, out] data Pointer to register will be read
+ *
+ * \return error code /ref smsc9220_error_t
+ */
+enum smsc9220_error_t smsc9220_mac_regread(
+        const struct smsc9220_eth_dev_t* dev,
+        enum smsc9220_mac_reg_offsets_t regoffset,
+        uint32_t *data);
+
+/**
+ * \brief Writes the MAC register.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in] regoffset Register offset
+ * \param[in] data Register value to write
+ *
+ * \return error code /ref smsc9220_error_t
+ */
+enum smsc9220_error_t smsc9220_mac_regwrite(
+        const struct smsc9220_eth_dev_t* dev,
+        enum smsc9220_mac_reg_offsets_t regoffset,
+        uint32_t data);
+
+/**
+ * \brief Reads the PHY register.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in] regoffset Register offset
+ * \param[out] data Register value is read
+ *
+ * \return error code /ref smsc9220_error_t
+ */
+enum smsc9220_error_t smsc9220_phy_regread(
+        const struct smsc9220_eth_dev_t* dev,
+        enum phy_reg_offsets_t,
+        uint32_t *data);
+
+/**
+ * \brief Writes the PHY register.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in] regoffset Register offset
+ * \param[in] data Register value to write
+ *
+ * \return error code /ref smsc9220_error_t
+ */
+enum smsc9220_error_t smsc9220_phy_regwrite(
+        const struct smsc9220_eth_dev_t* dev,
+        enum phy_reg_offsets_t,
+        uint32_t data);
+
+/**
+ * \brief Reads the Ethernet Controller's ID.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ *
+ * \return ID number
+ */
+uint32_t smsc9220_read_id(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Initiates a soft reset, returns failure or success.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ *
+ * \return error code /ref smsc9220_error_t
+ */
+enum smsc9220_error_t smsc9220_soft_reset(
+        const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Sets the Maximum Transmission Unit by Tx fifo size.
+ *        Note: The MTU will be smaller by 512 bytes,
+ *        whis is used by the status.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in] val Size of the fifo in kbytes
+ *                \ref HW_CFG_REG_TX_FIFO_SIZE_MIN
+ *                \ref HW_CFG_REG_TX_FIFO_SIZE_MAX
+ */
+void smsc9220_set_txfifo(const struct smsc9220_eth_dev_t* dev,
+                         uint32_t val);
+
+/**
+ * \brief Sets the FIFO level interrupt for a given source.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in] irq_level_pos Bit position of the FIFO to set
+ *            \ref smsc9220_fifo_level_irq_pos_t
+ * \param[in] level Level of the FIFO, when the FIFO used space is greater
+ *             than this value, corresponding interrupt will be generated.
+ *
+ * \return error code /ref smsc9220_error_t
+ */
+enum smsc9220_error_t smsc9220_set_fifo_level_irq(
+        const struct smsc9220_eth_dev_t* dev,
+        enum smsc9220_fifo_level_irq_pos_t irq_level_pos,
+        uint32_t level);
+
+/**
+ * \brief Waits for EEPROM to be ready to use.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ *
+ * \return error code /ref smsc9220_error_t
+ */
+enum smsc9220_error_t smsc9220_wait_eeprom(
+        const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Initializes irqs by clearing and disabling all interrupt sources
+ *        and enable interrupts. Since all interrupt sources are disabled,
+ *        interrupt won't be triggered, until interrupt sources won't be
+ *        enabled by \ref smsc9220_enable_interrupt
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ */
+void smsc9220_init_irqs(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Checks PHY ID registers.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ *
+ * \return error code /ref smsc9220_error_t
+ */
+enum smsc9220_error_t smsc9220_check_phy(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Resets PHY.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ *
+ * \return error code /ref smsc9220_error_t
+ */
+enum smsc9220_error_t smsc9220_reset_phy(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Advertises all speeds and pauses capabilities.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ */
+void smsc9220_advertise_cap(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Enables transmission.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ */
+void smsc9220_enable_xmit(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Disables transmission.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ */
+void smsc9220_disable_xmit(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Enables MAC Transmitter.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ */
+void smsc9220_enable_mac_xmit(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Disables MAC Transmitter.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ */
+void smsc9220_disable_mac_xmit(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Enables receiving.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ */
+void smsc9220_enable_mac_recv(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Disables receiving.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ */
+void smsc9220_disable_mac_recv(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Enables the given interrupt source.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in] source Enum of the interrupt source.
+ */
+void smsc9220_enable_interrupt(const struct smsc9220_eth_dev_t* dev,
+                               enum smsc9220_interrupt_source source);
+
+/**
+ * \brief Disables the given interrupt source.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in] source Enum of the interrupt source.
+ */
+void smsc9220_disable_interrupt(const struct smsc9220_eth_dev_t* dev,
+                                enum smsc9220_interrupt_source source);
+
+/**
+ * \brief Disables all interrupt sources.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ */
+void smsc9220_disable_all_interrupts(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Clears the given interrupt source.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in] source Enum of the interrupt source.
+ */
+void smsc9220_clear_interrupt(const struct smsc9220_eth_dev_t* dev,
+                              enum smsc9220_interrupt_source source);
+
+/**
+ * \brief Clears all interrupt sources.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ */
+void smsc9220_clear_all_interrupts(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Gets the status of the given interrupt source.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in] source Enum of the interrupt source.
+ *
+ * \return non-zero if the given interrupt source is triggered, zero otherwise
+ */
+int smsc9220_get_interrupt(const struct smsc9220_eth_dev_t* dev,
+                           enum smsc9220_interrupt_source source);
+
+/**
+ * \brief Establishes link
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ */
+void smsc9220_establish_link(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Reads the Ethernet Controller's MAC address from its EEPROM.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in,out] mac array will include the read MAC address in
+ *                6 bytes hexadecimal format.
+ *                It should be allocated by the caller to 6 bytes.
+ *
+ * \return error code /ref smsc9220_error_t
+ */
+enum smsc9220_error_t smsc9220_read_mac_address(
+        const struct smsc9220_eth_dev_t* dev, char *mac);
+
+/**
+ * \brief Check device ID.
+ *
+ * \return error code /ref smsc9220_error_t
+ */
+int smsc9220_check_id(const struct smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Gets the data size of the Tx buffer, aka Maximum Trasmission Unit
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ *
+ * \return Fifo data size in bytes
+ */
+uint32_t smsc9220_get_tx_data_fifo_size(const struct
+                                            smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Sends data from the given buffer as an Ethernet packet.
+ *        The full packet length must be specified at the beginning
+ *        of a new packet transmission.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in] total_payload_length Length of the ethernet payload.
+ *            Should be equal to the sum of passed buffers within a packet.
+ * \param[in] is_new_packet Should be set to true if the input buffer has to
+ *            be sent as the start of a new packet or as a full packet.
+ * \param[in] data Pointer to the data buffer to be sent.
+ * \param[in] current_size Size of the data in bytes.
+ *
+ * \return error code /ref smsc9220_error_t
+ */
+enum smsc9220_error_t smsc9220_send_by_chunks(
+        const struct smsc9220_eth_dev_t* dev,
+        uint32_t total_payload_length,
+        bool is_new_packet,
+        const char *data, uint32_t current_size);
+
+/**
+ * \brief Reads an incoming Ethernet packet into the given buffer.
+ *        Stops reading at packet border.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ * \param[in,out] data Pointer to a pre-allocated input buffer.
+ *                     Allocating sufficient memory space is the caller's
+ *                     responsibility, which is typically done by calling
+ *                     \ref smsc9220_peek_next_packet_size.
+ * \param[in] dlen Length of the allocated data in bytes.
+ *
+ * \return Number of bytes read from the Rx FIFO into the given buffer.
+ */
+uint32_t smsc9220_receive_by_chunks(const struct smsc9220_eth_dev_t* dev,
+                                        char *data, uint32_t dlen);
+
+/**
+ * \brief Get the used space of Rx fifo in bytes.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ *
+ * \return Data received and waiting for read in bytes
+ */
+uint32_t smsc9220_get_rxfifo_data_used_space(const struct
+                                                 smsc9220_eth_dev_t* dev);
+
+/**
+ * \brief Gets the size of next unread packet in Rx buffer, using the peak
+ *        register, which is not destructive so can be read asynchronously.
+ *        Warning: In case of heavy receiving loads, this register may not
+ *        be in perfect sync.
+ *
+ * \param[in] dev Ethernet device structure \ref smsc9220_eth_dev_t
+ *
+ * \return Size of the next packet in bytes, read from the Rx Peek register.
+ */
+uint32_t smsc9220_peek_next_packet_size(const struct
+                                            smsc9220_eth_dev_t* dev);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SMSC9220_ETH_H__ */
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/target_cfg.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/target_cfg.c
index ece62768..6cbdd941 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/target_cfg.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/target_cfg.c
@@ -24,6 +24,11 @@
 #include "tfm_plat_defs.h"
 #include "region.h"
 
+// FIXME: needed for syscounter init hack
+#include "syscounter_armv8-m_cntrl_drv.h"
+#include "device_cfg.h"
+#include "device_definition.h"
+
 /* Throw out bus error when an access causes security violation */
 #define CMSDK_SECRESPCFG_BUS_ERR_MASK   (1UL << 0)
 
@@ -515,6 +520,17 @@ enum tfm_plat_err_t ppc_init_cfg(void)
                                         PPC_SSE300_NONSECURE_CONFIG,
                                         PPC_SSE300_PRIV_AND_NONPRIV_CONFIG);
 
+    err |= Driver_PPC_SSE300_MAIN_EXP0.ConfigPrivilege(
+                                        USB_AND_ETHERNET_MAIN_PPCEXP0_POS_MASK,
+                                        PPC_SSE300_NONSECURE_CONFIG,
+                                        PPC_SSE300_PRIV_AND_NONPRIV_CONFIG);
+    // err |= Driver_PPC_SSE300_MAIN_EXP0.ConfigPrivilege(
+    //                                     USB_AND_ETHERNET_MAIN_PPCEXP0_POS_MASK,
+    //                                     PPC_SSE300_NONSECURE_CONFIG,
+    //                                     PPC_SSE300_PRIV_AND_NONPRIV_CONFIG);
+
+    syscounter_armv8_m_cntrl_init(&SYSCOUNTER_CNTRL_ARMV8_M_DEV);
+
     /* Initialize not used PPC drivers */
     err |= Driver_PPC_SSE300_MAIN0.Initialize();
     err |= Driver_PPC_SSE300_MAIN_EXP2.Initialize();
-- 
2.25.1

